<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Problem Internals · Quantized System Solver</title><meta name="title" content="Problem Internals · Quantized System Solver"/><meta property="og:title" content="Problem Internals · Quantized System Solver"/><meta property="twitter:title" content="Problem Internals · Quantized System Solver"/><meta name="description" content="Documentation for Quantized System Solver."/><meta property="og:description" content="Documentation for Quantized System Solver."/><meta property="twitter:description" content="Documentation for Quantized System Solver."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Quantized System Solver logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quantized System Solver</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../guide/userTutorial/">Tutorial</a></li><li><a class="tocitem" href="../../guide/userAPI/">User API</a></li></ul></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../../background/introductoryResources/">Introduction to Quantized System Methods</a></li><li><a class="tocitem" href="../../background/qss/">Quantized State System Methods</a></li><li><a class="tocitem" href="../../background/liqss/">Linearly Implicit Quantized State System Methods</a></li><li><a class="tocitem" href="../../background/mliqss/">Modified Linearly Implicit Quantized State System Methods</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/linearTimeInvariantSystem/">Linear Time Invariant</a></li><li><a class="tocitem" href="../../examples/linearTimeInvariantSystemEvents/">Linear Time Invariant with events</a></li><li><a class="tocitem" href="../../examples/vanderpol/">Van der Pol</a></li><li><a class="tocitem" href="../../examples/tysonModel/">The Tyson Model</a></li><li><a class="tocitem" href="../../examples/adr/">ADR problem</a></li><li><a class="tocitem" href="../../examples/dosing/">Conditional Dosing in Pharmacometrics</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../devIntro/">Developer Guide</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">IR model</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../normalize_ir/">Normalize_IR</a></li><li><a class="tocitem" href="../intermediateRepresentation/">IR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox" checked/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">problem construction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../problem/">Problem</a></li><li><a class="tocitem" href="../problemFunction/">Problem Function</a></li><li class="is-active"><a class="tocitem" href>Problem Internals</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../algorithm/">QSS Algorithms</a></li><li><a class="tocitem" href="../solve/">Solve</a></li><li><a class="tocitem" href="../integrator/">Integrators</a></li><li><a class="tocitem" href="../quantizer/">Quantizer</a></li><li><a class="tocitem" href="../solution/">Solution</a></li><li><a class="tocitem" href="../taylor/">Taylor Variables</a></li><li><a class="tocitem" href="../utils/">Utils references</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer resources</a></li><li><a class="is-disabled">problem construction</a></li><li class="is-active"><a href>Problem Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Problem Internals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mongibellili/QuantizedSystemSolver.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/main/docs/src/developer/problem_references.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Problem-Internals"><a class="docs-heading-anchor" href="#Problem-Internals">Problem Internals</a><a id="Problem-Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Internals" title="Permalink"></a></h1><h3 id="Problem-definition"><a class="docs-heading-anchor" href="#Problem-definition">Problem definition</a><a id="Problem-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-definition" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.ODEContProblem" href="#QuantizedSystemSolver.ODEContProblem"><code>QuantizedSystemSolver.ODEContProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ODEContProblem{F,PRTYPE,T,D,Z,CS}</code></pre><p>A struct that holds the continuous problem with tspan. It has the following fields:  </p><ul><li><code>prname</code>: The name of the problem  </li><li><code>prtype</code>: The type of the problem  </li><li><code>a</code>: The size of the problem   </li><li><code>c</code>: The number of discrete vars </li><li><code>b</code>: The number of zero crossing functions </li><li><code>cacheSize</code>: The size of the cache  </li><li><code>initConditions</code>: The initial conditions of the problem  </li><li><code>discreteVars</code> # to match the differentialEqation.jl interface that wants the parameter p to be part of the problem</li><li><code>eqs</code>: The function that holds all the ODEs  </li><li><code>jac</code>: The Jacobian dependency  </li><li><code>SD</code>: The state derivative dependency  </li><li><code>exactJac</code>: The exact Jacobian function  </li><li><code>tspan::Tuple{Float64, Float64}</code>:  This field variable did not exist in the original ODEContProblem as this simulation time should part of the problem. However, to match the differentialEqation.jl interface, the tspan is added to the definition of the problem.</li><li><code>closureFuncs::Vector{F}</code> # function that holds closure function inside system defined by user</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemDefinition.jl#L13-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.ODEDiscProblem" href="#QuantizedSystemSolver.ODEDiscProblem"><code>QuantizedSystemSolver.ODEDiscProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ODEDiscProblem{F,PRTYPE,T,D,Z,CS}</code></pre><p>A struct that holds the Problem of a system of ODEs with a set of events with tspan. It has the following fields:     -<code>prname::Symbol</code>   -<code>prtype::Val{PRTYPE}</code>    -<code>a::Val{T}</code>   -<code>c::Val{D}</code>   -<code>b::Val{Z}</code>    -<code>cacheSize::Val{CS}</code>   -<code>initConditions::Vector{Float64}</code>     -<code>discreteVars::Vector{Float64}</code>      -<code>jac::Vector{Vector{Int}}</code>#Jacobian dependency..I have a der and I want to know which vars affect it...opposite of SD     -<code>ZCjac::Vector{Vector{Int}}</code> # to update other Qs before checking ZCfunction     -<code>eqs::Function</code>#function that holds all ODEs     -<code>eventDependencies::Vector{EventDependencyStruct}</code>    -<code>SD::Vector{Vector{Int}}</code>#  I have a var and I want the der that are affected by it     -<code>HZ::Vector{Vector{Int}}</code>#  an ev occured and I want the ZC that are affected by it     -<code>HD::Vector{Vector{Int}}</code>#  an ev occured and I want the der that are affected by it     -<code>SZ::Vector{Vector{Int}}</code>#  I have a var and I want the ZC that are affected by it     -<code>exactJac::Function</code>#used only in the implicit integration: linear approximation     -<code>tspan::Tuple{Float64, Float64}</code># This field variable did not exist in the original ODEDiscProblem as this simulation time should part of the problem. However, to match the differentialEqation.jl interface, the tspan is added to the definition of the problem.   -<code>closureFuncs::Vector{F}</code> # function that holds closure function inside system defined by user</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemDefinition.jl#L53-L75">source</a></section></article><h3 id="Problem-construction"><a class="docs-heading-anchor" href="#Problem-construction">Problem construction</a><a id="Problem-construction-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-construction" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">The examples of the continuous problem</header><div class="admonition-body"><p>All the examples that explain the problem construction functions use the following problem. The examples are reproducible as they are shown. To see the problem construction process in one step, add <code>print()</code> statements inside the functions of the package while solving this problem as shown in the tutorial section.</p><pre><code class="language-julia hljs">du[1] = u[2]-2.0*u[1]*u[2]
for k in 2:9  
du[k]=u[k]*u[k-1];
end 
du[10]=u[1]-u[10]</code></pre></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.odeProblemFunc-Union{Tuple{EM}, Tuple{D}, Tuple{T}, Tuple{ODEFunctionIR, Val{T}, Val{D}, Val{0}, Vector{Float64}, Union{Vector{EM}, Tuple{Vararg{EM}}}, PreProcessData, Symbol}} where {T, D, EM}" href="#QuantizedSystemSolver.odeProblemFunc-Union{Tuple{EM}, Tuple{D}, Tuple{T}, Tuple{ODEFunctionIR, Val{T}, Val{D}, Val{0}, Vector{Float64}, Union{Vector{EM}, Tuple{Vararg{EM}}}, PreProcessData, Symbol}} where {T, D, EM}"><code>QuantizedSystemSolver.odeProblemFunc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">odeProblemFunc(ir::ODEFunctionIR,::Val{T},::Val{D},::Val{Z},initCond::Vector{Float64},discrVars::Union{Vector{EM}, Tuple{Vararg{EM}}},preProcessData::PreProcessData,jac_mode ::Symbol) where {T,D,Z,EM} 

    continues building a discrete problem. 
It receives an expression and useful info from the main interface. It calls the transform function from the taylorEquationConstruction.jl file to change the AST of all operations to personlized ones and update the needed cache size. It also construct via helper functions the Exact jacobian function, the jacobian dependecy (jac) and the state-derivative dependency (SD:opposite of jacobian), the state to zero-crossing dependency (SZ) and events to derivative and zero-crossing (HD and HZ) as vectors. Finally, it groups all differential equations and events in one function, and constructs a discrete problem from the qssProblemDefinition.jl file.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemDiscrete.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.odeProblemFunc-Union{Tuple{EM}, Tuple{Z}, Tuple{D}, Tuple{T}, Tuple{ODEFunctionIR, Val{T}, Val{D}, Val{Z}, Vector{Float64}, Union{Vector{EM}, Tuple{Vararg{EM}}}, PreProcessData, Symbol}} where {T, D, Z, EM}" href="#QuantizedSystemSolver.odeProblemFunc-Union{Tuple{EM}, Tuple{Z}, Tuple{D}, Tuple{T}, Tuple{ODEFunctionIR, Val{T}, Val{D}, Val{Z}, Vector{Float64}, Union{Vector{EM}, Tuple{Vararg{EM}}}, PreProcessData, Symbol}} where {T, D, Z, EM}"><code>QuantizedSystemSolver.odeProblemFunc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">odeProblemFunc(ir::ODEFunctionIR,::Val{T},::Val{D},::Val{Z},initCond::Vector{Float64},discrVars::Union{Vector{EM}, Tuple{Vararg{EM}}},preProcessData::PreProcessData,jac_mode ::Symbol) where {T,D,Z,EM} 

    continues building a discrete problem. 
It receives an expression and useful info from the main interface. It calls the transform function from the taylorEquationConstruction.jl file to change the AST of all operations to personlized ones and update the needed cache size. It also construct via helper functions the Exact jacobian function, the jacobian dependecy (jac) and the state-derivative dependency (SD:opposite of jacobian), the state to zero-crossing dependency (SZ) and events to derivative and zero-crossing (HD and HZ) as vectors. Finally, it groups all differential equations and events in one function, and constructs a discrete problem from the qssProblemDefinition.jl file.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemDiscrete.jl#L2-L7">source</a></section></article><h3 id="Problem-construction-helpers"><a class="docs-heading-anchor" href="#Problem-construction-helpers">Problem construction helpers</a><a id="Problem-construction-helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-construction-helpers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.changeExprToFirstValue-Tuple{Expr}" href="#QuantizedSystemSolver.changeExprToFirstValue-Tuple{Expr}"><code>QuantizedSystemSolver.changeExprToFirstValue</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">changeExprToFirstValue(ex::Expr)</code></pre><p>changes an expression in the form u[1] to an expression in the form u[1][0] inside exact jacobian expressions and inside events, because linear coefficients (a_{ii}) do not have derivatives, and updates in events affect the value of a variable directly and there is no need to update its higher derivatives. It is called by the <a href="#QuantizedSystemSolver.restoreRef-Tuple{Any, Any}"><code>restoreRef</code></a> function for jacobian expressions, and called by the <a href="#QuantizedSystemSolver.handleEvents-Tuple{Expr, Vector{Expr}, Int64, Vector{EventDependencyStruct}}"><code>handleEvents</code></a> function for events.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver 
ex=:(q[i - 1]) 
newEx=QuantizedSystemSolver.changeExprToFirstValue(ex)

# output

:((q[i - 1])[0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemCommonHelper.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.symbolFromRef-Tuple{Symbol, Union{Int64, Expr, Symbol}}" href="#QuantizedSystemSolver.symbolFromRef-Tuple{Symbol, Union{Int64, Expr, Symbol}}"><code>QuantizedSystemSolver.symbolFromRef</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">symbolFromRef(el::Symbol,refEx::Union{Int64,Expr,Symbol})</code></pre><p>gets a symbol qi, qiplusNumber, qiminusNumber, or qitimesNumber from a symbol i or expressions like i+Number, i+Number, i+Number.  It is called by the <a href="../normalize_ir/#QuantizedSystemSolver.SimpleModelIR.changeVarNames_params-Tuple{Expr, Symbol, Symbol, Symbol, Dict{Symbol, Union{Float64, Int64, Expr, Symbol}}, Set{Symbol}}"><code>changeVarNames_params</code></a>, the <a href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>extractJacDepNormal</code></a> and the <a href="#QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>extractJacDepLoop</code></a> functions</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
ex=:(i - 1) 
newEx=QuantizedSystemSolver.symbolFromRef(:q,ex)
(ex,newEx)

# output

(:(i - 1), :qiminus1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemCommonHelper.jl#L29-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.restoreRef-Tuple{Any, Any}" href="#QuantizedSystemSolver.restoreRef-Tuple{Any, Any}"><code>QuantizedSystemSolver.restoreRef</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">restoreRef(coefExpr,symDict)</code></pre><p>This function is the opposite of symbolFromRef. After using the symbols in symbolic differentiation, it gets back expressions like p[i+Number] and q[i+Number][0] from symbols diplusNumber and qiplusNumber. Adding a zero to q variables is beacause q is a taylor variable while p is a vector.</p><p><strong>arguments:</strong></p><ul><li><code>coefExpr::Expr</code>: the expression to be changed</li><li><code>symDict::Dict{Symbol,Expr}</code>: the dictionary to store the translation of symbols of continous and discrete variables (q[i] &lt;-&gt; qi)</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver

symDict= Dict{Symbol, Expr}(:qi =&gt; :(q[i]), :q10 =&gt; :(q[10]), :q2 =&gt; :(q[2]), :qiminus1 =&gt; :(q[i - 1]), :q1 =&gt; :(q[1]))
coefExpr=:(1.5qiminus1) 
  newEx=QuantizedSystemSolver.restoreRef(coefExpr, symDict)


# output

:(1.5 * (q[i - 1])[0]) </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemCommonHelper.jl#L66-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.handleEvents-Tuple{Expr, Vector{Expr}, Int64, Vector{EventDependencyStruct}}" href="#QuantizedSystemSolver.handleEvents-Tuple{Expr, Vector{Expr}, Int64, Vector{EventDependencyStruct}}"><code>QuantizedSystemSolver.handleEvents</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>handleEvents(argI::Expr,eventequs::Vector{Expr},length_zcequs::Int64,evsArr::Vector{EventDependencyStruct})</p><p>Handles events in the quantized system solver.</p><p><strong>Arguments</strong></p><ul><li><code>argI::Expr</code>: An expression representing the &#39;if-statement&#39;.</li><li><code>eventequs::Vector{Expr}</code>: A vector of expressions representing the event equations.</li><li><code>length_zcequs::Int64</code>: current number of treated zero-crossing equations. Usezd as index to store the events in order.</li><li><code>evsArr</code>: An array containing EventDependencyStruct  objects.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemDiscreteHelper.jl#L81-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.transformFSimplecase-Tuple{Union{Float64, Int64, Expr, Symbol}}" href="#QuantizedSystemSolver.transformFSimplecase-Tuple{Union{Float64, Int64, Expr, Symbol}}"><code>QuantizedSystemSolver.transformFSimplecase</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transformFSimplecase(ex::Union{Float64,Int64,Expr,Symbol})</code></pre><p>transforms expressions of the right hand side of differential equations and zero-crossing functions to personalized ones that use caching to a form that can be used in the <a href="../taylor/#QuantizedSystemSolver.createT-Tuple{Taylor0, Taylor0}"><code>createT</code></a> function. The right hand side of the equations should be a number or a q[i] term.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
ex=:(q[2])
newEx=QuantizedSystemSolver.transformFSimplecase(ex);


# output

:(createT(q[2], cache[1])) 
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/taylorEquationConstruction.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.transformF-Tuple{Expr}" href="#QuantizedSystemSolver.transformF-Tuple{Expr}"><code>QuantizedSystemSolver.transformF</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transformF(ex::Expr)</code></pre><p>transforms expressions of the right hand side of differential equations and zero-crossing functions to personalized ones that use caching to a form that can be used in functions like  <a href="../taylor/#QuantizedSystemSolver.addT-Tuple{Taylor0, Taylor0, Taylor0}"><code>addT</code></a>, <a href="../taylor/#QuantizedSystemSolver.subT-Tuple{Taylor0, Taylor0, Taylor0}"><code>subT</code></a>, <a href="../taylor/#QuantizedSystemSolver.mulT-Tuple{Taylor0, Taylor0, Taylor0}"><code>mulT</code></a>, <a href="../taylor/#QuantizedSystemSolver.muladdT-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{P, Q, R, Taylor0}} where {P, Q, R&lt;:Union{Number, Taylor0}}"><code>muladdT</code></a>. The right hand side of the equations can be any form of expression.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
ex=:(q[2] - 2.0*q[1]*q[2],1)
newEx=QuantizedSystemSolver.transformF(ex);


# output

:((subT(q[2], mulTT(2.0, q[1], q[2], cache[2], cache[3]), cache[1]), 3))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/taylorEquationConstruction.jl#L42-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createJacVect-Union{Tuple{T}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{T}}} where T" href="#QuantizedSystemSolver.createJacVect-Union{Tuple{T}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{T}}} where T"><code>QuantizedSystemSolver.createJacVect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createJacVect(jac:: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},::Val{T}) where {T}</code></pre><p>constructs the jacobian dependency as a vector from the existing dictionary jac resulted from <a href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>extractJacDepNormal</code></a> and <a href="#QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>extractJacDepLoop</code></a> functions. </p><p>This function just collects the data from the value of the dictionary if the key of the dictionary is an integer. (a dictionary contains(key=&gt;value),...). In the case it is an expression :(b,niter), the function uses a &#39;for&#39; loop to replace each &#39;b&#39; by its corresponding integer. This approach depends on the size of the problem, but it runs one time.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
jac=Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(1 =&gt; Set([2, 1]),:((2, 9)) =&gt; Set([:(i - 1), :i]),10 =&gt; Set([1, 10]))
jacVect=QuantizedSystemSolver.createJacVect(jac,Val(10) )
string(jacVect)

# output

&quot;[[2, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [10, 1]]&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemCommonHelper.jl#L248-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createSDVect-Union{Tuple{T}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{T}}} where T" href="#QuantizedSystemSolver.createSDVect-Union{Tuple{T}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{T}}} where T"><code>QuantizedSystemSolver.createSDVect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createSDVect(jac:: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},::Val{T}) where {T}</code></pre><p>constructs the State to derivative dependency (opposite of jacobian dependency) as a vector from the existing dictionary jac resulted from the <a href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>extractJacDepNormal</code></a> and the <a href="#QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>extractJacDepLoop</code></a> functions. It is the opposite in the sense that here we collect the keys into some vectors whereas in the jacobian dependency we collect the values of the dictionary in some vectors. </p><p>If the key of the dictionary is an integer, then for all elements &#39;k&#39; in the value of the dictionary (a set), the key is pushed into a new vector indexed at &#39;k&#39;. In the case the key is an expression :(b,niter), the function uses a &#39;for&#39; loop to replace each &#39;b&#39; by its corresponding integer. This approach depends on the size of the problem, but it runs one time.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
jac=Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(1 =&gt; Set([2, 1]),:((2, 9)) =&gt; Set([:(i - 1), :i]),10 =&gt; Set([1, 10]));
SD=QuantizedSystemSolver.createSDVect(jac,Val(10) );
string(SD)

# output

&quot;[[10, 2, 1], [2, 3, 1], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9], [10]]&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemCommonHelper.jl#L294-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createExactJacFun-Tuple{Expr, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Any}" href="#QuantizedSystemSolver.createExactJacFun-Tuple{Expr, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Any}"><code>QuantizedSystemSolver.createExactJacFun</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createExactJacFun(otherCode::Expr,Exactjac:: Dict{Expr,Union{Float64,Int,Symbol,Expr}},funName::Symbol,f)</code></pre><p>constructs the exact jacobian entries as a function from the existing dictionary Exactjac resulted from extractJacDepNormal and extractJacDepLoop functions. </p><p>From the input dictionary exactJac, we see that the key is always a expression that hold a tuple of size 2: the first element is going to be the index &#39;i&#39; and the second element if the index &#39;j&#39;. The value corresponding to this key, which is the exact jacobian entry, is put in a cache. i.e the function maps the keys of the dictionary to their values using an &#39;if-statement.. This approach does not depend on the size of the problem.     # Example:   </p><pre><code class="language-julia hljs">using QuantizedSystemSolver
exacteJacExpr=Dict{Expr,Union{Float64,Int,Symbol,Expr}}(:((1, 1)) =&gt; :(-2.0 * (q[2])[0]), :((1, 2)) =&gt; :(1 - 2.0 * (q[1])[0]),:(((2, 9), i - 1)) =&gt; :((q[i])[0]), :(((2, 9), i)) =&gt; :((q[i - 1])[0]),:((10, 10)) =&gt; -1, :((10, 1)) =&gt; 1);
exactJac=QuantizedSystemSolver.createExactJacFun(:(),exacteJacExpr,:f,0);
exactJac

# output

:(function exactJacf(q::Vector{Taylor0}, p::Vector{Float64}, cache::AbstractVector{Float64}, i::Int, j::Int, t::Float64, f_)
      (if i == 0
              return nothing
          elseif i == 1 &amp;&amp; j == 1
              cache[1] = -2.0 * (q[2])[0]
              return nothing
          elseif i == 10 &amp;&amp; j == 10
              cache[1] = -1
              return nothing
          elseif 2 &lt;= i &lt;= 9 &amp;&amp; j == i - 1
              cache[1] = (q[i])[0]
              return nothing
          elseif i == 1 &amp;&amp; j == 2
              cache[1] = 1 - 2.0 * (q[1])[0]
              return nothing
          elseif 2 &lt;= i &lt;= 9 &amp;&amp; j == i
              cache[1] = (q[i - 1])[0]
              return nothing
          elseif i == 10 &amp;&amp; j == 1
              cache[1] = 1
              return nothing
          end,)
  end)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemCommonHelper.jl#L340-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createContEqFun-Tuple{Expr, Dict{Union{Int64, Expr}, Union{Int64, Expr, Symbol}}, Symbol, Any}" href="#QuantizedSystemSolver.createContEqFun-Tuple{Expr, Dict{Union{Int64, Expr}, Union{Int64, Expr, Symbol}}, Symbol, Any}"><code>QuantizedSystemSolver.createContEqFun</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createContEqFun(otherCode::Expr,equs::Dict{Union{Int,Expr},Union{Int,Symbol,Expr}},fname::Symbol,f)</code></pre><p>constructs one function from all differential equations in the problem, which are transformed and stored in a dictionary in the NLodeProblemFunc function.</p><p>The function maps the keys of the dictionary to their values using an &#39;if-statement.     # Example:   </p><pre><code class="language-julia hljs">using QuantizedSystemSolver
equs = Dict{Union{Int,Expr},Union{Int,Symbol,Expr}}(10 =&gt; :(subT(q[1], q[10], cache[1])), :((2, 9)) =&gt; :(mulT(q[i], q[i - 1], cache[1])), 1 =&gt; :(subT(q[2], mulTT(2.0, q[1], q[2], cache[2], cache[3]), cache[1])));
diffEqfun=QuantizedSystemSolver.createContEqFun(:(),equs,:f,0); 
diffEqfun 

# output

:(function f(i::Int, q::Vector{Taylor0}, p::Vector{Float64}, t::Taylor0, cache::Vector{Taylor0}, f_)    
      (if i == 0
              return nothing
          elseif i == 10
              subT(q[1], q[10], cache[1])
              return nothing
          elseif 2 &lt;= i &lt;= 9
              mulT(q[i], q[i - 1], cache[1])
              return nothing
          elseif i == 1
              subT(q[2], mulTT(2.0, q[1], q[2], cache[2], cache[3]), cache[1])
              return nothing
          end,)
  end)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemContinuousHelper.jl#L2-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}" href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>QuantizedSystemSolver.extractJacDepNormal</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extractJacDepNormal(varNum::Int,rhs::Expr,jac :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},exactJacExpr :: Dict{Expr,Union{Float64,Int,Symbol,Expr}},jac_mode ::Symbol,symDict::Dict{Symbol,Expr},dD :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}})</code></pre><p>Extracts the jacobian dependency (jac) as well as the exacte symbolic jacobian expression (exactJacExpr) and the dependency of state derivatives to discrete variables (dD), in the form of dictionaries, from the simple differential equations.</p><p>For the continuous part, similar to <a href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>extractJacDepNormal</code></a>  function, this function sarts by looking for the &#39;i&#39; in q[i] in the RHS and storing this &#39;i&#39; in a jacSet for the varNum. Then, it changes q[i] to qi for symbolic differentiation. After finding <span>$\frac{\partial f_i}{\partial q_i}$</span> as the exact jacobian entry, it changes back qi to q[i]. Also, any mute variable from the differential equations is changed to &#39;i&#39;.</p><p>For the discrete part, the function puts the index of the differential equation in a set, and stores this set in a dictionary dD with the key being the index of the discrete variable.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
(varNum, rhs, jac, exactJacExpr, symDict, dD) = (1, :(p[2] - 2.0 * q[1] * p[2]), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(), Dict{Symbol, Expr}(:q10 =&gt; :(q[10]), :p2 =&gt; :(p[2]), :qiminus1 =&gt; :(q[i - 1]), :p1 =&gt; :(p[1]), :q1 =&gt; :(q[1])), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}())
QuantizedSystemSolver.extractJacDepNormal(varNum, rhs, jac, exactJacExpr,:symbolic, symDict, dD )
(jac, exactJacExpr, dD) 

# output

(Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(1 =&gt; Set([1])), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(:((1, 1)) =&gt; :(-2.0 * p[2])), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(2 =&gt; Set([1])))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemCommonHelper.jl#L127-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}" href="#QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>QuantizedSystemSolver.extractJacDepLoop</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extractJacDepLoop(b::Int,niter::Int,rhs::Expr,jac :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},exactJacExpr :: Dict{Expr,Union{Float64,Int,Symbol,Expr}},jac_mode ::Symbol,symDict::Dict{Symbol,Expr},dD :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}})</code></pre><p>This function is similar to the <a href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>extractJacDepNormal</code></a>  function by using the tuple (b,niter) instead of the integer varNum. Itextracts the jacobian dependency (jac) as well as the exacte symbolic jacobian expression (exactJacExpr) and the dependency of state derivatives to discrete variables (dD), in the form of dictionaries, from the differential equations that are written in a loop.</p><p>For the continuous part, it sarts by looking for the &#39;i&#39; in q[i] in the RHS and storing this &#39;i&#39; in a jacSet. Then, it changes q[i] to qi for symbolic differentiation. After finding <span>$\frac{\partial f_i}{\partial q_i}$</span> as the exact jacobian entry, it changes back qi to q[i]. Also, any mute variable from the differential equations is changed to &#39;i&#39;.</p><p>For the discrete part, the function puts the the tuple (b,niter) in a set, and stores this set in a dictionary dD with the key being the index of the discrete variable.     # Example:</p><pre><code class="language-julia hljs">using QuantizedSystemSolver
(b, niter, rhs, jac, exactJacExpr, symDict, dD) = (2, 9, :(p[1] * q[i - 1] * 1.5), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(1 =&gt; Set([1])), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(:((1, 1)) =&gt; :(-2.0 * p[2])), Dict{Symbol, Expr}(:q10 =&gt; :(q[10]), :p2 =&gt; :(p[2]), :qiminus1 =&gt; :(q[i - 1]), :p1 =&gt; :(p[1]), :q1 =&gt; :(q[1])), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(2 =&gt; Set([1])))
QuantizedSystemSolver.extractJacDepLoop(b, niter, rhs, jac, exactJacExpr,:symbolic, symDict, dD )
(jac, exactJacExpr, dD) 

# output

(Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(:((2, 9)) =&gt; Set([:(i - 1)]), 1 =&gt; Set([1])), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(:((1, 1)) =&gt; :(-2.0 * p[2]), :(((2, 9), i - 1)) =&gt; :(1.5 * p[1])), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(2 =&gt; Set([1]), 1 =&gt; Set([:((2, 9))])))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemCommonHelper.jl#L186-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.extractZCJacDep-Tuple{Int64, Expr, Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Dict{Int64, Set{Int64}}}" href="#QuantizedSystemSolver.extractZCJacDep-Tuple{Int64, Expr, Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Dict{Int64, Set{Int64}}}"><code>QuantizedSystemSolver.extractZCJacDep</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extractZCJacDep(counter::Int,zcf::Expr,zcjac :: Vector{Vector{Int}},SZ ::Dict{Int,Set{Int}},dZ :: Dict{Int,Set{Int}})</code></pre><p>Extracts the zero-crossing jacobian dependency as a vector (zcjac), the dependency of the zero-crossing functions to continuous (SZ) and discrete variables (dZ) in the form of dictionaries, from the &#39;if-statements&#39; (zcf).</p><p>The zcjac is a vector of vectors, where each vector contains the indices of the continuous variables that the zero-crossing function depends on. The SZ dictionary contains the indices of the zero-crossing functions as values and the indices of the continuous variables as keys. Similarly, the dZ dictionary contains the indices of the zero-crossing functions as values and the indices of the discrete variables as keys.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
(counter, zcf, zcjac, SZ, dZ) = (2, :(q[2] - p[1]), [[1]], Dict{Int64, Set{Int64}}(1 =&gt; Set([1])), Dict{Int64, Set{Int64}}())
QuantizedSystemSolver.extractZCJacDep(counter, zcf, zcjac, SZ, dZ)
(zcjac, SZ, dZ) 

# output

([[1], [2]], Dict{Int64, Set{Int64}}(2 =&gt; Set([2]), 1 =&gt; Set([1])), Dict{Int64, Set{Int64}}(1 =&gt; Set([2])))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemDiscreteHelper.jl#L32-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.EventDependencyStruct" href="#QuantizedSystemSolver.EventDependencyStruct"><code>QuantizedSystemSolver.EventDependencyStruct</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EventDependencyStruct</code></pre><p>A struct that holds the event dependency information. It has the following fields:</p><ul><li><code>id::Int:</code> the id of the event</li><li><code>evCont::Vector{Int}:</code> the index tracking used for HD &amp; HZ. Also it is used to update q,quantum,recomputeNext when x is modified in an event</li><li><code>evDisc::Vector{Int}:</code> the index tracking used for HD &amp; HZ.</li><li><code>evContRHS::Vector{Int}:</code> the index tracking used to update other Qs before executing the event</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemDiscreteHelper.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createSZVect-Union{Tuple{T}, Tuple{Dict{Int64, Set{Int64}}, Val{T}}} where T" href="#QuantizedSystemSolver.createSZVect-Union{Tuple{T}, Tuple{Dict{Int64, Set{Int64}}, Val{T}}} where T"><code>QuantizedSystemSolver.createSZVect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createSZVect(SZ :: Dict{Int64, Set{Int64}},::Val{T}) where {T}</code></pre><p>constructs the zero-crossing dependency to state variables as a vector from the existing dictionary SZ resulted from the <a href="#QuantizedSystemSolver.extractZCJacDep-Tuple{Int64, Expr, Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Dict{Int64, Set{Int64}}}"><code>extractZCJacDep</code></a> function. The continuous variables are the keys and the zero-crossing are the values.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
(SZ, T) = (Dict{Int64, Set{Int64}}(2 =&gt; Set([2]), 1 =&gt; Set([1])), 10)
szVec=QuantizedSystemSolver.createSZVect(SZ, Val(T))
string(szVec)

# output

&quot;[[1], [2], Int64[], Int64[], Int64[], Int64[], Int64[], Int64[], Int64[], Int64[]]&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemDiscreteHelper.jl#L186-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createdDVect-Union{Tuple{D}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{D}}} where D" href="#QuantizedSystemSolver.createdDVect-Union{Tuple{D}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{D}}} where D"><code>QuantizedSystemSolver.createdDVect</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createdDVect(dD::Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}},::Val{D}) where {D}</code></pre><p>constructs the State to derivative dependency to discrete variables as a vector from the existing dictionary dD resulted from the <a href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>extractJacDepNormal</code></a> and the <a href="#QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>extractJacDepLoop</code></a> functions. The discrete variables are the keys and the differential equations are the values. This dependency is needed only in <a href="#QuantizedSystemSolver.createDependencyToEventsDiscr-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}"><code>createDependencyToEventsDiscr</code></a>  .</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
(dD, D) = (Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(2 =&gt; Set([10, 1]), 1 =&gt; Set([:((2, 9))])), 2)
dDVect=QuantizedSystemSolver.createdDVect(dD, Val(D) )
string(dDVect)

# output

&quot;[[2, 3, 4, 5, 6, 7, 8, 9], [10, 1]]&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemDiscreteHelper.jl#L213-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createDependencyToEventsDiscr-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}" href="#QuantizedSystemSolver.createDependencyToEventsDiscr-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}"><code>QuantizedSystemSolver.createDependencyToEventsDiscr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createDependencyToEventsDiscr(dD::Vector{Vector{Int}},dZ::Dict{Int64, Set{Int64}},eventDep::Vector{EventDependencyStruct})</code></pre><p>constructs the dependency of zero-crossing functions and state derivatives to events using only discrete variables.</p><p><strong>arguments</strong></p><ul><li><code>dD::Vector{Vector{Int}}:</code> the dependency of state derivatives to discrete variables as a vector</li><li><code>dZ::Dict{Int64, Set{Int64}}:</code> the dependency of zero-crossing functions to discrete variables as a dictionary</li><li><code>eventDep::Vector{EventDependencyStruct}:</code> the event dependency information as a vector of structs</li></ul><p><strong>returns</strong></p><ul><li><p><code>HZ1::Vector{Vector{Int}}:</code> the dependency of zero-crossing functions to events using only discrete variables</p></li><li><p><code>HD1::Vector{Vector{Int}}:</code> the dependency of differential equations to events using only discrete variables</p><p><strong>Example:</strong></p></li></ul><pre><code class="language-julia hljs">using QuantizedSystemSolver
(dD, dZ, eventDep) = ([[2, 3, 4, 5, 6, 7, 8, 9], [10, 1]], Dict{Int64, Set{Int64}}(1 =&gt; Set([2])), QuantizedSystemSolver.EventDependencyStruct[QuantizedSystemSolver.EventDependencyStruct(1, Int64[], [1], Int64[]), QuantizedSystemSolver.EventDependencyStruct(2, Int64[], Int64[], Int64[]), QuantizedSystemSolver.EventDependencyStruct(3, [3], [2], [3, 1, 2]), QuantizedSystemSolver.EventDependencyStruct(4, Int64[], Int64[], Int64[])])
(HZ1, HD1) =QuantizedSystemSolver.createDependencyToEventsDiscr(dD, dZ, eventDep )
(HZ1, HD1) 

# output

([[2], Int64[], Int64[], Int64[]], [[5, 4, 6, 7, 2, 9, 8, 3], Int64[], [10, 1], Int64[]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemDiscreteHelper.jl#L250-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createDependencyToEventsCont-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}" href="#QuantizedSystemSolver.createDependencyToEventsCont-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}"><code>QuantizedSystemSolver.createDependencyToEventsCont</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">createDependencyToEventsCont(SD::Vector{Vector{Int}},sZ::Dict{Int64, Set{Int64}},eventDep::Vector{EventDependencyStruct})</code></pre><p>constructs the dependency of zero-crossing functions and state derivatives to events using only continuous variables.</p><p><strong>arguments</strong></p><ul><li><code>SD::Vector{Vector{Int}}:</code> the dependency of state derivatives to continuous variables as a vector</li><li><code>sZ::Dict{Int64, Set{Int64}}:</code> the dependency of zero-crossing functions to continuous variables as a dictionary</li><li><code>eventDep::Vector{EventDependencyStruct}:</code> the event dependency information as a vector of structs</li></ul><p><strong>returns</strong></p><ul><li><p><code>HZ2::Vector{Vector{Int}}:</code> the dependency of zero-crossing functions to events using only continuous variables</p></li><li><p><code>HD2::Vector{Vector{Int}}:</code> the dependency of differential equations to events using only continuous variables</p><p><strong>Example:</strong></p></li></ul><pre><code class="language-julia hljs">using QuantizedSystemSolver
(SD, sZ, eventDep) = ([[10, 2, 1], [3], [4], [5], [6], [7], [8], [9], Int64[], [10]], Dict{Int64, Set{Int64}}(2 =&gt; Set([2]), 1 =&gt; Set([1])), QuantizedSystemSolver.EventDependencyStruct[QuantizedSystemSolver.EventDependencyStruct(1, Int64[], [1], Int64[]), QuantizedSystemSolver.EventDependencyStruct(2, Int64[], Int64[], Int64[]), QuantizedSystemSolver.EventDependencyStruct(3, [3], [2], [3, 1, 2]), QuantizedSystemSolver.EventDependencyStruct(4, Int64[], Int64[], Int64[])])
(HZ2, HD2) =QuantizedSystemSolver.createDependencyToEventsCont(SD, sZ, eventDep)
(HZ2, HD2) 

# output

([Int64[], Int64[], Int64[], Int64[]], [Int64[], Int64[], [4], Int64[]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemDiscreteHelper.jl#L306-L330">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.unionDependency-Tuple{Vector{Vector{Int64}}, Vector{Vector{Int64}}}" href="#QuantizedSystemSolver.unionDependency-Tuple{Vector{Vector{Int64}}, Vector{Vector{Int64}}}"><code>QuantizedSystemSolver.unionDependency</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unionDependency(HZD1::Vector{Vector{Int}},HZD2::Vector{Vector{Int}})</code></pre><p>merges the state derivatives and zero-crossing functions dependencies to events using both continuous and discrete variables.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
(HD1, HD2) = ([[5, 4, 6, 7, 2, 9, 8, 3], Int64[], [10, 1], Int64[]], [Int64[], Int64[], [4], Int64[]])
HD=QuantizedSystemSolver.unionDependency(HD1, HD2)
string(HD)

# output

&quot;[[5, 4, 6, 7, 2, 9, 8, 3], Int64[], [4, 10, 1], Int64[]]&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/problem/qssProblemDiscreteHelper.jl#L361-L376">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="../problem/#QuantizedSystemSolver.ODEProblemData"><code>QuantizedSystemSolver.ODEProblemData</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../problemFunction/">« Problem Function</a><a class="docs-footer-nextpage" href="../algorithm/">QSS Algorithms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 12 July 2025 19:00">Saturday 12 July 2025</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
