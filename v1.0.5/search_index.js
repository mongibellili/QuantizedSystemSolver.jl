var documenterSearchIndex = {"docs":
[{"location":"background/liqss/#Linearly-Implicit-Quantized-State-System-Methods","page":"Linearly Implicit Quantized State System Methods","title":"Linearly Implicit Quantized State System Methods","text":"","category":"section"},{"location":"background/liqss/","page":"Linearly Implicit Quantized State System Methods","title":"Linearly Implicit Quantized State System Methods","text":"Despite their advantages, explicit QSS methods are inefficient in solving stiff systems. In order to deal with stiffness, LiQSS evaluates the state derivative at future instants using a future quantized state value, as in classic implicit algorithms. The quantized state becomes a future value of the state and it is calculated smarter [2]. ","category":"page"},{"location":"background/liqss/#LIQSS1","page":"Linearly Implicit Quantized State System Methods","title":"LIQSS1","text":"","category":"section"},{"location":"background/liqss/","page":"Linearly Implicit Quantized State System Methods","title":"Linearly Implicit Quantized State System Methods","text":"In first order, we either add or subtract the quantum Delta to the quantized state, and when when we sense a change of the derivative, we set the derivative equals to zero. ","category":"page"},{"location":"background/liqss/","page":"Linearly Implicit Quantized State System Methods","title":"Linearly Implicit Quantized State System Methods","text":"beginequation*\n q_i=begincases\n  x_impDelta_i  if  dot x_i  tildef_i(x_impDelta_i) 0  \n  frac-u_iia_ii  otherwise\nendcases \nendequation*","category":"page"},{"location":"background/liqss/","page":"Linearly Implicit Quantized State System Methods","title":"Linearly Implicit Quantized State System Methods","text":"where tildef_i=a_iiq_i+u_ii  is a linear approximation of the derivative function f_i at the future instant. ","category":"page"},{"location":"background/liqss/","page":"Linearly Implicit Quantized State System Methods","title":"Linearly Implicit Quantized State System Methods","text":"The LIQSS order 1 method is defined in the following Algorithm: LIQSS1 algorithm","category":"page"},{"location":"background/liqss/","page":"Linearly Implicit Quantized State System Methods","title":"Linearly Implicit Quantized State System Methods","text":"If a variable i needs to change\nCompute the elapsed time e since the last update of variable i\nUpdate its value using Taylor expansion: x_i=x_i+dot x_ie\nUpdate the quantum Delta_i\nIf dot x  (a_ii(x_i+sign(dot x)Delta_i)+u_ii) 0\nUpdate the Quantized variable q_i=x_i+sign(dot x)Delta_i\nElse\nUpdate the Quantized variable q_i=frac-u_iia_ii   \nCompute the next time when q_i=x_i \nFor {any variable j depends on i}\nUpdate the variable x_j=x_j+dot x_je_j\nUpdate the derivative dot x_j=f_j(qt) \nCompute the next time when q_j=x_j  or q_j-x_j=2Delta_i \nFor {any zero crossing function zc depends on i}\nUpdate zc\nCompute the next event time of zc \nIf an event needs to occur\nRecheck validity of the event\nExecute the event and update the related quantized variables\nFor any variable j depends on the event\nUpdate the variable x_j=x_j+dot x_je_j\nUpdate the derivative dot x_j=f_j(Qt) \nCompute the next time when q_j=x_j  or q_j-x_j=2Delta_j \nFor any zero crossing function zc depends on the event\nUpdate zc\nCompute the next event time of zc ","category":"page"},{"location":"background/liqss/#LIQSS2","page":"Linearly Implicit Quantized State System Methods","title":"LIQSS2","text":"","category":"section"},{"location":"background/liqss/","page":"Linearly Implicit Quantized State System Methods","title":"Linearly Implicit Quantized State System Methods","text":"In Order 2, the updates involve not only the first-order variables but also their second-order derivatives. Similar to Order 1, these updates depend on the future behavior of the state variables, but with a focus on both their positions and rates of change as reflected in the second-order derivative terms. To define LIQSS2, we need to consider the second derivative of the state variables. The linear approximation of the future second derivative is given as follows: ddot x_i=a_iidot q_i+dot u_ii.","category":"page"},{"location":"background/liqss/","page":"Linearly Implicit Quantized State System Methods","title":"Linearly Implicit Quantized State System Methods","text":"The LIQSS order 2 method is defined in the following Algorithm. LIQSS2 algorithm ","category":"page"},{"location":"background/liqss/","page":"Linearly Implicit Quantized State System Methods","title":"Linearly Implicit Quantized State System Methods","text":"If a variable i needs to change\nCompute the elapsed time e since the last update of variable i\nUpdate the variable x_i=x_i+dot x_ie_i+frac12ddot x_ie_i^2\nUpdate the quantum Delta_i\nUpdate the derivative dot x_i=dot x_i+ddot x_ie\nUpdate the affine coefficient u_ii = dot x_i - a_ii  (q_i+dot q_ie_i)\nUpdate the derivative of the affine coefficient dot u_ii = ddot x_i - a_ii  dot q_i\nThe Quantized variable q_i(h)=frac(x_i-ha_iix_i-h^2(au_ii+dot u_ii)2)(1 - h  a_ii + h^2a_ii^2  2)\nUpdate the step size h=FinalSimulationTime-currentSimTime;  q_i=q_i(h)\nIf {q_i-x_iDelta_i}\nUpdate the Quantized variable h=sqrtfrac2Delta_iddx_i;  q_i=q_i(h)\nWhile q_i-x_iDelta_i\nUpdate the Quantized variable h=hsqrtfracDelta_iq_i-x_i;  q_i=q_i(h)\nUpdate the Quantized derivative dot q_i=fraca_iiq_i+u_ii+hdot u_ii1-ha_ii\nCompute the next time when q_i=x_i \nFor any variable j depends on i\nUpdate the variable x_j=x_j+dot x_je_j+frac12ddot x_je_j^2\nFor {any variable k that f_j depends upon}\nUpdate the Quantized variable q_k=q_k+dot q_ke_k \nUpdate the derivatives dot x_j=f_j(qt)  and ddot x_j=dot f_j(Qt) \nCompute the next time when q_j=x_j  or q_j-x_j=2Delta_i \nFor any zero crossing function zc depends on i\nFor {any variable k that zc depends upon}\nUpdate the Quantized variable q_k=q_k+dot q_ke_k\nUpdate zc\nCompute the next event time of zc \nIf an event needs to occur\nRecheck validity of the event\nExecute the event and update the related quantized variables\nFor any variable j depends on the event\nUpdate the variable x_j=x_j+dot x_je_j+frac12ddot x_je_j^2\nFor any variable k that f_j depends upon\nUpdate the Quantized variable q_k=q_k+dot q_ke_k\nUpdate the derivatives dot x_j=f_j(Qt)  and ddot x_j=dot f_j(Qt) \nCompute the next time when q_j=x_j  or q_j-x_j=2Delta_j \nFor any zero crossing function zc depends on the event\nFor any variable k that zc depends upon\nUpdate the Quantized variable q_k=q_k+dot q_ke_k\nUpdate zc\nCompute the next event time of zc ","category":"page"},{"location":"background/liqss/#refs2","page":"Linearly Implicit Quantized State System Methods","title":"References","text":"","category":"section"},{"location":"background/liqss/","page":"Linearly Implicit Quantized State System Methods","title":"Linearly Implicit Quantized State System Methods","text":"[1]  Migoni, G., Kofman, E., and Cellier, F. (2012). Quantization-based new integration methods for stiff odes. Simulation: Transactions of the Society for Modeling and Simulation International, 88(4):378–407.","category":"page"},{"location":"background/liqss/","page":"Linearly Implicit Quantized State System Methods","title":"Linearly Implicit Quantized State System Methods","text":"[2]  G. Migoni, M. Bortolotto, E. Kofman, and F. Cellier. Linearly implicit quantization-based integration methods for stiff ordinary differential equations. Simulation Modelling Practice and Theory, vol.35:pp.118–136, 2013.","category":"page"},{"location":"background/introductoryResources/#Introduction-to-Quantized-System-Methods","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"","category":"section"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"QSS methods, including LIQSS, are alternatives to traditional integration methods for solving ordinary differential equations (ODE). These methods are specially designed to solve challenges posed by the increasing complexity of modern systems. These methods offer advantages such as reduced computational cost and improved performance compared to traditional numerical integration methods in large sparse and stiff systems with frequent discontinuities. ","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"The main idea behind QSS methods is to divide the system state space into quantized regions and represent the system state in terms of these quantized values. The quantization of the states leads to an asynchronous discrete-event simulation model instead of a discrete time difference equation model. The QSS methods update the system status only when certain thresholds or conditions are met, instead of continuously simulating the system's behavior. All state derivatives remain constant if the states or inputs do not cross the next threshold, and the time of the crossing can be computed explicitly. QSS algorithms are asynchronous because The time, at which a state variable reaches its next threshold is different for separate states. For instance, state variables with large gradients will get to their thresholds more frequently than states with small gradients. If a state or input gets to its next threshold, a discrete event is triggered, and information is passed on to other integrators that depend on it [1].","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"In solving the following system of n ODEs in Eq.(1), classic methods look for the values of all variables after a small elapsed time, while QSS methods search for the time it takes to change the value of one variable by a small quantity. ","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"beginequation\n   dot X=f(Xt)  \nendequation","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"where X=x_1x_2x_n^T is the state vector, fmathbbR^n times mathbbR^+  rightarrow mathbbR^n is the derivative function, and t is the independent variable. In classic methods, the difference between t_k (the current time) and t_k+1 (the next time) is called the step size.  In QSS, besides the step size, the difference between x_i(t_k) (the current value) and x_i(t_k+1) (the next value) is called the quantum Delta_i. Depending on the type of the QSS method (explicit or implicit), a new variable q_i is set to equal x_i(t_k)  or x_i(t_k+1) respectively.  q_i is called the quantized state of x_i. The use of the quantized state q_i as the future value x_i to calculate the derivatives is what makes the method implicit.  Instead of solving the system shown in Eq.(1), QSS methods solve the following system in Eq.(2):","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"beginalign\n   dot X=f(Qt)  \nendalign","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"where Q=q_1q_2q_n^T is the Quantized state vector.","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"The general form of a problem composed of a set of ODEs and a set of events that QSS is able to solve is described in the following: ","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"System of n ODEs:","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"beginalign*\n   dot X=f(XDt)  \nendalign*","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"System of v events:","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"beginalign*\n if  zc_v(x_id_pt)  i in 1n      p  in 1m \n qquad x_i=H(x_id_pt) \n qquad qquad\n qquad d_p=L(x_id_pt)  \n qquad qquad\nendalign*","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"where n and m are the number of state variables and discrete variables of the system respectively. D=d_1d_2d_m^T is the vector of the system discrete variables. v is the number of events and zc is an event condition, H and L are functions used in the effects of the event zc.","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"QSS methods were shown to have nice stability and error bound properties and they outperformed some classic solvers [2].","category":"page"},{"location":"background/introductoryResources/#refs1","page":"Introduction to Quantized System Methods","title":"References","text":"","category":"section"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"[1] Cellier, F. and Kofman, E. (2006). Continuous system. Springer, simulation.New York.","category":"page"},{"location":"background/introductoryResources/","page":"Introduction to Quantized System Methods","title":"Introduction to Quantized System Methods","text":"[2]  Kofman, E. (2009). Relative error control in quantization based integration. Latin American Applied Research, 39(no.3):pp.231–238.","category":"page"},{"location":"developer/intermediateRepresentation/#IR","page":"IR","title":"IR","text":"","category":"section"},{"location":"developer/intermediateRepresentation/#Goal:-separate-the-problem-parsing-from-the-problem-construction.","page":"IR","title":"Goal: separate the problem parsing from the problem construction.","text":"","category":"section"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"problem parsing is delegated to a new Module named SimpleModelIR:","category":"page"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"module SimpleModelIR\nusing MacroTools: postwalk \ninclude(\"utils.jl\")\ninclude(\"types.jl\")\ninclude(\"build_ir.jl\")\ninclude(\"normalize_ir.jl\")\nexport\n    AbstractODEStatement,\n    AssignStatement,\n    IfStatement,\n    ForStatement,\n    WhileStatement,\n    ExprStatement,\n    ODEFunctionIR,\n    build_ir,\n    normalize_ir,\n    problem_to_normalized_ir,\nend","category":"page"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"The buildir_ function loops through the user code expression and builds an ODEFunctionIR(statement). i.e the expression will be changed to a vector of statements. Each statement is an object of type ....<: AbstractODEStatement The normalizeir_ function loops over the vectors and call personalized functions such as changeVarNamesparams_ or normalizeifstatement! to change composite if-statements to simple if-statements.","category":"page"},{"location":"developer/intermediateRepresentation/#Example:","page":"IR","title":"Example:","text":"","category":"section"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"  function simpleModel(dy,y,p,t)# api requires four args\n      U = 24.0; \n      rd,rs=p;\n      il=y[1] \n      id=(il*rs-U)/(rd+rs)\n      dy[1] =id\n      dy[2]=il\n      if t>0 || y[2]>0 && y[1]>y[2]\n        y[1]=0.0\n      else\n        y[2]=0.0\n      end       \n   end","category":"page"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"buildir –>","category":"page"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"ir = SimpleModelIR.ODEFunctionIR(SimpleModelIR.AbstractODEStatement[SimpleModelIR.AssignStatement(:U, 24.0), \nSimpleModelIR.AssignStatement(:((rd, rs)), :p), SimpleModelIR.AssignStatement(:il, :(y[1])), SimpleModelIR.AssignStatement(:id, :\n((il * rs - U) / (rd + rs))), SimpleModelIR.AssignStatement(:(dy[1]), :id), SimpleModelIR.AssignStatement(:(dy[2]), :il), \nSimpleModelIR.IfStatement(:(t > 0 || y[2] > 0 && y[1] > y[2]), :(if t > 0 || y[2] > 0 && y[1] > y[2]\n      y[1] = 0.0\n  else\n      y[2] = 0.0\n  end))])","category":"page"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"normalizeir –>","category":"page"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"ir = SimpleModelIR.ODEFunctionIR(SimpleModelIR.AbstractODEStatement[SimpleModelIR.AssignStatement(:U, 24.0), \nSimpleModelIR.AssignStatement(:((rd, rs)), :p), SimpleModelIR.AssignStatement(:il, :(q[1])), SimpleModelIR.AssignStatement(:id, :\n((q[1] * p[2] - 24.0) / (p[1] + p[2]))), SimpleModelIR.AssignStatement(:(dy[1]), :((q[1] * p[2] - 24.0) / (p[1] + p[2]))), \nSimpleModelIR.AssignStatement(:(dy[2]), :(q[1])), SimpleModelIR.IfStatement(:(t - 0.0), :(if t - 0.0\n      if t > 0.0 || q[2] > 0.0 && q[1] > q[2]\n          q[1] = 0.0\n      else\n          q[2] = 0.0\n      end\n  else\n      if t > 0.0 || q[2] > 0.0 && q[1] > q[2]\n          q[1] = 0.0\n      else\n          q[2] = 0.0\n      end\n  end)), SimpleModelIR.IfStatement(:(q[2] - 0.0), :(if q[2] - 0.0\n      if t > 0.0 || q[2] > 0.0 && q[1] > q[2]\n          q[1] = 0.0\n      else\n          q[2] = 0.0\n      end\n  else\n      if t > 0.0 || q[2] > 0.0 && q[1] > q[2]\n          q[1] = 0.0\n      else\n          q[2] = 0.0\n      end\n  end)), SimpleModelIR.IfStatement(:(q[1] - q[2]), :(if q[1] - q[2]\n      if t > 0.0 || q[2] > 0.0 && q[1] > q[2]\n          q[1] = 0.0\n      else\n          q[2] = 0.0\n      end\n  else\n      if t > 0.0 || q[2] > 0.0 && q[1] > q[2]\n          q[1] = 0.0\n      else\n          q[2] = 0.0\n      end\n  end))])","category":"page"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"QuantizedSystemSolver.problem_to_normalized_ir(expr::Expr, stateVarName::Symbol, discrParamName::Symbol)","category":"page"},{"location":"developer/intermediateRepresentation/#QuantizedSystemSolver.SimpleModelIR.problem_to_normalized_ir-Tuple{Expr, Symbol, Symbol}","page":"IR","title":"QuantizedSystemSolver.SimpleModelIR.problem_to_normalized_ir","text":"problem_to_normalized_ir(expr::Expr, stateVarName::Symbol, discrParamName::Symbol)\n\nConverts a symbolic problem expression into a normalized intermediate representation (IR).\n\nArguments\n\nexpr::Expr: The symbolic expression representing the problem to be normalized.\nstateVarName::Symbol: The symbol representing the state variable in the problem.\ndiscrParamName::Symbol: The symbol representing the discrete variable in the problem.\n\nReturns\n\nprobInfo: A structure containing the normalized IR and associated problem information.\n\nDescription\n\nThis function processes the input symbolic expression, extracting relevant information and transforming it into a normalized IR suitable for further analysis or code generation.  It uses the provided state variable and discretization parameter names to correctly interpret the structure of the problem. this process is delegated to buildir and normalizeir functions.\n\n\n\n\n\n","category":"method"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"QuantizedSystemSolver.build_ir(expr::Expr)","category":"page"},{"location":"developer/intermediateRepresentation/#QuantizedSystemSolver.SimpleModelIR.build_ir-Tuple{Expr}","page":"IR","title":"QuantizedSystemSolver.SimpleModelIR.build_ir","text":"build_ir(expr::Expr)\n\nConverts a symbolic expression into an ODEFunctionIR representation.\n\nArguments\n\nexpr::Expr: The symbolic expression to be converted into an ODEFunctionIR.\n\nReturns\n\nODEFunctionIR: An intermediate representation of the ODE function, encapsulating the parsed\n\n\n\n\n\n","category":"method"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"QuantizedSystemSolver.AbstractODEStatement","category":"page"},{"location":"developer/intermediateRepresentation/#QuantizedSystemSolver.SimpleModelIR.AbstractODEStatement","page":"IR","title":"QuantizedSystemSolver.SimpleModelIR.AbstractODEStatement","text":"AbstractODEStatement\n\nAn abstract type representing a single statement in the user code. This serves as a base type for various specific types of statements that can be part of an ODE function's intermediate representation (IR). It is used to encapsulate different kinds of operations, such as assignments, conditional statements, loops, and expressions, allowing for a structured representation of the ODE function's logic.\n\n\n\n\n\n","category":"type"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"QuantizedSystemSolver.AssignStatement","category":"page"},{"location":"developer/intermediateRepresentation/#QuantizedSystemSolver.SimpleModelIR.AssignStatement","page":"IR","title":"QuantizedSystemSolver.SimpleModelIR.AssignStatement","text":"AssignStatement\n\nRepresents an assignment statement within an ODE statement in the intermediate representation (IR) of a simple model. This mutable struct is used to store information about lhs and rhs parts of an assignment.\n\n\n\n\n\n","category":"type"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"QuantizedSystemSolver.IfStatement","category":"page"},{"location":"developer/intermediateRepresentation/#QuantizedSystemSolver.SimpleModelIR.IfStatement","page":"IR","title":"QuantizedSystemSolver.SimpleModelIR.IfStatement","text":"IfStatement\n\nRepresents a conditional (if) statement within the intermediate representation (IR) of a simple model ODE system.\n\nFields\n\ncondition: The condition expression to evaluate. it represents the zero-crossing function for an event.\nbody: The statements to execute if the condition is true. it contains an expression of the whole if-statment. It will be used as the actual execution of the event.\n\nUsage\n\nUsed to model control flow in the IR for ODE problem generation.\n\n\n\n\n\n","category":"type"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"QuantizedSystemSolver.ForStatement","category":"page"},{"location":"developer/intermediateRepresentation/#QuantizedSystemSolver.SimpleModelIR.ForStatement","page":"IR","title":"QuantizedSystemSolver.SimpleModelIR.ForStatement","text":"ForStatement\n\nRepresents a for loop statement within the intermediate representation (IR) of an ODE problem.\n\nDescription\n\nThis mutable struct is a subtype of AbstractODEStatement and is used to represent a for loop that is used to define differential equations.\n\nExample\n\n\n\n\n\n","category":"type"},{"location":"developer/intermediateRepresentation/","page":"IR","title":"IR","text":"QuantizedSystemSolver.ExprStatement","category":"page"},{"location":"developer/intermediateRepresentation/#QuantizedSystemSolver.SimpleModelIR.ExprStatement","page":"IR","title":"QuantizedSystemSolver.SimpleModelIR.ExprStatement","text":"ExprStatement\n\nA mutable struct representing an expression statement within the ODE problem intermediate representation (IR).\n\nDescription\n\nExprStatement is used to encapsulate a single expression that was not handled by other specific statement types like AssignStatement, IfStatement, ForStatement, or WhileStatement. It allows for the inclusion of arbitrary expressions in the IR, which can be useful for representing complex operations or computations that do not fit neatly into the other categories.\n\n\n\n\n\n","category":"type"},{"location":"guide/userTutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The API was designed to match the differentialEquations.jl interace. The only difference is in the way we define events. The problem is defined inside a function, in which the user may introduce any parameters, variables, equations, and events:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"function func(du,u,p,t) \n  #parameters\n  #helper expressions or functions\n  #differential equations\n  #if-statments for events \nend","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"Then, this function is passed to the ODEProblem function along with the initial conditions, the time span, and any parameters or discrete variables. ","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"tspan=(initial_time,final_time)\nu = [u1_0,u2_0...]\np = [p1_0,p2_0...]\nodeprob=ODEProblem(func,u,tspan,p)","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"This function accepts also the chosen jacobian representation mode (jacmode= :approximate or jacmode= :symbolic (default mode). The latter is more accurate but it is currently not recommended when helper functions are used along the model function). The output of the previous function, which is a QSS problem, is passed to a solver function with other configuration arguments (tolerance, cycle detection mechanism, verbose....). The solve function dispatches on the given algorithm and start the numerical integration. See existing cyclde detection mechanisms in the Cycle Detection section.","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"sol= solve(odeprob,algorithm,abstol=...,reltol=...,detection=Detection(N))    ","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"A the end, a solution object is produced that can be queried, plotted, and error-analyzed.","category":"page"},{"location":"guide/userTutorial/#Solving-a-Nonlinear-ODE-Problem-with-events-in-Julia","page":"Tutorial","title":"Solving a Nonlinear ODE Problem with events in Julia","text":"","category":"section"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"In this section, we will go through the process of setting up, solving, querying, and plotting a non linear system of ordinary differential equation (ODEs) with events. We will use a buck converter circuit model as an example.","category":"page"},{"location":"guide/userTutorial/#Example:-Buck-circuit","page":"Tutorial","title":"Example: Buck circuit","text":"","category":"section"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The Buck is a converter that decreases voltage and increases current with a greater power efficiency than linear regulators. Its circuit is shown in the following figure:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: buck circuit)","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The diode and the switch can be modeled as two variables resistors RD and RS. When the diode and the switch are ON, RD and RS are set to 10^-5, and they are OFF, they are set to 10^5.","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: buck circuit remodeled)","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"First, we look for any differential equations. The relationship between the voltage and the current within the inductor and the capacitor is respectively given by:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"large fracdi_ldt=fracu_lL","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"large fracdu_cdt=fraci_cC","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The system variables are i_l and u_c. Therefore, we have to express the differential equations using only these two variables. i.e. i_c and u_l must be found as functions of i_l and u_c. To do this, we conduct a mesh and a nodal analysis to get the relationship between the different components in the circuit.","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"Using nodal analysis in Node N1, we have i_c=i_l-i_R=i_l-fracu_cR. Then, we update the differential equation of the capacitor to become: large fracdu_cdt=fraci_l-fracu_cRC ","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"Using mesh analysis in Mesh 2, we get u_l=-u_c-u_d=-uc-i_dRD. To get rid of i_d, we use mesh analysis in Mesh 1 to get:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"V1= RSi_s-i_dRD=RS(i_l-i_d)-i_dRD","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"Thus, i_d=fracRSi_l-V1RS+RD","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"Second, we look for the events, which are defined by the switching of the RS and RD. The switch is ON for 05 x 10^-4 seconds and OFF for the same period. The diode is ON when id0","category":"page"},{"location":"guide/userTutorial/#Problem","page":"Tutorial","title":"Problem","text":"","category":"section"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"We get the problem discribed inside the function buck. First, we define any constant parameters, then we rename the continuous variables (u[1] and u[2]) and the discrete variables (p[1],p[2],p[3],p[4]) for convenience. i_d can be plugged in the inductor differential equation or can be defined before it. Next, we put the differential euations and events using if-statements.","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"To match The interface of differentialEquations.jl, the buck function is passed along the initial conditions and the tspan to the ODEProblem function.  the result is an ODE problem that is sent to the solve function. The buck problem can be solved by the following user code:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"using QuantizedSystemSolver\nfunction buck(du,u,p,t)\n  #Constant parameters\n  C = 1e-4; L = 1e-4; R = 10.0;V1 = 24.0; T = 1e-4; DC = 0.5; ROn = 1e-5;ROff = 1e5;\n  #Optional rename for convenience\n  RD,RS,nextT,lastT=p;il,uc=u\n  #Equations\n  id=(il*RS-V1)/(RD+RS) # diode's current\n  du[1] =(-id*RD-uc)/L\n  du[2]=(il-uc/R)/C\n  #Events\n  if t>nextT\n    lastT=nextT;nextT=nextT+T;RS=ROn\n  end\n  if t>lastT-DC*T\n    RS=ROff\n  end\n  if id>0\n    RD=ROn;\n  else\n    RD=ROff;\n  end\nend\n#Initial conditions and time settings\np = [1e5,1e-5,1e-4,0.0];u0 = [0.0,0.0];tspan = (0.0,0.001)\n#Define the problem\nprob = ODEProblem(buck,u0,tspan,p)","category":"page"},{"location":"guide/userTutorial/#Solve","page":"Tutorial","title":"Solve","text":"","category":"section"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The solve function takes the previous problem (prob) with a chosen algorithm (qss1,qss2,liqss1,liqss2,nmliqss1,nmliqss2) and some simulation settings, and it outputs a solution (sol). ","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"sol= solve(prob,nmliqss2(),abstol=1e-3,reltol=1e-2)","category":"page"},{"location":"guide/userTutorial/#Query-the-solution","page":"Tutorial","title":"Query the solution","text":"","category":"section"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The values of all variables  at time 0.0005:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"sol(0.0005)\n#[-0.0001274906262221241, 19.430164566823173]","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The value of variable 2  at time 0.0005:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"sol(0.0005,2)\n#19.430164566823173\nsol(0.0005,idxs=2)\n#19.430164566823173","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The total number of steps to end of the simulation:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"sol.stats.totalSteps\n#305","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The number of simultaneous steps during the simulation:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"sol.stats.simulStepCount\n#88","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The total number of events during the simulation:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"sol.stats.evCount\n#80","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The actual data is stored in two vectors:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"sol.savedTimes\nsol.savedVars","category":"page"},{"location":"guide/userTutorial/#Plot-the-solution","page":"Tutorial","title":"Plot the solution","text":"","category":"section"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"If users want to plot the solution, they can use:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sol)","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The plot function accepts other arguments such as xlims,ylims,legend,marker, and title. The user can also plot only certain variables (Users can put as many as they want) using:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sol,idxs=[i,j])# i and j are the indices of the variables (type int).\nplot(sol,i,j)# this is equivalent to the previous line.","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"Plotting a variable i with respect to another j is also possible via:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"plot(sol,idxs=(i,j))# i and j should be replaced by the desired variable indices.","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"It is also possible to plot the sum of some variables (Users can put as many as they want) using:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"plot_SolSum(sol,i,j)#i and j are the indices of the variables (type int).","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, if the user wants to save the plot to a png file:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"save_Sol(sol)\nsave_SolSum(sol,i,j)","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"Buck plot using QuantizedSystemSolver.jl","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: buck circuit plot)","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"To compare the results of this system against classic methods, an attempt to use the package DifferentialEquations.jl. However, currently DifferentialEquations.jl can not handle this problem. An issue is pending. Other tools are used to validate the QuantizedSystemSolver.jl in this buck converter are ltspice and the C qss-solver, and the results are also shown in the following plots:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"Buck plot using qssC","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: buck circuit plot_qssC)","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"Buck plot using ltspice","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: buck circuit plot_ltspice)","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"Buck plot using DifferentialEquations.jl","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: buck circuit plot_diffeEq)","category":"page"},{"location":"guide/userTutorial/#Error-Analysis","page":"Tutorial","title":"Error Analysis","text":"","category":"section"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"To explain the error analysis, we shall use the sin and cos functions:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"function sincos(du,u,t)\n  du[1] = u[2]\n  du[2] = -u[1]\nend\ntspan=(0.0,10.0)\nu0 = [0.0,1.0]\nprob = ODEProblem(sincos,u0 ,tspan)\nsol= solve(prob,nmliqss2(),abstol=1e-3,reltol=1e-2)","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"Since in QSS all variables are updated independently, we can interpolate all values at specific intervals to obtain a solution similar to that of classic methods using solInterpolated(sol,saveat) where saveat is a fixed step size.","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"solInterp=solInterpolated(sol,0.01)","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"To find the relative error we use: err=sqrtfracsum(sol_i-T_i)^2sum(T_i)^2 , where T is true or reference solution.","category":"page"},{"location":"guide/userTutorial/#Error-against-an-analytic-function","page":"Tutorial","title":"Error against an analytic function","text":"","category":"section"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"To compute the error against an analytic solution, we use getError(solInterp,index,analytic function)","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"err1=getError(solInterp,1,x->sin(x))\nerr2=getError(solInterp,2,x->cos(x))\n(err1+err2)/2\n#0.029546046862124274","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The analytic functions can be passed altogether to get the average error at once:  getAverageError(solInterp,vector of analytic functions)","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"err=getAverageError(solInterp,[x->sin(x),x->cos(x)])\n#0.029546046862124274","category":"page"},{"location":"guide/userTutorial/#Error-against-an-reference-solution","page":"Tutorial","title":"Error against an reference solution","text":"","category":"section"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, we compute the error against a reference solution using getErrorByRefs to get the error for one variable and getAverageErrorByRefs to get the average error. Here, the reference solution is stored in a vector that contains the values of all variables. it is the u vector for the case of the solution from the differentialEquations.jl:","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"solFeagin14 = solve(prob,Feagin14(),saveat=0.01,abstol = 1e-12, reltol = 1e-8)\nsolFeagin14Vector=solFeagin14.u\nerror1=getErrorByRefs(solInterp,1,solFeagin14Vector)\navgError=getAverageErrorByRefs(solInterp,solFeagin14Vector)","category":"page"},{"location":"guide/userTutorial/","page":"Tutorial","title":"Tutorial","text":"The results of some solvers of QuantizedSystemSolver.jl are compared against some solvers from DifferentialEquations.jl in the examples section.","category":"page"},{"location":"developer/normalize_ir/#Normalize_IR","page":"Normalize_IR","title":"Normalize_IR","text":"","category":"section"},{"location":"developer/normalize_ir/#allow-composite-if_statments-and-normalize","page":"Normalize_IR","title":"allow composite if_statments and normalize","text":"","category":"section"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"allow event conditions to be composite (contain &&, || ). ","category":"page"},{"location":"developer/normalize_ir/#Example","page":"Normalize_IR","title":"Example","text":"","category":"section"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"if u[1]+u[2] > u[3] && u < 10 || u > 5 && u < 15 || u > 20 \n    a = 0\nend","category":"page"},{"location":"developer/normalize_ir/#Solution","page":"Normalize_IR","title":"Solution","text":"","category":"section"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"case1) && ; without else","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"if A>0 && B>0\n   X\nend","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"<–>","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"if A>0 \n    if  B>0\n      X\n   end\nend   \nif B>0 \n    if  A>0\n      X\n   end\nend  ","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"case2) && ; with else","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"if A>0 && B>0\n   X\nelse\n  Y\nend","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"<–>","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"if A>0 \n    if  B>0\n      X\n   end\nelse\n   Y\nend   \nif B>0 \n    if  A>0\n      X\n   end\nelse\n   Y\nend  ","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"case3) || ; without else","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"if A>0 || B>0\n   X\nend","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"<–>","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"if A>0 \n      X\nend   \nif B>0 \n      X\nend ","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"case4) || ; with else","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"if A>0 || B>0\n   X\nelse\n  Y\nend","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"<–>","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"if A>0 \n   X\nelse\n      if  !(B>0)\n         Y\n      end\nend   \nif B>0 \n      X\nelse\n     if !(A>0)\n       Y\n    end\nend  ","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"case5) multiple || && ;with or without else","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"if A>0 || B>0 && C>0 #.....\n      #(with or without else : the logic is the same)\nend","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"<–>","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"if A>0 \n      #whole user if-statment and its body\nend\nif B>0 \n      #whole user if-statment and its body\nend\nif C>0 \n     #whole user if-statment and its body\nend","category":"page"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"QuantizedSystemSolver.changeVarNames_params(ex::Expr,stateVarName::Symbol,discrParamName::Symbol,muteVar::Symbol,param::Dict{Symbol,Union{Float64,Int64,Expr,Symbol}},helperFunSymSet::Set{Symbol})","category":"page"},{"location":"developer/normalize_ir/#QuantizedSystemSolver.SimpleModelIR.changeVarNames_params-Tuple{Expr, Symbol, Symbol, Symbol, Dict{Symbol, Union{Float64, Int64, Expr, Symbol}}, Set{Symbol}}","page":"Normalize_IR","title":"QuantizedSystemSolver.SimpleModelIR.changeVarNames_params","text":"changeVarNames_params(ex::Expr,stateVarName::Symbol,discrParamName::Symbol,muteVar::Symbol,param::Dict{Symbol,Union{Float64,Int64,Expr,Symbol}},helperFunSymSet::Set{Symbol})\n\nAs the name suggests, this changes the continuous variables names to :q and the discrete variable name to :p and any mute variables to :i. It also plugs the parameters values from a parameter dictionary into the differential equations. The function changeVarNames_params has three methods. One for RHS of equations, one for if-statements when RHS is an expression, and one for if-statements when RHS is a symbol. This is method one. It has an additional symDict::Dict{Symbol,Expr} to collect the translation of symbols of continous and discrete variables (q[i] <-> qi). \n\narguments:\n\nex::Expr: the expression to be changed\nstateVarName::Symbol: the name of the state variable\nmuteVar::Symbol: the name of the mute variable\nparam::Dict{Symbol,Union{Float64,Int64,Expr,Symbol}}: the dictionary of parameters\n\nExample:\n\nusing QuantizedSystemSolver\n\n(ex, stateVarName, discrParamName,muteVar, param) = (:(du[k] = u[k] * u[k - 1] * coef2), :u,:p, :k, Dict{Symbol, Union{Float64, Int64,Expr,Symbol}}(:coef1 => 2.0, :coef2 => 1.5))\n\n  newEx=QuantizedSystemSolver.changeVarNames_params(ex, stateVarName,discrParamName, muteVar, param,Set([:f]))\n(newEx, stateVarName, muteVar, param)\n# output\n\n(:(du[i] = q[i] * q[i - 1] * 1.5), :u, :k, Dict{Symbol, Union{Float64, Int64, Expr, Symbol}}(:coef1 => 2.0, :coef2 => 1.5))\n\n\n\n\n\n","category":"method"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"QuantizedSystemSolver.changeVarNames_params(element::Symbol,stateVarName::Symbol,discrParamName::Symbol,muteVar::Symbol,param::Dict{Symbol,Union{Float64,Int64,Expr,Symbol}},helperFunSymSet::Set{Symbol})","category":"page"},{"location":"developer/normalize_ir/#QuantizedSystemSolver.SimpleModelIR.changeVarNames_params-Tuple{Symbol, Symbol, Symbol, Symbol, Dict{Symbol, Union{Float64, Int64, Expr, Symbol}}, Set{Symbol}}","page":"Normalize_IR","title":"QuantizedSystemSolver.SimpleModelIR.changeVarNames_params","text":"changeVarNames_params(element::Symbol,stateVarName::Symbol,discrParamName::Symbol,muteVar::Symbol,param::Dict{Symbol,Union{Float64,Int64,Expr,Symbol}},helperFunSymSet::Set{Symbol})\n\nThis is method three of the function changeVarNames_params. It is for if-statements when RHS is a symbol.  Again, it changes the symbol to :q if it is a continuous variable, to :p if it is a discrete variable, to :i if it is a mute variable, and to its corresponding value if it is a parameter.\n\n\n\n\n\n","category":"method"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"QuantizedSystemSolver.recurse(e::Expr,flattened::Vector{Expr})","category":"page"},{"location":"developer/normalize_ir/#QuantizedSystemSolver.SimpleModelIR.recurse-Tuple{Expr, Vector{Expr}}","page":"Normalize_IR","title":"QuantizedSystemSolver.SimpleModelIR.recurse","text":"recurse(e::Expr,flattened::Vector{Expr})\n\nBreak down a compound condition into basic components. This function recursively decomposes a condition expression into its basic components, flattening nested logical operators (&&, ||) into a list of expressions. It returns a vector of flattened expressions.\n\nExample:\n\nusing QuantizedSystemSolver\nex=:(u < 1 || u > 10)\nflattened = Expr[]\nQuantizedSystemSolver.recurse(ex, flattened)\nflattened\n\n# output\n\n2-element Vector{Expr}:\n :(u < 1)\n :(u > 10)\n\n\n\n\n\n","category":"method"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"QuantizedSystemSolver.decompose_condition(cond::Expr)","category":"page"},{"location":"developer/normalize_ir/#QuantizedSystemSolver.SimpleModelIR.decompose_condition-Tuple{Expr}","page":"Normalize_IR","title":"QuantizedSystemSolver.SimpleModelIR.decompose_condition","text":"decompose_condition(cond::Expr)\n\nBreak down a compound condition into basic components. Returns a tuple (kind, normalized conditions). where kind is :or or :and depending on the original condition.\n\nExample:\n\nusing QuantizedSystemSolver\nex=:(u < 1 || u > 10)\n(kind,flattened)=QuantizedSystemSolver.decompose_condition(ex)\n(kind,flattened)\n\n# output\n\n(:or, Expr[:(u < 1), :(u > 10)])\n\n\n\n\n\n","category":"method"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"QuantizedSystemSolver.to_zcf(expr::Expr)","category":"page"},{"location":"developer/normalize_ir/#QuantizedSystemSolver.SimpleModelIR.to_zcf-Tuple{Expr}","page":"Normalize_IR","title":"QuantizedSystemSolver.SimpleModelIR.to_zcf","text":"to_zcf(expr::Expr)\n\nConvert a condition expression to zero-crossing form. This function transforms a condition expression into a zero-crossing form (ZCF) by rearranging the terms. For example, it converts expressions like A < B to B - A and A > B to A - B. It is used to prepare conditions for further processing in the normalization of IRs.    \n\nExample:\n\n```jldoctest using QuantizedSystemSolver ex1 = :(u > 10) ex2 = :(u < 1) zcf1 = QuantizedSystemSolver.tozcf(ex1) zcf2 = QuantizedSystemSolver.tozcf(ex2) (zcf1, zcf2)\n\noutput\n\n(:(u - 10), :(1 - u))\n\n\n\n\n\n","category":"method"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"QuantizedSystemSolver.process_if_condition(cond, stateVarName, discrParamName, param, helperFunSymSet)","category":"page"},{"location":"developer/normalize_ir/#QuantizedSystemSolver.SimpleModelIR.process_if_condition-NTuple{5, Any}","page":"Normalize_IR","title":"QuantizedSystemSolver.SimpleModelIR.process_if_condition","text":"process_if_condition(cond, stateVarName, discrParamName, param, helperFunSymSet)\n\nProcesses an if condition within the intermediate representation (IR).\n\nArguments\n\ncond: The condition expression to be processed.\nstateVarName: The name of the state variable involved in the condition.\ndiscrParamName: The name of the discrete parameter relevant to the condition.\nparam: Additional parameters required for processing.\nhelperFunSymSet: A set of helper function symbols used during processing.\n\nReturns\n\nReturns the processed representation of the if condition, potentially transformed for normalization within the IR.\n\nNotes\n\nThis function is intended for internal use in the normalization of IR.\n\n\n\n\n\n","category":"method"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"QuantizedSystemSolver.process_if_block(block_expr::Expr, stateVarName, discrParamName, param, helperFunSymSet)","category":"page"},{"location":"developer/normalize_ir/#QuantizedSystemSolver.SimpleModelIR.process_if_block-Tuple{Expr, Any, Any, Any, Any}","page":"Normalize_IR","title":"QuantizedSystemSolver.SimpleModelIR.process_if_block","text":"process_if_block(block_expr::Expr, stateVarName, discrParamName, param, helperFunSymSet)\n\nProcesses an if block (body) expression within the intermediate representation (IR).\n\nArguments\n\nblock_expr::Expr: The Julia expression representing the if block to be processed.\nstateVarName: The name of the state variable involved in the block.\ndiscrParamName: The name  of the discrete variable.\nparam: Additional parameter(s) required for processing the block.\nhelperFunSymSet: A set of helper function symbols used during processing.\n\nReturns\n\nThe processed if block body (change of variable names).\n\nNotes\n\nThis function is intended for internal use within the IR normalization pipeline.\n\n\n\n\n\n","category":"method"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"QuantizedSystemSolver.process_if_expr(statement,stateVarName,discrParamName,param,helperFunSymSet)","category":"page"},{"location":"developer/normalize_ir/#QuantizedSystemSolver.SimpleModelIR.process_if_expr-NTuple{5, Any}","page":"Normalize_IR","title":"QuantizedSystemSolver.SimpleModelIR.process_if_expr","text":"process_if_expr(statement,stateVarName,discrParamName,param,helperFunSymSet)\n\nProcesses an IfStatement within the intermediate representation (IR) of a simple model.  This function normalizes the given IfStatement according to the provided state variable name, discrete variable name, additional parameters, and a set of helper function symbols:     - Applies variable substitution and body block processing.     - Decomposes composite conditions (&&, ||).\n\nArguments\n\nstatement::IfStatement: The IfStatement node to be processed.\nstateVarName: The name of the state variable relevant to the normalization.\ndiscrParamName: The name of the discretization parameter.\nparam: Additional parameter(s) required for normalization.\nhelperFunSymSet: A set of symbols representing helper functions used during normalization.\n\nReturns\n\nVector{IfStatement}: A vector of normalized IfStatement objects resulting from the processing.\n\nNotes\n\nThis function is typically used as part of the IR normalization pipeline in the SimpleModelIR module.\n\n\n\n\n\n","category":"method"},{"location":"developer/normalize_ir/","page":"Normalize_IR","title":"Normalize_IR","text":"QuantizedSystemSolver.normalize_ir(ir, stateVarName::Symbol, discrParamName::Symbol)","category":"page"},{"location":"developer/normalize_ir/#QuantizedSystemSolver.SimpleModelIR.normalize_ir-Tuple{Any, Symbol, Symbol}","page":"Normalize_IR","title":"QuantizedSystemSolver.SimpleModelIR.normalize_ir","text":"normalize_ir(ir, stateVarName::Symbol, discrParamName::Symbol)\n\nNormalizes the intermediate representation (IR) of an ODE function.\n\nArguments\n\nir::ODEFunctionIR: The intermediate representation of the ODE function to be normalized.\nstateVarName::Symbol: The symbol representing the state variable in the IR.\ndiscrParamName::Symbol: The symbol representing the name of the discrete variable.\n\nReturns\n\nA normalized version of the input ODEFunctionIR.\n\nDescription\n\nThis function processes the given ODE function IR, normalizing its structure with respect to the specified state variable and discretization parameter. The normalization includes renaming variables, swapping parameters, and decomposing composite if-statements.\n\n\n\n\n\n","category":"method"},{"location":"developer/problem/#Problem","page":"Problem","title":"Problem","text":"","category":"section"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"The ODEProblem function is the entry point for defining a new problem to be solved by the QSS solver. It takes user-provided code, which includes system parameters, variables, equations, and event logic, and constructs a Problem object that encapsulates all the necessary information for the solver to simulate the system such as problem dimensions, dependencies, and equations. The function works by parsing the user code and extracting relevant data to populate the Problem object.","category":"page"},{"location":"developer/problem/#Problem-extension","page":"Problem","title":"Problem extension","text":"","category":"section"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"Problem extension can be achieved easily via PRTYPE which is of type Val, or another subtype of this superclass can be created.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":" QuantizedSystemSolver.ODEProblemData{F,PRTYPE,T,D,Z,CS}","category":"page"},{"location":"developer/problem/#QuantizedSystemSolver.ODEProblemData","page":"Problem","title":"QuantizedSystemSolver.ODEProblemData","text":"ODEProblemData{F,PRTYPE,T,D,Z,CS}\n\nThis is a superclass for all ODE problems. It is parametric on:\n\nThe problem type PRTYPE.\nThe number of continuous variables T\nThe number of discrete events D\nThe number of events (zero crossing functions) Z\nThe cache size CS.\n\n\n\n\n\n","category":"type"},{"location":"developer/problem/#What-is-needed-with-a-new-problem:","page":"Problem","title":"What is needed with a new problem:","text":"","category":"section"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"The more different the new problem from the ODEContProblem, the more functions are needed to be extended. In general the following functions need to be extended.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"The odeProblemFunc method to handle this problem.\nThe integrate method for this new type of problem.\nThe custom_Solve method if needed.","category":"page"},{"location":"developer/problem/#Example","page":"Problem","title":"Example","text":"","category":"section"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"struct SmallODEProblem{CS}<: ODEProblemData{0,1,1,0,0,CS} \n  cacheSize::Val{CS}# CS= cache size \n  initConditions::Float64   \n  eq::Function#function that holds the differential equation\nend","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"This new problem type takes care of one differential equation. There is no need for the Jacobian nor for the dependencies. This needs an extension of the custom_Solve method that just removes the references to the jac and the SD. An extension of the integrate method is also needed since the implementation is a lot simpler than what is currently implemented.","category":"page"},{"location":"developer/problem/#Further-reading-about-the-functions-creating-the-problem","page":"Problem","title":"Further reading about the functions creating the problem","text":"","category":"section"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"ODEDiscProblem{F,PRTYPE,T,D,Z,CS}: This is the struct that holds all the necessary data for a nonlinear ordinary differential equation (ODE)  problem with discrete events. The structure includes various fields such as initial conditions, discrete variables, Jacobians, event dependencies, and other data related to how the problem is formulated. This structure serves as the core data holder for the problem and will be used in the solver. It is a parametric abstract type that has the following parameters:","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"PRTYPE: The type of the problem (to distinguish between various types, and allow future extension of the solver to handle new types).","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"T: The number of continuous variables (state variables).","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"Z: The number of zero-crossing functions, which are used to detect events.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"Y: The actual number of events.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"CS: Cache size, which is used to store intermediate operations.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"The use of abstract types in this context allows for flexibility and extensibility in the solver. By defining these abstract types, the code can be easily adapted to handle different types of problems, algorithms, and solutions without needing to modify the core solver logic. This design choice enhances the maintainability and scalability of the solver, making it easier to add new features or support additional problem types in the future.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"odeProblemFunc: After an initial preparation performed by the The NLodeProblem function, The function odeProblemFunc takes the resulting expressions to continue constructing an instance of the ODEDiscProblem structure. It works in several key stages:","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"Initialization: The function begins by initializing vectors and dictionaries that will hold equations (equs), Jacobian dependencies (jac), zero-crossing functions (ZCjac), and event dependencies. These serve to store the different types of equations and their relationships.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"Processing ODEs: It loops through each of the ODE expressions provided by the user. Depending on the type of expression (discrete variables, differential equations, or loop constructs), it processes the right-hand side (RHS) of the equation. For differential equations, it extracts dependencies to build the Jacobian and transform the equations into a more appropriate form for further use. Special cases are handled, such as if the RHS is a number or a symbol.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"Handling Events: The function also processes event-related constructs (if conditions) that correspond to different points where the system might undergo discrete changes. It process the RHS of the event equations, transforms them into a suitable form, and builds the necessary dependency structures. Specifically, it constructs how discrete and continuous variables influence one another through the events.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"Constructing the Function Code: After processing all ODEs and events, the function dynamically generates a Julia function code needed to store the system of ODEs and events. This code is built into a function that handles different cases (i.e., which equation to evaluate based on an index of a state change or an event).","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"Building Dependencies: Several helper functions that build the dependencies between variables, events. They build dependency vectors  that track how discrete and continous variables influence the system. This is used to know what variables to update and determine when specific events should be checked. By tracking the relationships between variables and events, the solver can determine the appropriate actions to take at each time step. The dependencies are stored in the following vectors:","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"-jac: It determines which variables affect a derivative.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"-ZCjac: It determines which variables affect a zero-crossing function.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"-SD: It determines which derivatives that are affected by a given variable.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"-SZ: It determines which zero-crossing functions that are affected by a given variable.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"-HZ: It tells which Zero-crossing functions influenced by a given event.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"-HD: It tells which derivatives influenced by a given event.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"Here's a quick summary and what each helper function is doing:","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"extractJacDepNormal: It Extracts the dependencies for normal (non-loop) expressions. It updates the Jacobian matrix jac and a dictionary dD for tracking dependencies of derivatives to discrete variables.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"extractJacDepLoop: Similar to extractJacDepNormal, but specifically for loop expressions. It tracks dependencies across loop iterations.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"extractZCJacDep: It Extracts zero-crossing Jacobian dependencies for discrete variables (dZ), and it updates zcjac, SZ.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"createDependencyToEventsDiscr: It maps discrete dependencies (dD, dZ) to specific events, it and constructs dependency matrices HZ and HD from the discrete variables only.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"createDependencyToEventsCont: Similar to createDependencyToEventsDiscr, but for continuous dependencies (SD, sZ), and it updates the matrices HZ and HD from the continuous variables only.","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"unionDependency: Merges the two previous sets of dependencies (continuous and discrete) into the final matrices HZ and HD.","category":"page"},{"location":"developer/problem/#Helper-packages","page":"Problem","title":"Helper packages","text":"","category":"section"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"The 𝑝𝑜𝑠𝑡𝑤𝑎𝑙𝑘 function from the MacroTools.jl (Copyright (c) 2015: Mike Innes) package plugs parameters and helper functions directly into the equations, and traverses the right-hand side of differential equations and zero-crossing functions, facilitating the construction of the Jacobian matrix and identifying variable dependencies. It also transforms specific expressions like 𝑞[1] into 𝑞[1] [0] within events, and converts 𝑞[𝑖] to 𝑞𝑖, making the equations more tractable for differentiation and Jacobian construction. Additionally, the @𝑐𝑎𝑝𝑡𝑢𝑟𝑒 macro efficiently handles cases where differential equations are defined within a for loop. ","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"The diff(basi, symarg) function from the SymEngine.jl (Copyright (c) 2015-2017 Isuru Fernando) package is applied to perform symbolic differentiation, where basi is an expression and symarg is the symbol with respect to which the derivative is taken. This returns the partial derivative of the expression, making it particularly useful for deriving system Jacobians. ","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"@code_string macro from the CodeTracking.jl (Copyright (c) 2019 Tim Holy) is used to get the body expression of the function that holds the problem given by the user. ","category":"page"},{"location":"developer/problem/","page":"Problem","title":"Problem","text":"@RuntimeGeneratedFunction from the RuntimeGeneratedFunctions.jl package (Copyright (c) 2020 Chris Rackauckas) is used to avoid world-age issues with the generated functions.","category":"page"},{"location":"examples/linearTimeInvariantSystem/#Linear-Time-Invariant","page":"Linear Time Invariant","title":"Linear Time Invariant","text":"","category":"section"},{"location":"examples/linearTimeInvariantSystem/","page":"Linear Time Invariant","title":"Linear Time Invariant","text":"using QuantizedSystemSolver\nfunction sysb53(du,u,p,t)\n    du[1] = -20.0*u[1]-80.0*u[2]+1600.0\n    du[2] = 1.24*u[1]-0.01*u[2]+0.2\nend\nu0 = [-1.0, -2.0];tspan=(0.0,10.0)\n#Construct the problem\nodeprob = ODEProblem(sysb53,u0,tspan)\n#Solve the problem\nsol = solve(odeprob,nmliqss2())\np1 = plot(sol);","category":"page"},{"location":"examples/linearTimeInvariantSystem/","page":"Linear Time Invariant","title":"Linear Time Invariant","text":"The analytic solution is given by the following equations:","category":"page"},{"location":"examples/linearTimeInvariantSystem/","page":"Linear Time Invariant","title":"Linear Time Invariant","text":" x1(t)=105.83453057676363*-8.83362618880318*exp(-10.943696474115944*t)-127.91533865757171*-7.303470585390368*exp(-9.046303525884058*t)-0.32323232323231316\n x2(t)=105.83453057676363*exp(-10.943696474115944*t)-127.91533865757171*exp(-9.046303525884058*t)+20.08080808080808","category":"page"},{"location":"examples/linearTimeInvariantSystem/","page":"Linear Time Invariant","title":"Linear Time Invariant","text":"Then use DifferentialEquations instead of QuantizedSystemSolver and use solvers such as ABDF2(), QNDF2(), QBDF2(), or Trapezoid() instead of nmliqss2. The plots are displayed below:","category":"page"},{"location":"examples/linearTimeInvariantSystem/","page":"Linear Time Invariant","title":"Linear Time Invariant","text":"LTI plot using QuantizedSystemSolver.jl","category":"page"},{"location":"examples/linearTimeInvariantSystem/","page":"Linear Time Invariant","title":"Linear Time Invariant","text":"(Image: LTI plot)","category":"page"},{"location":"examples/linearTimeInvariantSystem/","page":"Linear Time Invariant","title":"Linear Time Invariant","text":"LTI plot using DifferentialEquations.jl","category":"page"},{"location":"examples/linearTimeInvariantSystem/","page":"Linear Time Invariant","title":"Linear Time Invariant","text":"(Image: LTI plot)","category":"page"},{"location":"examples/linearTimeInvariantSystem/","page":"Linear Time Invariant","title":"Linear Time Invariant","text":"LTI plot using the analytic solution","category":"page"},{"location":"examples/linearTimeInvariantSystem/","page":"Linear Time Invariant","title":"Linear Time Invariant","text":"(Image: LTI plot)","category":"page"},{"location":"examples/linearTimeInvariantSystem/","page":"Linear Time Invariant","title":"Linear Time Invariant","text":"This is a great example that shows when we need to use the explicit qss, the implicit liqss, or the modified implicit nmliqss. This is a stiff problem so we need to use the implicit methods, but it also contains larger entries outside the main diagonal of the Jacobian. Therefore, nmliqss should the most appropriate algorithm to use. ","category":"page"},{"location":"examples/adr/#ADR-problem","page":"ADR problem","title":"ADR problem","text":"","category":"section"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"The Advection diffusion reaction  equations describe many processes that include heat transfer, chemical reactions and many phenomena in areas of environmental sciences. They are ordinary differential equations that resulted from the method of lines (MOL). The resulting system is a large stiff system with possible large entries outside the main diagonal. :","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"beginalign*\n textFor  i=1N-1  quad quad  dot u_i=-afracu_i-u_i-1Delta x+dfracu_i+1-2u_i+u_i-1Delta x^2+r(u_i^2-u_i^3) nonumber \n dot u_N=-afracu_N-u_N-1Delta x+d frac2u_N-1-2u_NDelta x^2+r(u_N^2-u_N^3)\nendalign*","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"where N is the number of grid points and Delta x=frac10N is the grid width after the discretization of the problem with the MOL, a is the advection parameter, d is the diffusion parameter, and r is the reaction parameter. The initial condition is given by:","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"beginalign*\n  u_i(t=0)= 1  if  i in 1N3\n u_i(t=0)= 0  else\nendalign*","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"The advection parameter is fixed at a=1, and the reaction parameter is fixed at r=1000. The number of grid points is picked as N=1000, and d is set to 0.1. see [1] and [2] for more details.","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"The QuantizedSystemSolver code to solve this system:","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"using QuantizedSystemSolver\nfunction adr(du,u,p,t)# api requires four args\n    _dx=100.0\n    a=1.0\n    d=0.1\n    r=1000.0\n    du[1] = -a*_dx*(u[1]-0.0)+d*_dx*_dx*(u[2]-2.0*u[1]+0.0)+r*u[1]*u[1]*(1.0-u[1]) \n    for k in 2:999  \n        du[k]=-a*_dx*(u[k]-u[k-1])+d*_dx*_dx*(u[k+1]-2.0*u[k]+u[k-1])+r*u[k]*u[k]*(1.0-u[k]) ;\n    end \n    du[1000]=-a*_dx*(u[1000]-u[999])+d*_dx*_dx*(2.0*u[999]-2.0*u[1000])+r*u[1000]*u[1000]*(1.0-u[1000]) \nend\ntspan = (0.0,10.0)\nu0=zeros(1000)\nu0[1:333].=1.0\n#Construct the problem\nodeprob = ODEProblem(adr,u0,tspan)\n#Solve the problem\nsol=solve(odeprob,nmliqss2(),abstol=1e-3,reltol=1e-2)\np1=plot(sol,idxs=[1,400,1000],title=\"---\");\nsavefig(p1, \"adr$(nmliqss2())\") ","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"(Image: plot_adrqss) (Image: plot_adr)","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"This is a great example to compare QSS methods against classic integration methods, because it is a large sparse system. Replace nmliqss2 by solvers such as ABDF2(), QNDF2(), QBDF2(), Rosenbrock23, or Trapezoid() from the DifferentialEquations.jl. Using @btime from BenchmarkTools.jl, we obtain the following results.","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"Solver @btime\nnmliqss2 using @NLodeProblem 98.782 ms (10205 allocations: 2.13 MiB)\nnmliqss2 using ODEProblem: 340.980 ms (270008 allocations: 13.22 MiB)\nRosenbrock23: 2.315 s (2348 allocations: 29.37 MiB)","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"Other DifferentialEquations.jl solvers are tested and the following plot shows the their @btime.","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"(Image: plot_adrcompare)","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"In addition order1 is compared against the ImplicitEuler with a reference solution using an absolute tolerance abstol = 10−12 and relative tolerance reltol = 10−8 using the solver Feagin14 (a Runge-Kutta method of order14) :","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"Solver @btime Relative Error\nnmliqss1 using @NLodeProblem 94.99 ms 0.0268\nImplicit Euler: 13134 ms 0.0572","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"The following code is used:","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"function getAverageErrorByRefs(solVec::Vector{Vector{Float64}},solRef::Vector{Any},T::Int,numPoints::Int)\n    allErrors=0.0\n    for index=1:T\n        sumTrueSqr=0.0\n        sumDiffSqr=0.0\n        relerror=0.0\n        for i = 1:numPoints #\n            ts=solRef[i][index]\n            Ns=solVec[i][index]\n            sumDiffSqr+=(Ns-ts)*(Ns-ts)\n            sumTrueSqr+=ts*ts\n        end\n        relerror=sqrt(sumDiffSqr/sumTrueSqr)\n        allErrors+= relerror\n    end\n    return allErrors/T\n  end\nBSON.@load \"test/solVectAdvection_N1000d01_Feagin14e-12.bson\" solFeagin14VectorN1000d01\nsol=solve(odeprob,ImplicitEuler(),saveat=0.01,abstol=1e-2,reltol=1e-1)\nerr2=getAverageErrorByRefs(sol.u,solFeagin14VectorN1000d01,1000,1000)","category":"page"},{"location":"examples/adr/#refs4","page":"ADR problem","title":"References","text":"","category":"section"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"[1] F. Bergero, J. Fernandez, E. Kofman, and M. Portapila. Time discretization versus state ´ quantization in the simulation of a 1d advection-diffusion-reaction equation. Simulation: Transactions of the Society for Modeling and Simulation International, vol.92(no.1):pp.47– 61, 2016.","category":"page"},{"location":"examples/adr/","page":"ADR problem","title":"ADR problem","text":"[2]  F. Pietro, G. Migoni, and E. Kofman. Improving linearly implicit quantized state system methods. Simulation: Transactions of the Society for Modeling and Simulation International, vol.95(no.2):pp.127–144, 2019.","category":"page"},{"location":"guide/userAPI/#User-API","page":"User API","title":"User API","text":"","category":"section"},{"location":"guide/userAPI/#Problem-definition","page":"User API","title":"Problem definition","text":"","category":"section"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"ODEProblem(f::Function, u::Vector{Float64}, tspan::Tuple{A,B}, p::Union{Vector{EM}, Tuple{Vararg{EM}}};jac_mode ::Symbol= :symbolic) where{EM,A<:Union{Float64, Int64},B<:Union{Float64, Int64}}","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.ODEProblem-Union{Tuple{B}, Tuple{A}, Tuple{EM}, Tuple{Function, Vector{Float64}, Tuple{A, B}, Union{Vector{EM}, Tuple{Vararg{EM}}}}} where {EM, A<:Union{Float64, Int64}, B<:Union{Float64, Int64}}","page":"User API","title":"QuantizedSystemSolver.ODEProblem","text":"ODEProblem(f::Function, u::Vector{Float64}, tspan::Tuple{A,B}, p::Union{Vector{EM}, Tuple{Vararg{EM}}};jac_mode ::Symbol= :symbolic) where{EM,A<:Union{Float64, Int64},B<:Union{Float64, Int64}}\n\nCreates an ODE problem with the given function f, initial conditions u, parameters p, and time span tspan.\n\nArguments\n\nf::Function: The function defining the ODE.\nu::Vector{Float64}: The initial conditions.\np::Vector{Float64}: The parameters.\ntspan::Tuple{Float64,Float64}: The time span for the ODE.\n\nReturns\n\nAn ODE problem.\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"ODEProblem(f::Function, u::Vector{Float64}, tspan::Tuple{A,B};jac_mode ::Symbol= :symbolic) where{A<:Union{Float64, Int64},B<:Union{Float64, Int64}}","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.ODEProblem-Union{Tuple{B}, Tuple{A}, Tuple{Function, Vector{Float64}, Tuple{A, B}}} where {A<:Union{Float64, Int64}, B<:Union{Float64, Int64}}","page":"User API","title":"QuantizedSystemSolver.ODEProblem","text":"ODEProblem(f::Function, u::Vector{Float64}, tspan::Tuple{A,B};jac_mode ::Symbol= :symbolic) where{A<:Union{Float64, Int64},B<:Union{Float64, Int64}}\n\nCreates an ODE problem with the given function f, initial conditions u, and time span tspan.\n\nArguments\n\nf::Function: The function defining the ODE.\nu::Vector{Float64}: The initial conditions.\ntspan::Tuple{Float64,Float64}: The time span for the ODE.\n\nReturns\n\nAn ODE problem.\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/#The-solve-function:","page":"User API","title":"The solve function:","text":"","category":"section"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"solve(prob::ODEProblemData{F,PRTYPE,T,D,Z,CS},al::QSSAlgorithm{SolverType, OrderType};detection::Val{M}=Val(2),saveat::Float64=Inf,abstol::Float64=1e-3,reltol::Float64=1e-3,maxErr::Float64=1.0,maxiters::Int=Int(1e7),verbose=false::Bool) where{F,PRTYPE,T,D,Z,CS,SolverType,OrderType,M}        ","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.solve-Union{Tuple{M}, Tuple{OrderType}, Tuple{SolverType}, Tuple{CS}, Tuple{Z}, Tuple{D}, Tuple{T}, Tuple{PRTYPE}, Tuple{F}, Tuple{ODEProblemData{F, PRTYPE, T, D, Z, CS}, QSSAlgorithm{SolverType, OrderType}}} where {F, PRTYPE, T, D, Z, CS, SolverType, OrderType, M}","page":"User API","title":"QuantizedSystemSolver.solve","text":"solve(prob::ODEProblemData{F,PRTYPE,T,D,Z,CS},al::QSSAlgorithm{SolverType, OrderType};detection::Val{M}=Val(2),saveat::Float64=Inf,abstol::Float64=1e-3,reltol::Float64=1e-3,maxErr::Float64=1.0,maxiters::Int=Int(1e7),verbose=false::Bool) where{F,PRTYPE,T,D,Z,CS,SolverType,OrderType,M}\n\ndispatches on a specific integrator based on the algorithm provided and sends a nonlinear ODE problem to the integrator. With the exception of the argument prob, all other arguments are optional and have default values:\n\nArguments\n\nprob::ODEProblemData{F,PRTYPE,T,D,Z,CS}: The nonlinear ODE problem to solve.\nal::QSSAlgorithm{SolverType, OrderType}: The QSS algorithm to use for solving the problem.\ndetection::Val{M}: A type parameter indicating which detection mechanism to use.\nsaveat::Float64: The time interval at which to save the solution (default: Inf).\nabstol::Float64: The absolute tolerance for the solver (default: 1e-4).\nreltol::Float64: The relative tolerance for the solver (default: 1e-3).\nmaxErr::Float64: The maximum allowable error (default: Inf).\nmaxiters::Int: The maximum number of iterations (default: Int(1e7)).\n\nAfter the simulation, the solution is returned as a Solution object.\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"solve(prob::ODEProblemData{F,PRTYPE,T,D,Z,CS},al::QSSAlgorithm{SolverType, OrderType},tspan::Tuple{Float64, Float64};detection::Val{M}=Val(2),saveat::Float64=Inf,abstol::Float64=1e-3,reltol::Float64=1e-3,maxErr::Float64=1.0,maxiters::Int=Int(1e7),verbose=false::Bool) where{F,PRTYPE,T,D,Z,CS,SolverType,OrderType,M} ","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.solve-Union{Tuple{M}, Tuple{OrderType}, Tuple{SolverType}, Tuple{CS}, Tuple{Z}, Tuple{D}, Tuple{T}, Tuple{PRTYPE}, Tuple{F}, Tuple{ODEProblemData{F, PRTYPE, T, D, Z, CS}, QSSAlgorithm{SolverType, OrderType}, Tuple{Float64, Float64}}} where {F, PRTYPE, T, D, Z, CS, SolverType, OrderType, M}","page":"User API","title":"QuantizedSystemSolver.solve","text":"solve(prob::ODEProblemData{F,PRTYPE,T,D,Z,CS},al::QSSAlgorithm{SolverType, OrderType},tspan::Tuple{Float64, Float64};detection::Val{M}=Val(2),saveat::Float64=Inf,abstol::Float64=1e-3,reltol::Float64=1e-3,maxErr::Float64=1.0,maxiters::Int=Int(1e7),verbose=false::Bool) where{F,PRTYPE,T,D,Z,CS,SolverType,OrderType,M}\n\nsame as the previous solve method, but with a specified time span. This method is useful when the user wants to specify the time span separately from the problem definition.\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/#Algorithms","page":"User API","title":"Algorithms","text":"","category":"section"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":" qss1()  ","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.qss1-Tuple{}","page":"User API","title":"QuantizedSystemSolver.qss1","text":"qss1()\n\ncalls the explicit quantized state system solver with order 1\n\nqss1()=QSSAlgorithm(Val(:qss),Val(1))\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":" qss2()  ","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.qss2-Tuple{}","page":"User API","title":"QuantizedSystemSolver.qss2","text":"qss2()\n\ncalls the explicit quantized state system solver with order 2 \n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":" liqss1()  ","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.liqss1-Tuple{}","page":"User API","title":"QuantizedSystemSolver.liqss1","text":"liqss1()\n\ncalls the  imlicit quantized state system solver with order 1.\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":" liqss2()  ","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.liqss2-Tuple{}","page":"User API","title":"QuantizedSystemSolver.liqss2","text":"liqss2()\n\ncalls the  imlicit quantized state system solver with order 2.\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":" nmliqss1()  ","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.nmliqss1-Tuple{}","page":"User API","title":"QuantizedSystemSolver.nmliqss1","text":"nmliqss1()\n\ncalls the modified imlicit quantized state system solver with order 1. It is efficient when the system contains large entries outside the main diagonal of the Jacobian .\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":" nmliqss2()  ","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.nmliqss2-Tuple{}","page":"User API","title":"QuantizedSystemSolver.nmliqss2","text":"nmliqss2()\n\ncalls the modified imlicit quantized state system solver with order 2. It is efficient when the system contains large entries outside the main diagonal of the Jacobian .\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/#Solution","page":"User API","title":"Solution","text":"","category":"section"},{"location":"guide/userAPI/#Query-a-solution","page":"User API","title":"Query a solution","text":"","category":"section"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"QuantizedSystemSolver.evaluateSol(sol::Sol{T,O},index::Int,t::Float64) where {T,O}","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.evaluateSol-Union{Tuple{O}, Tuple{T}, Tuple{Sol{T, O}, Int64, Float64}} where {T, O}","page":"User API","title":"QuantizedSystemSolver.evaluateSol","text":"evaluateSol(sol::Sol{T,O},index::Int,t::Float64) where {T,O}\n\nEvaluates the solution at a given time t for a specified variable index.\n\nArguments\n\nsol::Sol{T,O}: The solution struct.\nindex::Int: The index of the variable to evaluate. If index is 0, evaluates all variables.\nt::Float64: The time at which to evaluate the solution.\n\nReturns\n\nThe value of the specified variable at time t, or a vector of values if index is 0.\n\nThrows\n\nAn error if the given time t is outside the solution range.\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"QuantizedSystemSolver.solInterpolated(sol::Sol{T,O},step::Float64) where {T,O}","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.solInterpolated-Union{Tuple{O}, Tuple{T}, Tuple{Sol{T, O}, Float64}} where {T, O}","page":"User API","title":"QuantizedSystemSolver.solInterpolated","text":"solInterpolated(sol::Sol{T,O},step::Float64) where {T,O}\n\nConstruct a new solution by interpolating the current solution at each step for all variables.\n\nArguments\n\nsol::Sol{T,O}: The solution struct.\nstep::Float64: the step size at which to generate the new solution.\n\nReturns\n\nA new solution that contains information at each step size..\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"QuantizedSystemSolver.solInterpolated(sol::Sol{T,O},index::Int,step::Float64) where {T,O}","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.solInterpolated-Union{Tuple{O}, Tuple{T}, Tuple{Sol{T, O}, Int64, Float64}} where {T, O}","page":"User API","title":"QuantizedSystemSolver.solInterpolated","text":"solInterpolated(sol::Sol{T,O},index::Int,step::Float64) where {T,O}\n\nConstructs a new solution by interpolating the current solution at each step for one variable.\n\nArguments\n\nsol::Sol{T,O}: The solution struct.\nindex::Int: the index of the variable to interpolate.\nstep::Float64: the step size at which to generate the new solution.\n\nReturns\n\nA new solution that contains the information of one variable at each step size.\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"QuantizedSystemSolver.show(io::IO, a::Stats)","category":"page"},{"location":"guide/userAPI/#Base.show-Tuple{IO, Stats}","page":"User API","title":"Base.show","text":"show(io::IO, a::Stats)\n\nDisplays the statistics of the simulation.\n\nArguments\n\nio::IO: The IO stream to write to.\na::Stats: The Stats struct containing the simulation statistics.\n\nPrints\n\nThe total simulation steps.\nThe simultaneous steps.\nThe number of events.\nThe number of state steps.\nThe number of input steps.\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"QuantizedSystemSolver.Stats","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.Stats","page":"User API","title":"QuantizedSystemSolver.Stats","text":"Stats\n\nA struct that holds the statistics of a simulation. It has the following fields:\n\ntotalSteps::Int: The total number of simulation steps.\nsimulStepCount::Int: The number of simultaneous steps.\nevCount::Int: The number of events.\nnumStateSteps::Vector{Int}: A vector holding the number of steps for each state update.\nnumInputSteps::Vector{Int}: A vector holding the number of steps for each input update.\n\n\n\n\n\n","category":"type"},{"location":"guide/userAPI/#Error-with-respect-to-an-analytic-or-reference-solution","page":"User API","title":"Error with respect to an analytic or reference solution","text":"","category":"section"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"warning: Finding the error\nTo find the error, an interpolated solution has to be used as shown in solInterpolated. The reference solution (using saveat for example) and the interpolated solution (passed step to interpolated function) must have the same tspan and the same step size.","category":"page"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"getError(sol::Sol{T,O},index::Int,f::Function) where{T,O}","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.getError-Union{Tuple{O}, Tuple{T}, Tuple{Sol{T, O}, Int64, Function}} where {T, O}","page":"User API","title":"QuantizedSystemSolver.getError","text":"getError(sol::Sol{T,O},index::Int,f::Function) where{T,O}\n\ncalculates the relative error of one variable of the solution with respect to a function of an analytic solution.\n\nbeginequation*\nerr=sqrtfracsum(sol_index-f_index)^2sum(f_index)^2\nendequation*\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"getAverageError(sol::Sol{T,O},f::Vector{Function}) where{T,O}","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.getAverageError-Union{Tuple{O}, Tuple{T}, Tuple{Sol{T, O}, Vector{Function}}} where {T, O}","page":"User API","title":"QuantizedSystemSolver.getAverageError","text":"getAverageError(sol::Sol{T,O},f::Vector{Function}) where{T,O}\n\ncalculates the average relative error of all variables of the solution with respect to a vector of functions of analytic solutions.\n\nbeginalign*\n err_index=sqrtfracsum(sol_index-f_index)^2sum(f_index)^2\n avgError=fracsum_index=1^Terr_indexT\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"getErrorByRefs(sol::Sol{T,O},index::Int,solRef::Vector{Any}) where{T,O}","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.getErrorByRefs-Union{Tuple{O}, Tuple{T}, Tuple{Sol{T, O}, Int64, Vector{Any}}} where {T, O}","page":"User API","title":"QuantizedSystemSolver.getErrorByRefs","text":"getErrorByRefs(sol::Sol{T,O},index::Int,solRef::Vector{Any}) where{T,O}\n\ncalculates the relative error of one variable of the solution with respect to a vector of values received from a reference solution.\n\nbeginequation*\nerr=sqrtfracsum(sol_index-solRef_index)^2sum(solRef_index)^2\nendequation*\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"getAverageErrorByRefs(sol::Sol{T,O},solRef::Vector{Any}) where{T,O}","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.getAverageErrorByRefs-Union{Tuple{O}, Tuple{T}, Tuple{Sol{T, O}, Vector{Any}}} where {T, O}","page":"User API","title":"QuantizedSystemSolver.getAverageErrorByRefs","text":"getAverageErrorByRefs(sol::Sol{T,O},solRef::Vector{Any}) where{T,O}\n\ncalculates the average relative error of the solution with respect to a reference solution. The relative error is calculated for each variable, and then it is averaged over all variables.\n\nbeginalign*\n err_index=sqrtfracsum(sol_index-solRef_index)^2sum(solRef_index)^2\n avgError=fracsum_index=1^Terr_indexT\nendalign*\n\n\n\n\n\n","category":"method"},{"location":"guide/userAPI/#Plot-the-solution","page":"User API","title":"Plot the solution","text":"","category":"section"},{"location":"guide/userAPI/","page":"User API","title":"User API","text":"plot_SolSum(sol::Sol{T,O},xvars::Int...;interp=0.0001,note=\" \"::String,xlims::Tuple{Float64, Float64}=(0.0,0.0),ylims::Tuple{Float64, Float64}=(0.0,0.0),legend::Bool=true) where{T,O}","category":"page"},{"location":"guide/userAPI/#QuantizedSystemSolver.plot_SolSum-Union{Tuple{O}, Tuple{T}, Tuple{Sol{T, O}, Vararg{Int64}}} where {T, O}","page":"User API","title":"QuantizedSystemSolver.plot_SolSum","text":"plot_SolSum(sol::Sol{T,O},xvars::Int...;interp=0.0001,note=\" \"::String,xlims::Tuple{Float64, Float64}=(0.0,0.0),ylims::Tuple{Float64, Float64}=(0.0,0.0),legend::Bool=true) where{T,O}\n\nplots of the sum of the variables xvars.\n\nArguments\n\nsol::Sol{T,O}: The solution struct.\nxvars::Int...: The indices of the variables to sum. If no indices are provided, all variables are summed.\ninterp::Float64: The interpolation step.\nnote::String: A note to add to the title of the plot.\nxlims::Tuple{Float64, Float64}: The x-axis limits of the plot.\nylims::Tuple{Float64, Float64}: The y-axis limits of the plot.\nlegend::Bool: A boolean indicating whether to display the legend.\n\n\n\n\n\n","category":"method"},{"location":"developer/problemFunction/#Problem-Function","page":"Problem Function","title":"Problem Function","text":"","category":"section"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Constructing the Function Code: After processing all ODEs and events, the 'odeProblemFunc' function dynamically generates a Julia function (diffEqfunctionF) code needed to store the system of ODEs and events. This code is built into a function that handles different cases (i.e., which equation to evaluate based on an index of a state change or an event).","category":"page"},{"location":"developer/problemFunction/#scoping-and-world-age-issues","page":"Problem Function","title":"scoping and world age issues","text":"","category":"section"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"There are several ways to construct this function:","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"case_p1: diffEqfunctionF=@RuntimeGeneratedFunction(diffEqfunctionExpression) # during the package's compilation time  case_p2: diffEqfunctionF=RuntimeGeneratedFunction(module,module,diffEqfunctionExpression) #generated at runtime in another module  case_p3: f1= Base.eval(module, diffEqfunctionExpression) diffEqfunctionF= (args...) -> Base.invokelatest(f1, args...)  case_p4: diffEqfunctionF= Base.eval(module, diffEqfunctionExpression)  case_p5: diffEqfunctionF=mk_function(diffEqfunctionExpression)","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"inside user space","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Case_u1:  all on top level","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"function mainModel()\nend\nf=ODEProblem(mainModel)\nsolve(f)","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Case_u2:  all on local scope","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"function test()\n      function mainModel()\n      end\n      f=ODEProblem(mainModel)\n      solve(f)\nend","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Case_u3:  mainModel function on top level and solve called from local scope  ","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"function mainModel()\nend\nfunction test()\n       f=ODEProblem(mainModel)\n      solve(f)\nend","category":"page"},{"location":"developer/problemFunction/#Discussion:","page":"Problem Function","title":"Discussion:","text":"","category":"section"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"First of all, if there are no helperF, f can see anything it needs. For the structures of the 3 cases above, there is no issue of visibility. Below only world age issues are discussed:","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Case_p1: @RuntimeGeneratedFunction ✅ Caseu1, Caseu2 and Case_u3 are fine, because @RuntimeGeneratedFunction (macro version) compiles early at compile-time and thus not subject to world age.","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Case_p2: RuntimeGeneratedFunction ✅ Caseu1: works, because at top level, solve(f) is interpreted — not precompiled — so it sees everything defined up to the current world age. ❌ Caseu2 and Case_u3: an error is thrown (The applicable method may be too new: running in world age) because inside a function, solve(f) is compiled earlier — in the world it was defined — so it may not see newer methods added afterward.","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"t0: 📦 ODEProblem defined\nt1: 🧑‍💻 function test() compiled (world age 100)\nt2: 🧑‍💻 test() called\nt3: 🧑‍💻 local mainModel defined\nt4: ⚙️ f = ODEProblem(mainModel)\n         └─ RuntimeGeneratedFunction(Main, Main, expr) adds method at world age 105\nt5: ⚙️ solve(f)\n         └─ fails: trying to call a method compiled at world age 105 from code compiled at 100\n         └─ 🔥 WorldAgeError","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Case_p3: Base.invokelatest ✅ Caseu1, Caseu2 and Case_u3 are fine, because it uses Julia's dynamic dispatch, bypassing the world age restrictions. However, it produces performance penalties.","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"case_p4: Base.eval This approach faces world age issues.","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"case_p5: mkfunction Although mkfunction elegantly avoids runtime eval, it comes with significant caveats:","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Only supports unnamed function expressions — named or typed functions fail\nCannot include type annotations (e.g., u::Vector{Float64})\nDoes not support references to external functions\nHigh latency & memory usage\nRisk of segfaults when functions grow enormous","category":"page"},{"location":"developer/problemFunction/#Visibility-of-helper-functions","page":"Problem Function","title":"Visibility of helper functions","text":"","category":"section"},{"location":"developer/problemFunction/#A-helper-function-**OUTSIDE**-the-mainModel-function:","page":"Problem Function","title":"A helper function OUTSIDE the mainModel function:","text":"","category":"section"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Case-by-case analysis:","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"inside user space","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Case_u1: **  Both functions live on **top level","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"function helperF()\nend\nfunction mainModel()\n    du=helperF()\nend\nf=ODEProblem(mainModel)\nsolve(f)","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Case_u2: **  Both function on **local scope","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"function test()\n      function helperF()\n      end\n      function mainModel()\n           du=helperF()\n      end\n      f=ODEProblem(mainModel)\n      solve(f)\nend","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Case_u3: **  mainModel function on **local scope and helper function on top level","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"function helperF()\nend\nfunction test()\n      function mainModel()\n           du=helperF()\n      end\n       f=ODEProblem(mainModel)\n      solve(f)\nend","category":"page"},{"location":"developer/problemFunction/#Discussion:-2","page":"Problem Function","title":"Discussion:","text":"","category":"section"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Case_p1: @RuntimeGeneratedFunction the f function is compiled  inside the package module, any helper function in the user scope is not seen during the evaluation of the package.  Caseu1, Caseu2 and Case_u3 an error is thrown (helperF is undefined).","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Case_p2: RuntimeGeneratedFunction The f function is compiled  inside the calling module (Main for example). Caseu1: works. Caseu2 and Case_u3: an error is thrown (The applicable method may be too new: running in world age)","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"Case_p3: Base.invokelatest Caseu1 and Caseu3: work. Case_u2: works an error is thrown (UndefVarError: helperF not defined)","category":"page"},{"location":"developer/problemFunction/#A-helper-function-**INSIDE**-the-mainModel-function:","page":"Problem Function","title":"A helper function INSIDE the mainModel function:","text":"","category":"section"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"For example:","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"function foo(du,u,p,t)\n  function bar(k, θ)\n  end\n  #differential equations\nend","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"This can be accomplished in 2 ways:","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"function bar should be placed inside the main function as is, but we have the following issues:","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"@RuntimeGeneratedFunction does not allow closure: it gives :","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"$(Expr(:opaque_closure, :((k, θ)->begin  ....instead of function fname(k, θ)","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"GeneralizedGenerated tricky to integrate\ninvokelatest is slow","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"function bar should be passed to the main function as is.","category":"page"},{"location":"developer/problemFunction/#dependency-not-extracted-from-helper-function","page":"Problem Function","title":"dependency not extracted from helper function","text":"","category":"section"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"It is difficult to extract Jac and dependencies from the bar(k, θ) functions. For example:","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"function bar(k, θ)\n         if 1 < k < 4\n            return Y[k-1] * sin(θ[k] - θ[k-1])  # Contribution from (k, k-1)\n         else\n            return Y[k] * sin(θ[k] )  # Contribution from (k)\n        end\n       \n    end","category":"page"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"A solution that has not been implemented is : during parsing, everytime a function call g(i,j) is detected, @code_string g(i,j) must be used to get the body of the helper function.","category":"page"},{"location":"developer/problemFunction/#Conclusion","page":"Problem Function","title":"Conclusion","text":"","category":"section"},{"location":"developer/problemFunction/","page":"Problem Function","title":"Problem Function","text":"  if helper_functions_outside_model_definition\n        warn_if_symbolic_jac\n        if is_top_level                     \n            RuntimeGeneratedFunction\n        else\n            warn_scope_performance\n            invokelatest\n        end\n    else\n      @RuntimeGeneratedFunction\n    end","category":"page"},{"location":"developer/quantizer/#Quantizer","page":"Quantizer","title":"Quantizer","text":"","category":"section"},{"location":"developer/quantizer/#The-Quantizer-functions","page":"Quantizer","title":"The Quantizer functions","text":"","category":"section"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"The system handles different quantizer orders (Order 1 and Order 2...). The quantizer functions define state integration, derivative computation, event time computation, quantized values updates, and cycle detection updates.","category":"page"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"computeNextTime: for first-order, the state of the system changes at a constant rate. The core calculation takes place when the first derivative of the state, represented by xi1, is non-zero. In this case, the function determines the time to the next event by dividing a quantum threshold by this derivative. Additionally, to prevent numerical issues, it ensures that this calculated time-step does not fall below a predefined minimum value, absDeltaT. If the first derivative is extremely small or essentially zero, the function adjusts it to avoid potential numerical instabilities that could arise from very small time increments.","category":"page"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"For second-order, the system state evolves with both a rate of change (first derivative) and acceleration (second derivative). The core calculation occurs when the second derivative of the state, represented by xi2, is non-zero. In this case, the function computes the time to the next event by using the square root of the ratio between a quantum threshold and the second derivative. This ensures that the time-step reflects the influence of the system's acceleration. Additionally, to prevent numerical issues (such as division by zero or overly small time-steps), a minimum delta time (absDeltaT) is enforced. If the computed time-step is smaller than this threshold, the function adjusts the second derivative to maintain stability. If the second derivative is zero but the first derivative is non-zero, the time to the next event is calculated based on the first derivative. The function ensures that the time-step does not drop below absDeltaT, adjusting the first derivative if necessary. If both derivatives are zero, the system is assumed to have no change, and the next event time is set to infinity (Inf).","category":"page"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"recomputeNextTime: The reComputeNextTime functions are used in the explicit QSS algorithms to enable the recalculation of the next time after interactions between different variables, such as variable i and variable j. These functions determine the time until the system crosses the quantum threshold by solving polynomial equations derived from the difference between the quantized state and the actual state. In situations where the quantum threshold has already been surpassed, they promptly return a very small time increment (e.g., simt + 1e-12) to trigger an immediate update of the system's state.","category":"page"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"LiqssrecomputeNextTime: In the LIQSS methods of first-order, the recomputeNextTime function calculates the next event time based on the current state (x), its first derivative (x1), and the quantized state (q). First, if the difference between the current state and the quantized state exceeds twice the quantum size, the next event is scheduled almost immediately with a small time-step. Otherwise, if the derivative is non-zero, the function computes the time-step by dividing the state difference by the derivative. If the result is positive, this time is added to the current simulation time (simt). If negative, it adjusts the time-step by either adding or subtracting twice the quantum size based on the direction of change. If the derivative is zero, indicating no change, the event time is set to infinity. Lastly, if the computed time is in the past, the function resets it to a far future time to prevent any premature events. This ensures that the system evolves smoothly and accurately.","category":"page"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"In the second-order LIQSS method, the recomputeNextTime function calculates the next event time by considering both the state (x) and its first (x1) and second (x2) derivatives, along with the quantized state (q). The function constructs a polynomial using the current state, derivative values, and the second derivative, then calculates the next event time by finding the smallest positive root of this polynomial.","category":"page"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"computeNextInputTime: The computeNextInputTime functions focus on computing the next action when derivatives depend only on time. They assess changes in the derivatives over a specified elapsed time to compute the time increment until the next input action. If the derivatives are null, the function reverts to handling the system in a lower-order thus simplifying the calculation.","category":"page"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"computeNextEventTime: The computeNextEventTime function calculates the next event time based on the zero-crossing function (ZCFun) of a system. It first checks if a sign change has occurred in the zero-crossing function, indicating that the system is leaving zero and should be considered an event, provided the previous value is significantly different from zero (to prevent duplicate events). If a sign change is detected, the function updates the event time to the current simulation time. If both the old and new values of the zero-crossing function are zero, it sets the next event time to infinity, indicating no event should occur. For cases where the old and new values have the same sign, it calculates the minimum positive root of the zero-crossing function, representing the time of the next event, ensuring that this time is not too close to zero to avoid spurious events. The function then updates the old sign values for future5 comparisons.","category":"page"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"updateQ: This methods updates the quantized variables during single updates","category":"page"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"isCycle_simulUpdate: This methods checks the presence of cycles and conducts a simultaneous update. The method picks a detection mechanism among several mechanisms based on a user parameter passed along the pipeline (Val{M}).","category":"page"},{"location":"developer/quantizer/#Quantizer-references","page":"Quantizer","title":"Quantizer references","text":"","category":"section"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.integrateState(::Val{0}, x::Taylor0,elapsed::Float64)","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.integrateState-Tuple{Val{0}, Taylor0, Float64}","page":"Quantizer","title":"QuantizedSystemSolver.integrateState","text":"integrateState(::Val{0}, x::Taylor0,elapsed::Float64)\n\ndoes nothing: created for elapse-updating q in order1 which does not happen. This is needed in order to have one integrator function for all orders.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.integrateState(::Val{1}, x::Taylor0,elapsed::Float64)","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.integrateState-Tuple{Val{1}, Taylor0, Float64}","page":"Quantizer","title":"QuantizedSystemSolver.integrateState","text":"integrateState(::Val{1}, x::Taylor0,elapsed::Float64)\n\nIntegrates the state for a first-order quantized system.\n\nArguments\n\n::Val{1}: A type parameter indicating the order of the quantized system.\nx::Taylor0: The current state variable x represented as a Taylor0 object.\nelapsed::Float64: The elapsed time since the last integration step of this variable x.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.integrateState(::Val{2}, x::Taylor0,elapsed::Float64)","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.integrateState-Tuple{Val{2}, Taylor0, Float64}","page":"Quantizer","title":"QuantizedSystemSolver.integrateState","text":"integrateState(::Val{2}, x::Taylor0,elapsed::Float64)\n\nIntegrates a state variable x and its first derivative using a second-order Taylor series approximation\n\nArguments\n\n::Val{2}: A type parameter indicating the order of the Taylor series (second-order in this case).\nx::Taylor0: The current state variable x represented as a Taylor0 object.\nelapsed::Float64: The elapsed time over which to integrate the state x.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.computeDerivative(::Val{1}, x::Taylor0, f::Taylor0)","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.computeDerivative-Tuple{Val{1}, Taylor0, Taylor0}","page":"Quantizer","title":"QuantizedSystemSolver.computeDerivative","text":"computeDerivative(::Val{1}, x::Taylor0, f::Taylor0)\n\ncopies the derivative from f to the first derivative of x for the first order.\n\nArguments\n\n::Val{1}: A type parameter indicating the order of the derivative.\nx::Taylor0: The state variable .\nf::Taylor0: The Taylor series function that corresponds to the derivative.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.computeDerivative(::Val{2}, x::Taylor0, f::Taylor0)","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.computeDerivative-Tuple{Val{2}, Taylor0, Taylor0}","page":"Quantizer","title":"QuantizedSystemSolver.computeDerivative","text":"computeDerivative(::Val{2}, x::Taylor0, f::Taylor0)\n\ncopies the first and second derivatives from f to the derivatives of x for the second-order quantizer.\n\nArguments\n\n::Val{2}: A type parameter indicating the order of the quantizer.\nx::Taylor0: The state variable .\nf::Taylor0: The Taylor series function that corresponds to the derivative.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.computeNextTime(::Val{1}, i::Int, simt::Float64, nextTime::Vector{Float64}, x::Vector{Taylor0}, quantum::Vector{Float64})","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.computeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}","page":"Quantizer","title":"QuantizedSystemSolver.computeNextTime","text":"computeNextTime(::Val{1}, i::Int, simt::Float64, nextTime::Vector{Float64}, x::Vector{Taylor0}, quantum::Vector{Float64})\n\nCompute the next time of change for a given state variable.\n\nArguments\n\n::Val{1}: A type parameter indicating a first order quantization method.\ni::Int: The index of the current state variable.\nsimt::Float64: The current simulation time.\nnextTime::Vector{Float64}: A vector containing the next time values for each state variable.\nx::Vector{Taylor0}: A vector of Taylor series coefficients representing the state variables and their derivatives.\nquantum::Vector{Float64}: A vector containing the quantum values for the state variables.\n\nReturns\n\nThe function updates the nextTime vector with the computed next time values for the state variables.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.computeNextTime(::Val{2}, i::Int, simt::Float64, nextTime::Vector{Float64}, x::Vector{Taylor0}, quantum::Vector{Float64})","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.computeNextTime-Tuple{Val{2}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}","page":"Quantizer","title":"QuantizedSystemSolver.computeNextTime","text":"computeNextTime(::Val{2}, i::Int, simt::Float64, nextTime::Vector{Float64}, x::Vector{Taylor0}, quantum::Vector{Float64})\n\nCompute the next time for a given state variable i in a second-order quantized system.\n\nArguments\n\n::Val{2}: A type parameter indicating the order of the quantized system (second-order).\ni::Int: The index of variable for which the next time is being computed.\nsimt::Float64: The current simulation time.\nnextTime::Vector{Float64}: A vector containing the next times for all variables.\nx::Vector{Taylor0}: A vector of Taylor series coefficients representing the state variables and their derivatives.\nquantum::Vector{Float64}: A vector of quantum values for the state variables.\n\nReturns\n\nNothing: This function updates the nextTime vector in place.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.reComputeNextTime(::Val{1}, index::Int, simt::Float64, nextTime::Vector{Float64}, x::Vector{Taylor0},q::Vector{Taylor0}, quantum::Vector{Float64})","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.reComputeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}","page":"Quantizer","title":"QuantizedSystemSolver.reComputeNextTime","text":"reComputeNextTime(::Val{1}, index::Int, simt::Float64, nextTime::Vector{Float64}, x::Vector{Taylor0},q::Vector{Taylor0}, quantum::Vector{Float64})\n\nRecomputes the next time for a given state variable i in a first-order quantized system after the derivative has changed. similar to computeNextTime but it also account for the first derivative change.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.reComputeNextTime(::Val{2}, index::Int, simt::Float64, nextTime::Vector{Float64}, x::Vector{Taylor0}, q::Vector{Taylor0}, quantum::Vector{Float64})","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.reComputeNextTime-Tuple{Val{2}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}","page":"Quantizer","title":"QuantizedSystemSolver.reComputeNextTime","text":"reComputeNextTime(::Val{2}, index::Int, simt::Float64, nextTime::Vector{Float64}, x::Vector{Taylor0}, q::Vector{Taylor0}, quantum::Vector{Float64})\n\nRecomputes the next time for a given state variable i in a second-order quantized system after the derivatives have changed. similar to computeNextTime but it also account for the first and second derivatives changes.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.computeNextInputTime(::Val{1}, i::Int, t::Taylor0,f::F,clF::FF,d::Vector{Float64}, taylorOpsCache::Vector{Taylor0} ,nextInputTime::Vector{Float64}, x::Vector{Taylor0},q::Vector{Taylor0}, quantum::Vector{Float64}) where {F,FF}","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.computeNextInputTime-Union{Tuple{FF}, Tuple{F}, Tuple{Val{1}, Int64, Taylor0, F, FF, Vector{Float64}, Vector{Taylor0}, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}} where {F, FF}","page":"Quantizer","title":"QuantizedSystemSolver.computeNextInputTime","text":"computeNextInputTime(::Val{1}, i::Int, t::Taylor0,f::F,clF::FF,d::Vector{Float64}, taylorOpsCache::Vector{Taylor0} ,nextInputTime::Vector{Float64}, x::Vector{Taylor0},q::Vector{Taylor0}, quantum::Vector{Float64}) where {F,FF}\n\nCompute the next input time for a given state variable in a first order method. This is needed when the differential equation depends on time only (i.e. does not depend on other state variables). It uses a prediction of the derivatives.\n\nArguments\n\n::Val{1}: A type parameter indicating the specific method to use.\ni::Int: The index of the current state variable.\nsimt::Float64: The current simulation time.\nelapsed::Float64: The elapsed time since the last update.\ntt::Taylor0: The Taylor series expansion of the state variable in a small time advance.\nnextInputTime::Vector{Float64}: A vector to store the computed next input times.\nx::Vector{Taylor0}: A vector of Taylor series expansions of the state variables.\nquantum::Vector{Float64}: A vector of quantum values for the state variables.\n\nReturns\n\nNothing, it updates the nextInputTime vector with the next input times for the state variables.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.computeNextInputTime(::Val{2}, i::Int, t::Taylor0,f::F,clF::FF,d::Vector{Float64}, taylorOpsCache::Vector{Taylor0} ,nextInputTime::Vector{Float64}, x::Vector{Taylor0},q::Vector{Taylor0}, quantum::Vector{Float64}) where {F,FF}","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.computeNextInputTime-Union{Tuple{FF}, Tuple{F}, Tuple{Val{2}, Int64, Taylor0, F, FF, Vector{Float64}, Vector{Taylor0}, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}} where {F, FF}","page":"Quantizer","title":"QuantizedSystemSolver.computeNextInputTime","text":"computeNextInputTime(::Val{2}, i::Int, t::Taylor0,f::F,clF::FF,d::Vector{Float64}, taylorOpsCache::Vector{Taylor0} ,nextInputTime::Vector{Float64}, x::Vector{Taylor0},q::Vector{Taylor0}, quantum::Vector{Float64}) where {F,FF}\n\nCompute the next input time for a given state variable in a second order method. This is needed when the differential equation depends on time only (i.e. does not depend on other state variables). It uses a prediction of the derivatives.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.computeNextEventTime(::Val{O},j::Int,ZCFun::Taylor0,oldsignValue::MMatrix{Z,2} ,simt::Float64,  nextEventTime :: MVector{Z,Float64}, quantum::Vector{Float64},absQ::Float64) where {O, Z}","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.computeNextEventTime-Union{Tuple{Z}, Tuple{O}, Tuple{Val{O}, Int64, Taylor0, MMatrix{Z, 2}, Float64, MVector{Z, Float64}, Vector{Float64}, Float64}} where {O, Z}","page":"Quantizer","title":"QuantizedSystemSolver.computeNextEventTime","text":"computeNextEventTime(::Val{O},j::Int,ZCFun::Taylor0,oldsignValue::MMatrix{Z,2} ,simt::Float64,  nextEventTime :: MVector{Z,Float64}, quantum::Vector{Float64},absQ::Float64) where {O, Z}\n\nCompute the next event time for a given zero-crossing function.\n\nArguments\n\n::Val{O}: A type parameter indicating the order of the quantizer.\nj::Int: The index of the zero-crossing function being processed.\nZCFun::Taylor0: the value of the zero-crossing function of type Taylor0.\noldsignValue::MMatrix{Z,2}: The previous sign and value of the zero-crossing function.\nsimt::Float64: The current simulation time.\nnextEventTime:: MVector{Z,Float64}: Vector contains the next event time for all zero-crossing functions.\nquantum::Vector{Float64}: A vector of quantum values for the state variables.\nabsQ::Float64: The absolute quantum value.\n\nReturns\n\nThe computed next event time for the state variable j.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.updateQ(::Val{1}, i::Int, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64},a::Float64, dxaux::Vector{MVector{1,Float64}}, qaux::Vector{MVector{1,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64, nextStateTime::Vector{Float64})","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.updateQ-Tuple{Val{1}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Float64, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}","page":"Quantizer","title":"QuantizedSystemSolver.updateQ","text":"updateQ(::Val{1}, i::Int, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64},a::Float64, dxaux::Vector{MVector{1,Float64}}, qaux::Vector{MVector{1,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64, nextStateTime::Vector{Float64})\n\nUpdate the quantized state for the LIQSS1 (Linearly Implicit Quantized State System 1) method.\n\nArguments\n\n::Val{1}: Type parameter indicating the LIQSS1 method.\ni::Int: Index of the state variable to update.\nxv::Vector{Taylor0}: Vector of current state values.\nqv::Vector{Taylor0}: Vector of quantized state values.\nquantum::Vector{Float64}: Vector of quantum values for the state variables.\nexactA::Function: Function to compute the exact value of a jacobian entry.\nd::Vector{Float64}: Vector of discrete variables.\ncacheA::MVector{1,Float64}: Cache for jacobian entry computation.\ndxaux::Vector{MVector{1,Float64}}: Auxiliary vector for saving old x values.\nqaux::Vector{MVector{1,Float64}}: Auxiliary vector for saving old quantized values.\ntx::Vector{Float64}: Vector of times at which the state variables were updated.\ntq::Vector{Float64}: Vector of times at which the quantized state variables were updated.\nsimt::Float64: Current simulation time.\nft::Float64: Final time of the simulation.\nnextStateTime::Vector{Float64}: Vector of times at which the state variables will be updated next.\n\nReturns\n\nNone. The function updates the quantized state and other info in place.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.updateQInit(::Val{1}, i::Int, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64},a::Float64,  dxaux::Vector{MVector{1,Float64}}, qaux::Vector{MVector{1,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64, nextStateTime::Vector{Float64})","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.updateQInit-Tuple{Val{1}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Float64, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}","page":"Quantizer","title":"QuantizedSystemSolver.updateQInit","text":"updateQInit(::Val{1}, i::Int, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64},a::Float64,  dxaux::Vector{MVector{1,Float64}}, qaux::Vector{MVector{1,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64, nextStateTime::Vector{Float64})\n\nInitialize the quantized state for the LIQSS1 method.\n\nArguments\n\n::Val{1}: Type parameter indicating the LIQSS1 method.\ni::Int: Index of the state variable to update.\nxv::Vector{Taylor0}: Vector of state variables.\nqv::Vector{Taylor0}: Vector of quantized state variables.\nquantum::Vector{Float64}: Vector of quantum values for the state variables.\nexactA::Function: Function to compute the exact value of the state variable.\nd::Vector{Float64}: Vector of derivatives of the state variables.\ncacheA::MVector{1,Float64}: Cache for intermediate computations.\ndxaux::Vector{MVector{1,Float64}}: Auxiliary vector for derivatives.\nqaux::Vector{MVector{1,Float64}}: Auxiliary vector for quantized states.\ntx::Vector{Float64}: Vector of times at which state variables were last updated.\ntq::Vector{Float64}: Vector of times at which quantized state variables were last updated.\nsimt::Float64: Current simulation time.\nft::Float64: Final simulation time.\nnextStateTime::Vector{Float64}: Vector of times at which the next state update is scheduled.\n\nDescription\n\nThis function initializes the quantized state for the LIQSS1 method by updating the quantized state variables and their associated times based on the provided state variables, derivatives, and quantum values.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.Liqss_reComputeNextTime(::Val{1}, i::Int, simt::Float64, nextStateTime::Vector{Float64}, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64})","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.Liqss_reComputeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}","page":"Quantizer","title":"QuantizedSystemSolver.Liqss_reComputeNextTime","text":"Liqss_reComputeNextTime(::Val{1}, i::Int, simt::Float64, nextStateTime::Vector{Float64}, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64})\n\nRecomputes the next time for the LIQSS1 quantizer.\n\nArguments\n\n::Val{1}: Type parameter indicating the LIQSS1 method.\ni::Int: Index of the state variable.\nsimt::Float64: Current simulation time.\nnextStateTime::Vector{Float64}: Vector containing the next state times for each state variable.\nxv::Vector{Taylor0}: Vector of current state values represented as Taylor series.\nqv::Vector{Taylor0}: Vector of quantized state values represented as Taylor series.\nquantum::Vector{Float64}: Vector of quantum values for the state variables.\n\nReturns\n\nUpdates the nextStateTime vector with the recomputed next time for the specified state variable.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.isCycle_simulUpdate(aii::Float64,ajj::Float64,aij::Float64,aji::Float64,trackSimul,::Val{1},::Val{M},i::Int,j::Int,dirI::Float64, x::Vector{Taylor0},q::Vector{Taylor0}, quantum::Vector{Float64},dxaux::Vector{MVector{1,Float64}},qaux::Vector{MVector{1,Float64}},tx::Vector{Float64},tq::Vector{Float64},simt::Float64,ft::Float64) where {M}","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.isCycle_simulUpdate-Union{Tuple{M}, Tuple{Float64, Float64, Float64, Float64, Any, Val{1}, Val{M}, Int64, Int64, Float64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64}} where M","page":"Quantizer","title":"QuantizedSystemSolver.isCycle_simulUpdate","text":"isCycle_simulUpdate(aii::Float64,ajj::Float64,aij::Float64,aji::Float64,trackSimul,::Val{1},::Val{M},i::Int,j::Int,dirI::Float64, x::Vector{Taylor0},q::Vector{Taylor0}, quantum::Vector{Float64},dxaux::Vector{MVector{1,Float64}},qaux::Vector{MVector{1,Float64}},tx::Vector{Float64},tq::Vector{Float64},simt::Float64,ft::Float64) where {M}\n\nPerforms a simultaneous update of two quantized variables qi and qj if cycle conditions are met.\n\nArguments\n\naij::Float64: linear approximation Coefficient for the jacobian entry between variable i and variable j.\naji::Float64: linear approximation Coefficient for the jacobian entry between variable j and variable i.\ntrackSimul: A tracking object for the simulataneous update.\n::Val{1}: A type parameter indicating the method order is order 1.\n::Val{M}: A type parameter indicating the detection mechanism.\ni::Int: The i of the current variable.\nj::Int: The i of the interacting variable.\ndirI::Float64: Direction of variable i.\nx::Vector{Taylor0}: State vector of Taylor series coefficients for the variables.\nq::Vector{Taylor0}: Quantized state vector of Taylor series coefficients for the variables.\nquantum::Vector{Float64}: Quantum levels for the variables.\nexactA::Function: Function to compute the exact value of a jacobian entry.\nd::Vector{Float64}: discrete variables.\ncacheA::MVector{1,Float64}: Cache for jacobian entry computation.\ndxaux::Vector{MVector{1,Float64}}: Auxiliary vector for old x values.\nqaux::Vector{MVector{1,Float64}}: Auxiliary vector for old quantized values.\ntx::Vector{Float64}: Time vector for state updates.\ntq::Vector{Float64}: Time vector for quantized state updates.\nsimt::Float64: Current simulation time.\nft::Float64: Final time for the simulation.\n\nReturns\n\nNone. The function performs in-place updates on the quantized state vectors.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.updateQ(::Val{2}, i::Int, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64}, a::Float64, dxaux::Vector{MVector{2,Float64}}, qaux::Vector{MVector{2,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64, nextStateTime::Vector{Float64})","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.updateQ-Tuple{Val{2}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Float64, Vector{MVector{2, Float64}}, Vector{MVector{2, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}","page":"Quantizer","title":"QuantizedSystemSolver.updateQ","text":"updateQ(::Val{2}, i::Int, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64}, a::Float64, dxaux::Vector{MVector{2,Float64}}, qaux::Vector{MVector{2,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64, nextStateTime::Vector{Float64})\n\nUpdate the quantized state for the second-order quantizer.\n\nArguments\n\n::Val{2}: Type parameter indicating the second-order quantizer.\ni::Int: Index of the state variable to update.\nxv::Vector{Taylor0}: Vector of state variables.\nqv::Vector{Taylor0}: Vector of quantized state variables.\nquantum::Vector{Float64}: Vector of quantum values of the state variables.\nexactA::Function: Function to compute the exact value of a jacobian entry.\nd::Vector{Float64}: Vector of discrete variables.\ncacheA::MVector{1,Float64}: Cache for jacobian entry computation.\ndxaux::Vector{MVector{2,Float64}}: Auxiliary vector for saving old x values.\nqaux::Vector{MVector{2,Float64}}: Auxiliary vector for saving old quantized values.\ntx::Vector{Float64}: Vector of state update times.\ntq::Vector{Float64}: Vector of quantized state update times.\nsimt::Float64: Current simulation time.\nft::Float64: Final time of the simulation.\nnextStateTime::Vector{Float64}: Vector of times for the next state updates.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.updateQInit(::Val{2}, i::Int, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64}, a::Float64,dxaux::Vector{MVector{2,Float64}}, qaux::Vector{MVector{2,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64, nextStateTime::Vector{Float64})","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.updateQInit-Tuple{Val{2}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Float64, Vector{MVector{2, Float64}}, Vector{MVector{2, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}","page":"Quantizer","title":"QuantizedSystemSolver.updateQInit","text":"updateQInit(::Val{2}, i::Int, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64}, a::Float64,dxaux::Vector{MVector{2,Float64}}, qaux::Vector{MVector{2,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64, nextStateTime::Vector{Float64})\n\nInitialize the quantized state variables for the LIQSS2 method. It is similar to the updateQ function but does not accept q to be set to x when all derivatives are zero, which is the case when an equilibrium ocurrs during the simulation.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.Liqss_reComputeNextTime(::Val{2}, i::Int, simt::Float64, nextStateTime::Vector{Float64}, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64})","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.Liqss_reComputeNextTime-Tuple{Val{2}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}","page":"Quantizer","title":"QuantizedSystemSolver.Liqss_reComputeNextTime","text":"Liqss_reComputeNextTime(::Val{2}, i::Int, simt::Float64, nextStateTime::Vector{Float64}, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64})\n\nRecomputes the next time for a given state in a second-order quantized state system.\n\nArguments\n\n::Val{2}: A type parameter indicating the order of the quantized state system (second-order in this case).\ni::Int: The index of the state for which the next time is being recomputed.\nsimt::Float64: The current simulation time.\nnextStateTime::Vector{Float64}: A vector containing the next state times for all states.\nxv::Vector{Taylor0}: A vector containing the current state values represented as Taylor series.\nqv::Vector{Taylor0}: A vector containing the quantized state values represented as Taylor series.\nquantum::Vector{Float64}: A vector containing the quantum values the states.\n\nReturns\n\nThis function does not return a value. It updates the nextStateTime vector in place.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.isCycle_simulUpdate(aii::Float64,ajj::Float64,aij::Float64,aji::Float64,trackSimul,::Val{2},::Val{M},index::Int,j::Int,dirI::Float64, x::Vector{Taylor0},q::Vector{Taylor0}, quantum::Vector{Float64},dxaux::Vector{MVector{2,Float64}},qaux::Vector{MVector{2,Float64}},tx::Vector{Float64},tq::Vector{Float64},simt::Float64,ft::Float64) where {M}","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.isCycle_simulUpdate-Union{Tuple{M}, Tuple{Float64, Float64, Float64, Float64, Any, Val{2}, Val{M}, Int64, Int64, Float64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Vector{MVector{2, Float64}}, Vector{MVector{2, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64}} where M","page":"Quantizer","title":"QuantizedSystemSolver.isCycle_simulUpdate","text":"isCycle_simulUpdate(aii::Float64,ajj::Float64,aij::Float64,aji::Float64,trackSimul,::Val{2},::Val{M},index::Int,j::Int,dirI::Float64, x::Vector{Taylor0},q::Vector{Taylor0}, quantum::Vector{Float64},dxaux::Vector{MVector{2,Float64}},qaux::Vector{MVector{2,Float64}},tx::Vector{Float64},tq::Vector{Float64},simt::Float64,ft::Float64) where {M}\n\nPerforms a simultaneous update of two quantized variables qi and qj and their derivatives if cycle conditions are met. This is similar to the isCycle_simulUpdate order 1 function.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/#Cycle-Detection","page":"Quantizer","title":"Cycle Detection","text":"","category":"section"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.detect1(::Val{1}, ẋi, dxP, dxi, ẋj, dxj)","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.detect1-Tuple{Val{1}, Any, Any, Any, Any, Any}","page":"Quantizer","title":"QuantizedSystemSolver.detect1","text":"detect1(::Val{1}, ẋi, dxP, dxi, ẋj, dxj)\n\ncycle detection in order 1 that uses mechanism type 1. ẋi is used and only change of direction is checked.\n\nArguments\n\n::Val{1}: Type parameter indicating the cycle detection mechanism type 1.\nẋi: Derivative of the first variable.\ndxP: derivative the first variable used to update the quantized variable q.\ndxi: prediction of the derivative of the first variable.\nẋj: Derivative of the second variable.\ndxj: prediction of the derivative of the second variable.\n\nReturns\n\nA boolean indicating whether a cycle is present.\n\nreturn  (dxj*ẋj)<0.0 && (dxi*ẋi)<0.0\n\nNotes\n\nThis function is used internally by the integrator to detect the presence of a cycle.\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.detect1(::Val{2}, ẋi, dxP, dxi, ẋj, dxj)","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.detect1-Tuple{Val{2}, Any, Any, Any, Any, Any}","page":"Quantizer","title":"QuantizedSystemSolver.detect1","text":"detect1(::Val{2}, ẋi, dxP, dxi, ẋj, dxj)\n\ncycle detection in order 1 that uses mechanism type 2. dxP is used and only change of direction is checked.\n\nReturns\n\nA boolean indicating whether a cycle is present.\n\nreturn  (dxj*ẋj)<0.0 && (dxi*dxP)<0.0\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.detect1(::Val{3}, ẋi, dxP, dxi, ẋj, dxj)","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.detect1-Tuple{Val{3}, Any, Any, Any, Any, Any}","page":"Quantizer","title":"QuantizedSystemSolver.detect1","text":"detect1(::Val{3}, ẋi, dxP, dxi, ẋj, dxj)\n\ncycle detection in order 1 that uses mechanism type 3. ẋi is used and significant changes in the derivatives are also checked.\n\nReturns\n\nA boolean indicating whether a cycle is present.\n\nreturn  abs(dxj-ẋj)>abs(dxj+ẋj)/2 && abs(dxi-ẋi)>abs(dxi+ẋi)/2\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.detect1(::Val{4}, ẋi, dxP, dxi, ẋj, dxj)","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.detect1-Tuple{Val{4}, Any, Any, Any, Any, Any}","page":"Quantizer","title":"QuantizedSystemSolver.detect1","text":"detect1(::Val{4}, ẋi, dxP, dxi, ẋj, dxj)\n\ncycle detection in order 1 that uses mechanism type 3. dxP is used and significant changes in the derivatives are also checked.\n\nReturns\n\nA boolean indicating whether a cycle is present.\n\nreturn  abs(dxj-ẋj)>abs(dxj+ẋj)/2 && abs(dxi-dxP)>abs(dxi+dxP)/2\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.detect2(::Val{1},xi1,dxi,dxithrow,xi2,ddxi,ddxithrow,βidir,βidth,xj1,dxj,xj2,ddxj,dqjplus,recentjDir,dirI)","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.detect2-Tuple{Val{1}, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}","page":"Quantizer","title":"QuantizedSystemSolver.detect2","text":"detect2(::Val{1},xi1,dxi,dxithrow,xi2,ddxi,ddxithrow,βidir,βidth,xj1,dxj,xj2,ddxj,dqjplus,recentjDir,dirI)\n\ncycle detection in order 2 that uses mechanism type 1. xi1 and xi2 are used. changes in the derivatives are checked.\n\nReturns\n\nA boolean indicating whether a cycle is present.\n\n if (abs(dxj-xj1)>(abs(dxj+xj1)/2) || abs(ddxj-xj2)>(abs(ddxj+xj2)/2))  \n    return (abs(dxi-xi1)>(abs(dxi+xi1)/2) || abs(ddxi-xi2)>(abs(ddxi+xi2)/2))  \n  else  \n    return false\n  end\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.detect2(::Val{2},xi1,dxi,dxithrow,xi2,ddxi,ddxithrow,βidir,βidth,xj1,dxj,xj2,ddxj,dqjplus,recentjDir,dirI)","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.detect2-Tuple{Val{2}, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}","page":"Quantizer","title":"QuantizedSystemSolver.detect2","text":"detect2(::Val{2},xi1,dxi,dxithrow,xi2,ddxi,ddxithrow,βidir,βidth,xj1,dxj,xj2,ddxj,dqjplus,recentjDir,dirI)\n\ncycle detection in order 2 that uses mechanism type 2. dxithrow and ddxithrow are used. changes in the derivatives are checked.\n\nReturns\n\nA boolean indicating whether a cycle is present.\n\n  if (abs(dxj-xj1)>(abs(dxj+xj1)/2) || abs(ddxj-xj2)>(abs(ddxj+xj2)/2))  \n    return (abs(dxi-dxithrow)>(abs(dxi+dxithrow)/2) || abs(ddxi-ddxithrow)>(abs(ddxi+ddxithrow)/2)) \n  else  \n    return false\n  end\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.detect2(::Val{3},xi1,dxi,dxithrow,xi2,ddxi,ddxithrow,βidir,βidth,xj1,dxj,xj2,ddxj,dqjplus,recentjDir,dirI)","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.detect2-Tuple{Val{3}, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}","page":"Quantizer","title":"QuantizedSystemSolver.detect2","text":"detect2(::Val{3},xi1,dxi,dxithrow,xi2,ddxi,ddxithrow,βidir,βidth,xj1,dxj,xj2,ddxj,dqjplus,recentjDir,dirI)\n\ncycle detection in order 2 that uses mechanism type 3. xi1 and xi2 are used. changes in the derivatives are checked, changes in direction are also checked.\n\nReturns\n\nA boolean indicating whether a cycle is present.\n\n  if (abs(dxj-xj1)>(abs(dxj+xj1)/2) || abs(ddxj-xj2)>(abs(ddxj+xj2)/2))  || dqjplus*recentjDir<0.0 \n    return (abs(dxi-xi1)>(abs(dxi+xi1)/2) || abs(ddxi-xi2)>(abs(ddxi+xi2)/2)) || βidir*dirI<0.0\n  else  \n    return false\n  end\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"QuantizedSystemSolver.detect2(::Val{4},xi1,dxi,dxithrow,xi2,ddxi,ddxithrow,βidir,βidth,xj1,dxj,xj2,ddxj,dqjplus,recentjDir,dirI)","category":"page"},{"location":"developer/quantizer/#QuantizedSystemSolver.detect2-Tuple{Val{4}, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any}","page":"Quantizer","title":"QuantizedSystemSolver.detect2","text":"detect2(::Val{4},xi1,dxi,dxithrow,xi2,ddxi,ddxithrow,βidir,βidth,xj1,dxj,xj2,ddxj,dqjplus,recentjDir,dirI)\n\ncycle detection in order 2 that uses mechanism type 3. dxithrow and ddxithrow are used. changes in the derivatives are checked, changes in direction are also checked.\n\nReturns\n\nA boolean indicating whether a cycle is present.\n\n  if (abs(dxj-xj1)>(abs(dxj+xj1)/2) || abs(ddxj-xj2)>(abs(ddxj+xj2)/2))  || dqjplus*recentjDir<0.0 \n    return (abs(dxi-dxithrow)>(abs(dxi+dxithrow)/2) || abs(ddxi-ddxithrow)>(abs(ddxi+ddxithrow)/2)) || βidir*βidth<0.0\n  else  \n    return false\n  end\n\n\n\n\n\n","category":"method"},{"location":"developer/quantizer/#Index","page":"Quantizer","title":"Index","text":"","category":"section"},{"location":"developer/quantizer/","page":"Quantizer","title":"Quantizer","text":"Pages = [\"quantizer.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"background/mliqss/#Modified-Linearly-Implicit-Quantized-State-System-Methods","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"","category":"section"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"In LIQSS, all steps involves single variable updates depending on the future direction of x_i, as shown in bullet 4 of the mLIQSS1 algorithm. While this intrinsic behavior of single cheap steps is advantageous, an issue arises from it. This asynchrony in updates can lead to unintended interactions between variables, causing them to stray from the true solution and trigger subsequent steps sooner than necessary. This behavior can result in cycles and unnecessary steps in the simulation.  In essence, the lack of synchronization in variable updates can introduce unintended feedback loops, disrupting the simulation dynamics and potentially leading to inaccuracies or inefficiencies in the simulation results. Addressing this issue involves cycle detection mechanisms [1].","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"The following conditions in Eq.(3) are used to detect cycles for order 1:","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"    beginalign\n       dot x_jdx_j0    and  dot x_idx_i0\n    endalign","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"where dx_i and dx_j are linear approximations of the future derivatives. They are given as follows: ","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"beginalign\n  dx_i=a_iiq_i+a_ijq_j+u_ij  nonumber\n  dx_j=a_jjq_j+a_jiq_i+u_ji\nendalign","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"where a_ij is the entry (i,j) of the Jacobian of the linearized derivative function and u_ij is an affine coefficient.","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"A modification to the original LIQSS algorithm was implemented in the following Algorithm:","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"mLIQSS1 algorithm","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"If a variable i needs to change\nCompute the elapsed time e since the last update of variable i\nUpdate its value using Taylor expansion: x_i=x_i+dot x_ie\nUpdate the quantum Delta_i\nIf dot x  (a_ii(x_i+sign(dot x)Delta_i)+u_ii) 0\nUpdate the Quantized variable q_i=x_i+sign(dot x)Delta_i\nElse\nUpdate the Quantized variable q_i=frac-u_iia_ii   \nCompute the next time when q_i=x_i \nFor any variable j depends on i such that a_ija_ji neq 0\ncompute the prediction of derivatives of i and j using Eq.(2)\nIf the conditions in Eq.(1) are met:\nperform a Backward Euler step as shown in Eq.(4) using The Iteration approach in the simultaneous update order 1\nFor any variable k that depends on j\nupdate x_k, dot x_k, a_kj, and next time of change.\nFor any variable j depends on i\nUpdate the variable x_j=x_j+dot x_je_j\nUpdate the derivative dot x_j=f_j(qt) \nCompute the next time when q_j=x_j  or q_j-x_j=2Delta_i \nFor any zero crossing function zc depends on i\nUpdate zc\nCompute the next event time of zc \nIf an event needs to occur\nRecheck validity of the event\nExecute the event and update the related quantized variables\nFor any variable j depends on the event\nUpdate the variable x_j=x_j+dot x_je_j\nUpdate the derivative dot x_j=f_j(Qt) \nCompute the next time when q_j=x_j  or q_j-x_j=2Delta_j \nFor any zero crossing function zc depends on the event\nUpdate zc\nCompute the next event time of zc ","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"The Iteration approach in the simultaneous update order 1","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"Update the step size h=FinalSimulationTime-currentSimTime; \nq_i=x_i+ds_i(h) \\; q_j=x_j+ds_j(h)\nIf (q_i-x_iDelta_i or q_j-x_jDelta_j)\nUpdate the step size h_i=fracDelta_idot x_i;  h_j=fracDelta_jdot x_j; h=min(h_ih_j)\nUpdate the Quantized variable q_i=x_i+ds_i(h) ; q_j=x_j+ds_j(h)\nWhile (q_i-x_iDelta_i or q_j-x_jDelta_j) and AllowedIters0\nUpdate AllowedIters=AllowedIters-1\nUpdate the step size h_i=h_isqrtfracDelta_iq_i-x_i; h_j=h_jsqrtfracDelta_jq_j-x_j; h=min(h_ih_j)\nUpdate the Quantized variable q_i=x_i+ds_i(h) ; q_j=x_j+ds_j(h)\nIf AllowedIters=0\ncancel the simultnaeous update and perform a LIQSS step","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"When a cycle is detected, a simultaneous update must occur.   In order to simultaneously update q_i and q_j as the future values of x_i and x_j, the following equation is used:","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"beginalign\n  q_i=x_i+hdx_i   nonumber\n  q_j=x_j+hdx_j \nendalign","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"Using this equation and Eq.(2) is equivalent to performing a Backward Euler step, and it can formulated as follows:","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"beginequation\nQ_ij=(I-hA_ij)^-1(X_ij+hU_ij)\nendequation","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"where  Q_ij= beginpmatrix   q_i     q_j  endpmatrix; A_ij=  beginpmatrix   a_ii  a_ij    a_ji  a_jj endpmatrix; X_ij= beginpmatrix   x_i     x_j  endpmatrix; and U_ij= beginpmatrix   u_ij     u_ji  endpmatrix ","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"The value of h is computed analytically or via iterations as the maximum value that satisfies Eq.(5).","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"beginalign\nq_i-x_i leq Delta_i  q_j-x_j leq Delta_j\nendalign","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"Where Delta_i  and Delta_j  are the quantums of the variables x_i and x_j respectively.","category":"page"},{"location":"background/mliqss/#mLIQSS2","page":"Modified Linearly Implicit Quantized State System Methods","title":"mLIQSS2","text":"","category":"section"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"While higher-order methods offer improved accuracy in tracking the system's dynamics, they also introduce additional challenges. One of the key issues arises from the increased complexity in variable interactions, which can lead to discrepancies between the predicted and actual trajectories of the variables, potentially causing premature or unnecessary steps in the simulation.To address these challenges, conducting the cycle detection mechanism and updating the quatized states consider higher order terms.","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"Cycle detection mechanisms for Order 2 must consider both the first and second derivatives of the variables. The following conditions in Eq.(6) are used to detect cycles for Order 2:","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"beginalign\n    dot x_j-dx_jfracdot x_j+dx_j2  or  ddot x_j-ddx_jfracddot x_j+ddx_j2 nonumber\n   qquad qquad qquad  qquad qquad and nonumber\n    dot x_i-dx_ifracdot x_i+dx_i2   or  ddot x_i-ddx_ifracddot x_i+ddx_i2\n\n  endalign","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"where ddx_i and ddx_j are linear approximations of the future second derivatives. They are given as shown in Eq.(7). ","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"beginalign\n  ddx_i=a_iidot q_i+a_ijdot q_j+dot u_ij  nonumber\n  ddx_j=a_jjdot q_j+a_jidot q_i+dot u_ji\nendalign","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"where dot u_ij is an affine coefficient.  ","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"To account for these second-order effects, modifications to the original LIQSS algorithm were implemented, as shown in the mLIQSS2 algorithm. The algorithm ensures that the higher-order derivatives are properly integrated into the update rules.","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"The mLIQSS order 2 method is defined in the following Algorithm. mLIQSS2 algorithm ","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"If a variable i needs to change\nCompute the elapsed time e since the last update of variable i\nUpdate the variable x_i=x_i+dot x_ie_i+frac12ddot x_ie_i^2\nUpdate the quantum Delta_i\nUpdate the derivative dot x_i=dot x_i+ddot x_ie\nUpdate the affine coefficient u_ii = dot x_i - a_ii  (q_i+dot q_ie_i)\nUpdate the derivative of the affine coefficient dot u_ii = ddot x_i - a_ii  dot q_i\nThe Quantized variable q_i(h)=frac(x_i-ha_iix_i-h^2(au_ii+dot u_ii)2)(1 - h  a_ii + h^2a_ii^2  2)\nUpdate the step size h=FinalSimulationTime-currentSimTime;  q_i=q_i(h)\nIf q_i-x_iDelta_i\nUpdate the step size h=sqrtfrac2Delta_iddx_i;  q_i=q_i(h)\nWhile q_i-x_iDelta_i\nUpdate the step size h=hsqrtfracDelta_iq_i-x_i;  q_i=q_i(h)\nUpdate the Quantized derivative dot q_i=fraca_iiq_i+u_ii+hdot u_ii1-ha_ii\nCompute the next time when q_i=x_i \nFor any variable j depends on i such that a_ija_ji neq 0\ncompute the prediction of derivatives of i and j using Eq.(7)\nIf the conditions in Eq.(6) are met:\nperform a simultaneous update as shown in Eq.(9) using The Iteration approach in the simultaneous update order 2\nFor any variable k that depends on j\nupdate x_k, dot x_k, ddot x_k, a_kj, and next time of change.\nFor any variable j depends on i\nUpdate the variable x_j=x_j+dot x_je_j+frac12ddot x_je_j^2\nFor any variable k that f_j depends upon\nUpdate the Quantized variable q_k=q_k+dot q_ke_k \nUpdate the derivatives dot x_j=f_j(qt)  and ddot x_j=dot f_j(Qt) \nCompute the next time when q_j=x_j  or q_j-x_j=2Delta_i \nFor any zero crossing function zc depends on i\nFor any variable k that zc depends upon\nUpdate the Quantized variable q_k=q_k+dot q_ke_k\nUpdate zc\nCompute the next event time of zc \nIf an event needs to occur\nRecheck validity of the event\nExecute the event and update the related quantized variables\nFor any variable j depends on the event\nUpdate the variable x_j=x_j+dot x_je_j+frac12ddot x_je_j^2\nFor any variable k that f_j depends upon\nUpdate the Quantized variable q_k=q_k+dot q_ke_k\nUpdate the derivatives dot x_j=f_j(Qt)  and ddot x_j=dot f_j(Qt) \nCompute the next time when q_j=x_j  or q_j-x_j=2Delta_j \nFor any zero crossing function zc depends on the event\nFor any variable k that zc depends upon\nUpdate the Quantized variable q_k=q_k+dot q_ke_k\nUpdate zc\nCompute the next event time of zc ","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"The Iteration approach in the simultaneous update order 2","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"Update the step size h=FinalSimulationTime-currentSimTime; \nCalculate q_i and q_j using Eq.(10)\nIf (q_i-x_iDelta_i or q_j-x_jDelta_j)\nUpdate the step size h_i=sqrtfrac2Delta_iddx_i;  h_j=sqrtfrac2Delta_jddx_j; h=min(h_ih_j)\ncalculate q_i and q_j using Eq.(10)\nWhile (q_i-x_iDelta_i or q_j-x_jDelta_j) and AllowedIters0\nUpdate AllowedIters=AllowedIters-1\nUpdate the step size h_i=h_isqrtfracDelta_iq_i-x_i; h_j=h_jsqrtfracDelta_jq_j-x_j; h=min(h_ih_j)\nCalculate q_i and q_j using Eq.(10)\nIf AllowedIters=0\nCancel the simultnaeous update and perform a LIQSS step\nCalculate dot q_i and dot q_j using Eq.(9)","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"When cycles are detected in Order 2, simultaneous updates must account for both the positions and second-order derivatives of the involved variables. This requires solving the following system of equations for q_i and q_j:","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"beginalign\n   q_i+hdot q_i=x_i+hdx_i+h^2ddx_i2  nonumber \n   dot q_i=dx_i+hddx_i nonumber\n   q_j+hdot q_j=x_j+hdx_j+h^2ddx_j2 nonumber\n   dot q_j=dx_j+hddx_j \n endalign","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"Using Eq.(8), Eq.(2) and Eq.(7) is equivalent to the following:","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":" beginalign\n dot Q_ij=(I-hA_ij)^-1(A_ijQ_ij+U_ij+hdot U_ij) nonumber\n  Q_ij+hdot Q_ij=(X_ij+h(A_ijQ_ij+U_ij)+h^2(A_ijdot Q_ij+dot U_ij)2)\n endalign","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":" beginalign\n   alpha=X_ij+hU_ij+h^2dot U_ij2 nonumber\n   beta=-(hI-h^2A_ij2)(I-hA_ij)^-1(U_ij+hdot U_ij)+alpha nonumber\n   gamma=(I-hA_ij)+(hI-h^2A_ij2)(I-hA_ij)^-1A_ij nonumber\n   Q_ij= gamma^-1beta\n  endalign","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"where   dot Q_ij= beginpmatrix   dot q_i     dot q_j   endpmatrix and dot U_ij= beginpmatrix   dot u_ij     dot u_ji   endpmatrix ","category":"page"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"The value of h is computed analytically or via iterations as the maximum value that satisfies Eq.(5).","category":"page"},{"location":"background/mliqss/#refs3","page":"Modified Linearly Implicit Quantized State System Methods","title":"References","text":"","category":"section"},{"location":"background/mliqss/","page":"Modified Linearly Implicit Quantized State System Methods","title":"Modified Linearly Implicit Quantized State System Methods","text":"[1]  F. Pietro, G. Migoni, and E. Kofman. Improving linearly implicit quantized state system methods. Simulation: Transactions of the Society for Modeling and Simulation International, vol.95(no.2):pp.127–144, 2019.","category":"page"},{"location":"developer/solution/#Solution","page":"Solution","title":"Solution","text":"","category":"section"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"This is where the results of the simulation are stored, including: Settings, Time points (times[]), Variables (vars[]), Statistics (stats).","category":"page"},{"location":"developer/solution/#Problem-extension","page":"Solution","title":"Problem extension","text":"","category":"section"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"The Solution entity can be extended by subclassing:","category":"page"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"Sol{T,O}","category":"page"},{"location":"developer/solution/#QuantizedSystemSolver.Sol","page":"Solution","title":"QuantizedSystemSolver.Sol","text":"Sol{T,O}\n\nThis is a superclass for all QSS solutions. It is parametric on:\n\nThe number of continuous variables T\nThe order of the algorithm O\n\n\n\n\n\n","category":"type"},{"location":"developer/solution/#What-is-needed-with-a-new-Solution:","page":"Solution","title":"What is needed with a new Solution:","text":"","category":"section"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"Extending a solution is easier than extending the Problem and the Algorithm. Some cases are presented as follows:","category":"page"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"Creating a new feature: no extra work is needed except the feature itself.\nCreating a new solution similar to the LightSol: no extra work is needed except the definition of the new type subclassing Sol.\nCreating a solution that differs from the LightSol: extend all functions that refer to fields that do not exist in the new type.","category":"page"},{"location":"developer/solution/#Example","page":"Solution","title":"Example","text":"","category":"section"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"struct HeavySol{T,O}<:Sol{T,O}\n  size::Val{T}\n  order::Val{O}\n  savedTimes::Vector{Vector{Float64}}\n  savedVars::Vector{Vector{Taylor0}}\nend","category":"page"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"Here, the heavy solution contains all variables and their derivatives. The evaluateSol function can be reimplemented to use the derivatives for interpolation.","category":"page"},{"location":"developer/solution/#Define-and-create-a-solution","page":"Solution","title":"Define and create a solution","text":"","category":"section"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"An implemented concrete solution type is: ","category":"page"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"QuantizedSystemSolver.LightSol{T,O}","category":"page"},{"location":"developer/solution/#QuantizedSystemSolver.LightSol","page":"Solution","title":"QuantizedSystemSolver.LightSol","text":"LightSol{T,O}\n\nA struct that holds the solution of a system of ODEs. It has the following fields:\n\nsize: The number of continuous variables T\norder: The order of the algorithm O\nsavedTimes: A vector of vectors of Float64 that holds the times at which the continuous variables were saved\nsavedVars: A vector of vectors of Float64 that holds the values of the continuous variables at the times they were saved\nalgName: The name of the algorithm used to solve the system\nsysName: The name of the system\nabsQ: The absolute tolerance used in the simulation\nstats: A Stats struct that holds the statistics of the simulation\nft: The final time of the simulation\n\n\n\n\n\n","category":"type"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"QuantizedSystemSolver.createSol(::Val{T},::Val{O}, savedTimes:: Vector{Vector{Float64}},savedVars :: Vector{Vector{Float64}},solver::String,nameof_F::String,absQ::Float64,stats::Stats,ft::Float64) where {T,O}","category":"page"},{"location":"developer/solution/#QuantizedSystemSolver.createSol-Union{Tuple{O}, Tuple{T}, Tuple{Val{T}, Val{O}, Vector{Vector{Float64}}, Vector{Vector{Float64}}, String, String, Float64, Stats, Float64}} where {T, O}","page":"Solution","title":"QuantizedSystemSolver.createSol","text":"createSol(::Val{T},::Val{O}, savedTimes:: Vector{Vector{Float64}},savedVars :: Vector{Vector{Float64}},solver::String,nameof_F::String,absQ::Float64,stats::Stats,ft::Float64) where {T,O}\n\nCreates a LightSol struct with the given parameters.\n\nArguments\n\n::Val{T}: The number of continuous variables.\n::Val{O}: The order of the algorithm.\nsavedTimes::Vector{Vector{Float64}}: A vector of vectors of times at which the continuous variables were saved.\nsavedVars::Vector{Vector{Float64}}: A vector of vectors of values of the continuous variables at the times they were saved.\nsolver::String: The name of the algorithm used to solve the system.\nnameof_F::String: The name of the system.\nabsQ::Float64: The absolute tolerance used in the simulation.\nstats::Stats: A Stats struct that holds the statistics of the simulation.\nft::Float64: The final time of the simulation.\n\nReturns\n\nA LightSol struct.\n\n\n\n\n\n","category":"method"},{"location":"developer/solution/#Further-reading","page":"Solution","title":"Further reading","text":"","category":"section"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"The solution Struct The LightSol struct is specifically designed to hold the solution of a system of ODEs. It contains several fields, including size and order, which denote the number of continuous variables and the order of the algorithm used, respectively. The savedTimes and savedVars fields are vectors that store the time steps and corresponding values of the continuous variables at which they were recorded during the simulation. Other fields include algName and sysName, which specify the names of the algorithm and system being solved, alongside absQ, the absolute tolerance used during the simulation. The stats field contains an instance of the Stats struct, providing access to the performance metrics, while ft holds the final time of the simulation. The Stats struct includes fields for totalSteps, which counts the total number of steps taken throughout the simulation, simulStepCount, representing the number of simultaneous updates during the simulation, and evCount, which tallies the number of events that occurred. Additionally, the numSteps vector keeps track of the number of steps taken for each continuous variable involved in the simulation, allowing for detailed analysis of the performance for individual components.","category":"page"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"The functions defined in conjunction with these structs enable various operations related to the simulation's solutions. The createSol function initializes a LightSol instance with the specified parameters, while the getindex function provides a helper to access either the saved times or variables easily. The evaluateSol function allows for the evaluation of the solution at a specified time, supporting linear interpolation between saved points. Furthermore, the solInterpolated functions enable the generation of interpolated solutions across specified intervals, creating new solution objects based on the interpolated values and times. The show function is tailored to present the statistics in a user-friendly format, offering insights into the performance of the simulation. Overall, these constructs provide a robust framework for managing and analyzing the outcomes of simulations involving ODEs.","category":"page"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"Plotting the Solution: The plotSol function is designed to visually represent the solution of a system of ODEs stored in the solution object. It accepts a variety of optional parameters, allowing users to customize their plots significantly. The function takes in a solution object sol along with indices for the variables to be plotted (xvars). Users can also specify a title, axis limits (xlims and ylims), and visual styles, such as marker types and whether to display a legend. If a title is not provided, it defaults to a composite of various parameters, including the system name, algorithm name, absolute tolerance, total steps taken, and more.Within the function, each selected variable is plotted against its corresponding saved time, utilizing different line styles for better distinction. If no specific variables are selected, all variables in the solution are plotted by default. After constructing the plot, the function checks for specified axis limits and applies them accordingly. Finally, the function returns the plot object, which can be further modified or saved. In addition to basic plotting, the saveSol function allows users to save their plots as PNG files, automatically generating filenames based on relevant parameters and timestamps. This functionality is crucial for documentation and sharing results in a reproducible manner. This comprehensive plotting capability ensures that users can effectively visualize the behavior of their systems, making the analysis of results intuitive and informative.","category":"page"},{"location":"developer/solution/","page":"Solution","title":"Solution","text":"Finding the Error: The getError function computes the relative error of a solution compared to a specified reference function, enabling users to assess the accuracy of their numerical results. The function iterates over the saved time points, and it calculates the sum of the squares of the differences between the numerical solution and the true values provided by the reference function, as well as the sum of the squares of the true values. The relative error is then derived as the square root of the ratio of these sums, providing a quantitative measure of the solution's deviation from the expected results. This comprehensive error analysis is essential for validating the performance of numerical methods and ensuring that the solutions produced are both reliable and precise. By comparing the numerical results to known reference values, users can gain insights into the accuracy and effectiveness of the solver, enabling them to make informed decisions about their simulations and analyses.","category":"page"},{"location":"developer/devIntro/#Developer-Guide","page":"Developer Guide","title":"Developer Guide","text":"","category":"section"},{"location":"developer/devIntro/#Contribution","page":"Developer Guide","title":"Contribution","text":"","category":"section"},{"location":"developer/devIntro/","page":"Developer Guide","title":"Developer Guide","text":"QuantizedSystemSolver is a collaborative project open to contributions. If you want to contribute, please take these steps into account:","category":"page"},{"location":"developer/devIntro/","page":"Developer Guide","title":"Developer Guide","text":"Carefully read and follow this guide. \nBefore opening a PR with a significant contribution, contact the project administrators, e.g., by writing an email to bellilimongi@gmail.com or by opening an issue describing what you are willing to implement. Wait for feed-back.\nOpen a PR with your contribution.","category":"page"},{"location":"developer/devIntro/","page":"Developer Guide","title":"Developer Guide","text":"If you want to help further develop this package, follow these steps:","category":"page"},{"location":"developer/devIntro/","page":"Developer Guide","title":"Developer Guide","text":"$ git clone https://github.com/mongibellili/QuantizedSystemSolver.jl.git /some/path/\njulia\n\njulia> ]\n\n(@v1.x) pkg> dev(\"/some/path/\")","category":"page"},{"location":"developer/devIntro/","page":"Developer Guide","title":"Developer Guide","text":"Want to help in other ways? You can start contributing to the project by solving some of the issues. ","category":"page"},{"location":"developer/devIntro/#Style-Guides","page":"Developer Guide","title":"Style Guides","text":"","category":"section"},{"location":"developer/devIntro/","page":"Developer Guide","title":"Developer Guide","text":"PascalCase for typenames\nAllCAPS for acronyms\nUse camelCase for variables, methods and file names, with underscores only when necessary\nFor the user API, adhere to the DifferentialEquation.jl interface\nUse lowercase for algorithm names.\nUse inline comments when necessary\nUse method! for muting methods\nWrap multiline expressions in parentheses to avoid errors","category":"page"},{"location":"developer/devIntro/","page":"Developer Guide","title":"Developer Guide","text":"See the Julia CONTRIBUTING.md for further information.","category":"page"},{"location":"developer/devIntro/#Components-overview","page":"Developer Guide","title":"Components overview","text":"","category":"section"},{"location":"developer/devIntro/","page":"Developer Guide","title":"Developer Guide","text":"While the package is optimized to be fast, extensibility is not compromised. It is divided into 3 entities that can be extended separately: Problem, Algorithm, and Solution. The package uses other packages such as MacroTools.jl for user-code parsing, SymEngine.jl for Jacobian computation, and a modified TaylorSeries.jl that uses caching to obtain free Taylor variables.  The other components of the solver include the NLodeProblem function, the solve function, the scheduler, and the quantizer. The following sections provide an in-depth explanation of the key components and their interactions within the solver framework.","category":"page"},{"location":"developer/devIntro/","page":"Developer Guide","title":"Developer Guide","text":"(Image: The QSS Solver Structure.)","category":"page"},{"location":"developer/devIntro/#Create-Problem-IR","page":"Developer Guide","title":"Create Problem IR","text":"","category":"section"},{"location":"developer/devIntro/","page":"Developer Guide","title":"Developer Guide","text":"(Image: The IR creation Structure.)","category":"page"},{"location":"developer/devIntro/#Create-Problem-structure","page":"Developer Guide","title":"Create Problem structure","text":"","category":"section"},{"location":"developer/devIntro/","page":"Developer Guide","title":"Developer Guide","text":"(Image: The problem creation Structure.)","category":"page"},{"location":"developer/devIntro/#Future-work","page":"Developer Guide","title":"Future work","text":"","category":"section"},{"location":"developer/devIntro/","page":"Developer Guide","title":"Developer Guide","text":"Improve the performance of constructing the problem using ODEProblem (similar to the performance when using @NLodeProblem).\nExtend the quantizer to handle order 3.\nCreate more functions to the Taylor object.","category":"page"},{"location":"developer/problem_references/#Problem-Internals","page":"Problem Internals","title":"Problem Internals","text":"","category":"section"},{"location":"developer/problem_references/#Problem-definition","page":"Problem Internals","title":"Problem definition","text":"","category":"section"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.ODEContProblem{F,PRTYPE,T,D,Z,CS}","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.ODEContProblem","page":"Problem Internals","title":"QuantizedSystemSolver.ODEContProblem","text":"ODEContProblem{F,PRTYPE,T,D,Z,CS}\n\nA struct that holds the continuous problem with tspan. It has the following fields:  \n\nprname: The name of the problem  \nprtype: The type of the problem  \na: The size of the problem   \nc: The number of discrete vars \nb: The number of zero crossing functions \ncacheSize: The size of the cache  \ninitConditions: The initial conditions of the problem  \ndiscreteVars # to match the differentialEqation.jl interface that wants the parameter p to be part of the problem\neqs: The function that holds all the ODEs  \njac: The Jacobian dependency  \nSD: The state derivative dependency  \nexactJac: The exact Jacobian function  \ntspan::Tuple{Float64, Float64}:  This field variable did not exist in the original ODEContProblem as this simulation time should part of the problem. However, to match the differentialEqation.jl interface, the tspan is added to the definition of the problem.\nclosureFuncs::Vector{F} # function that holds closure function inside system defined by user\n\n\n\n\n\n","category":"type"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.ODEDiscProblem{F,PRTYPE,T,D,Z,CS}","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.ODEDiscProblem","page":"Problem Internals","title":"QuantizedSystemSolver.ODEDiscProblem","text":"ODEDiscProblem{F,PRTYPE,T,D,Z,CS}\n\nA struct that holds the Problem of a system of ODEs with a set of events with tspan. It has the following fields:     -prname::Symbol   -prtype::Val{PRTYPE}    -a::Val{T}   -c::Val{D}   -b::Val{Z}    -cacheSize::Val{CS}   -initConditions::Vector{Float64}     -discreteVars::Vector{Float64}      -jac::Vector{Vector{Int}}#Jacobian dependency..I have a der and I want to know which vars affect it...opposite of SD     -ZCjac::Vector{Vector{Int}} # to update other Qs before checking ZCfunction     -eqs::Function#function that holds all ODEs     -eventDependencies::Vector{EventDependencyStruct}    -SD::Vector{Vector{Int}}#  I have a var and I want the der that are affected by it     -HZ::Vector{Vector{Int}}#  an ev occured and I want the ZC that are affected by it     -HD::Vector{Vector{Int}}#  an ev occured and I want the der that are affected by it     -SZ::Vector{Vector{Int}}#  I have a var and I want the ZC that are affected by it     -exactJac::Function#used only in the implicit integration: linear approximation     -tspan::Tuple{Float64, Float64}# This field variable did not exist in the original ODEDiscProblem as this simulation time should part of the problem. However, to match the differentialEqation.jl interface, the tspan is added to the definition of the problem.   -closureFuncs::Vector{F} # function that holds closure function inside system defined by user\n\n\n\n\n\n","category":"type"},{"location":"developer/problem_references/#Problem-construction","page":"Problem Internals","title":"Problem construction","text":"","category":"section"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"note: The examples of the continuous problem\nAll the examples that explain the problem construction functions use the following problem. The examples are reproducible as they are shown. To see the problem construction process in one step, add print() statements inside the functions of the package while solving this problem as shown in the tutorial section.du[1] = u[2]-2.0*u[1]*u[2]\nfor k in 2:9  \ndu[k]=u[k]*u[k-1];\nend \ndu[10]=u[1]-u[10]","category":"page"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.odeProblemFunc(ir::ODEFunctionIR,::Val{T},::Val{D},::Val{0},initCond::Vector{Float64},discrVars::Union{Vector{EM}, Tuple{Vararg{EM}}},preProcessData::PreProcessData,jac_mode ::Symbol) where {T,D,EM} \n","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.odeProblemFunc-Union{Tuple{EM}, Tuple{D}, Tuple{T}, Tuple{ODEFunctionIR, Val{T}, Val{D}, Val{0}, Vector{Float64}, Union{Vector{EM}, Tuple{Vararg{EM}}}, PreProcessData, Symbol}} where {T, D, EM}","page":"Problem Internals","title":"QuantizedSystemSolver.odeProblemFunc","text":"odeProblemFunc(ir::ODEFunctionIR,::Val{T},::Val{D},::Val{Z},initCond::Vector{Float64},discrVars::Union{Vector{EM}, Tuple{Vararg{EM}}},preProcessData::PreProcessData,jac_mode ::Symbol) where {T,D,Z,EM} \n\n    continues building a discrete problem. \nIt receives an expression and useful info from the main interface. It calls the transform function from the taylorEquationConstruction.jl file to change the AST of all operations to personlized ones and update the needed cache size. It also construct via helper functions the Exact jacobian function, the jacobian dependecy (jac) and the state-derivative dependency (SD:opposite of jacobian), the state to zero-crossing dependency (SZ) and events to derivative and zero-crossing (HD and HZ) as vectors. Finally, it groups all differential equations and events in one function, and constructs a discrete problem from the qssProblemDefinition.jl file.\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.odeProblemFunc(ir::ODEFunctionIR,::Val{T},::Val{D},::Val{Z},initCond::Vector{Float64},discrVars::Union{Vector{EM}, Tuple{Vararg{EM}}},preProcessData::PreProcessData,jac_mode ::Symbol) where {T,D,Z,EM}","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.odeProblemFunc-Union{Tuple{EM}, Tuple{Z}, Tuple{D}, Tuple{T}, Tuple{ODEFunctionIR, Val{T}, Val{D}, Val{Z}, Vector{Float64}, Union{Vector{EM}, Tuple{Vararg{EM}}}, PreProcessData, Symbol}} where {T, D, Z, EM}","page":"Problem Internals","title":"QuantizedSystemSolver.odeProblemFunc","text":"odeProblemFunc(ir::ODEFunctionIR,::Val{T},::Val{D},::Val{Z},initCond::Vector{Float64},discrVars::Union{Vector{EM}, Tuple{Vararg{EM}}},preProcessData::PreProcessData,jac_mode ::Symbol) where {T,D,Z,EM} \n\n    continues building a discrete problem. \nIt receives an expression and useful info from the main interface. It calls the transform function from the taylorEquationConstruction.jl file to change the AST of all operations to personlized ones and update the needed cache size. It also construct via helper functions the Exact jacobian function, the jacobian dependecy (jac) and the state-derivative dependency (SD:opposite of jacobian), the state to zero-crossing dependency (SZ) and events to derivative and zero-crossing (HD and HZ) as vectors. Finally, it groups all differential equations and events in one function, and constructs a discrete problem from the qssProblemDefinition.jl file.\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/#Problem-construction-helpers","page":"Problem Internals","title":"Problem construction helpers","text":"","category":"section"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.changeExprToFirstValue(ex::Expr) ","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.changeExprToFirstValue-Tuple{Expr}","page":"Problem Internals","title":"QuantizedSystemSolver.changeExprToFirstValue","text":"changeExprToFirstValue(ex::Expr)\n\nchanges an expression in the form u[1] to an expression in the form u[1][0] inside exact jacobian expressions and inside events, because linear coefficients (a_{ii}) do not have derivatives, and updates in events affect the value of a variable directly and there is no need to update its higher derivatives. It is called by the restoreRef function for jacobian expressions, and called by the handleEvents function for events.\n\nExample:\n\nusing QuantizedSystemSolver \nex=:(q[i - 1]) \nnewEx=QuantizedSystemSolver.changeExprToFirstValue(ex)\n\n# output\n\n:((q[i - 1])[0])\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.symbolFromRef(el::Symbol,refEx::Union{Int64,Expr,Symbol}) ","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.symbolFromRef-Tuple{Symbol, Union{Int64, Expr, Symbol}}","page":"Problem Internals","title":"QuantizedSystemSolver.symbolFromRef","text":"symbolFromRef(el::Symbol,refEx::Union{Int64,Expr,Symbol})\n\ngets a symbol qi, qiplusNumber, qiminusNumber, or qitimesNumber from a symbol i or expressions like i+Number, i+Number, i+Number.  It is called by the changeVarNames_params, the extractJacDepNormal and the extractJacDepLoop functions\n\nExample:\n\nusing QuantizedSystemSolver\nex=:(i - 1) \nnewEx=QuantizedSystemSolver.symbolFromRef(:q,ex)\n(ex,newEx)\n\n# output\n\n(:(i - 1), :qiminus1)\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.restoreRef(coefExpr,symDict)","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.restoreRef-Tuple{Any, Any}","page":"Problem Internals","title":"QuantizedSystemSolver.restoreRef","text":"restoreRef(coefExpr,symDict)\n\nThis function is the opposite of symbolFromRef. After using the symbols in symbolic differentiation, it gets back expressions like p[i+Number] and q[i+Number][0] from symbols diplusNumber and qiplusNumber. Adding a zero to q variables is beacause q is a taylor variable while p is a vector.\n\narguments:\n\ncoefExpr::Expr: the expression to be changed\nsymDict::Dict{Symbol,Expr}: the dictionary to store the translation of symbols of continous and discrete variables (q[i] <-> qi)\n\nExample:\n\nusing QuantizedSystemSolver\n\nsymDict= Dict{Symbol, Expr}(:qi => :(q[i]), :q10 => :(q[10]), :q2 => :(q[2]), :qiminus1 => :(q[i - 1]), :q1 => :(q[1]))\ncoefExpr=:(1.5qiminus1) \n  newEx=QuantizedSystemSolver.restoreRef(coefExpr, symDict)\n\n\n# output\n\n:(1.5 * (q[i - 1])[0]) \n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.handleEvents(argI::Expr,eventequs::Vector{Expr},length_zcequs::Int64,evsArr::Vector{EventDependencyStruct})","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.handleEvents-Tuple{Expr, Vector{Expr}, Int64, Vector{EventDependencyStruct}}","page":"Problem Internals","title":"QuantizedSystemSolver.handleEvents","text":"handleEvents(argI::Expr,eventequs::Vector{Expr},length_zcequs::Int64,evsArr::Vector{EventDependencyStruct})\n\nHandles events in the quantized system solver.\n\nArguments\n\nargI::Expr: An expression representing the 'if-statement'.\neventequs::Vector{Expr}: A vector of expressions representing the event equations.\nlength_zcequs::Int64: current number of treated zero-crossing equations. Usezd as index to store the events in order.\nevsArr: An array containing EventDependencyStruct  objects.\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.transformFSimplecase(ex::Union{Float64,Int64,Expr,Symbol})","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.transformFSimplecase-Tuple{Union{Float64, Int64, Expr, Symbol}}","page":"Problem Internals","title":"QuantizedSystemSolver.transformFSimplecase","text":"transformFSimplecase(ex::Union{Float64,Int64,Expr,Symbol})\n\ntransforms expressions of the right hand side of differential equations and zero-crossing functions to personalized ones that use caching to a form that can be used in the createT function. The right hand side of the equations should be a number or a q[i] term.\n\nExample:\n\nusing QuantizedSystemSolver\nex=:(q[2])\nnewEx=QuantizedSystemSolver.transformFSimplecase(ex);\n\n\n# output\n\n:(createT(q[2], cache[1])) \n\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.transformF(ex::Expr)","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.transformF-Tuple{Expr}","page":"Problem Internals","title":"QuantizedSystemSolver.transformF","text":"transformF(ex::Expr)\n\ntransforms expressions of the right hand side of differential equations and zero-crossing functions to personalized ones that use caching to a form that can be used in functions like  addT, subT, mulT, muladdT. The right hand side of the equations can be any form of expression.\n\nExample:\n\nusing QuantizedSystemSolver\nex=:(q[2] - 2.0*q[1]*q[2],1)\nnewEx=QuantizedSystemSolver.transformF(ex);\n\n\n# output\n\n:((subT(q[2], mulTT(2.0, q[1], q[2], cache[2], cache[3]), cache[1]), 3))\n\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.createJacVect(jac:: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},::Val{T}) where {T}","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.createJacVect-Union{Tuple{T}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{T}}} where T","page":"Problem Internals","title":"QuantizedSystemSolver.createJacVect","text":"createJacVect(jac:: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},::Val{T}) where {T}\n\nconstructs the jacobian dependency as a vector from the existing dictionary jac resulted from extractJacDepNormal and extractJacDepLoop functions. \n\nThis function just collects the data from the value of the dictionary if the key of the dictionary is an integer. (a dictionary contains(key=>value),...). In the case it is an expression :(b,niter), the function uses a 'for' loop to replace each 'b' by its corresponding integer. This approach depends on the size of the problem, but it runs one time.\n\nExample:\n\nusing QuantizedSystemSolver\njac=Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(1 => Set([2, 1]),:((2, 9)) => Set([:(i - 1), :i]),10 => Set([1, 10]))\njacVect=QuantizedSystemSolver.createJacVect(jac,Val(10) )\nstring(jacVect)\n\n# output\n\n\"[[2, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [10, 1]]\"\n\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.createSDVect(jac:: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},::Val{T}) where {T}","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.createSDVect-Union{Tuple{T}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{T}}} where T","page":"Problem Internals","title":"QuantizedSystemSolver.createSDVect","text":"createSDVect(jac:: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},::Val{T}) where {T}\n\nconstructs the State to derivative dependency (opposite of jacobian dependency) as a vector from the existing dictionary jac resulted from the extractJacDepNormal and the extractJacDepLoop functions. It is the opposite in the sense that here we collect the keys into some vectors whereas in the jacobian dependency we collect the values of the dictionary in some vectors. \n\nIf the key of the dictionary is an integer, then for all elements 'k' in the value of the dictionary (a set), the key is pushed into a new vector indexed at 'k'. In the case the key is an expression :(b,niter), the function uses a 'for' loop to replace each 'b' by its corresponding integer. This approach depends on the size of the problem, but it runs one time.\n\nExample:\n\nusing QuantizedSystemSolver\njac=Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(1 => Set([2, 1]),:((2, 9)) => Set([:(i - 1), :i]),10 => Set([1, 10]));\nSD=QuantizedSystemSolver.createSDVect(jac,Val(10) );\nstring(SD)\n\n# output\n\n\"[[10, 2, 1], [2, 3, 1], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9], [10]]\"\n\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.createExactJacFun(otherCode::Expr,Exactjac:: Dict{Expr,Union{Float64,Int,Symbol,Expr}},funName::Symbol,f)","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.createExactJacFun-Tuple{Expr, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Any}","page":"Problem Internals","title":"QuantizedSystemSolver.createExactJacFun","text":"createExactJacFun(otherCode::Expr,Exactjac:: Dict{Expr,Union{Float64,Int,Symbol,Expr}},funName::Symbol,f)\n\nconstructs the exact jacobian entries as a function from the existing dictionary Exactjac resulted from extractJacDepNormal and extractJacDepLoop functions. \n\nFrom the input dictionary exactJac, we see that the key is always a expression that hold a tuple of size 2: the first element is going to be the index 'i' and the second element if the index 'j'. The value corresponding to this key, which is the exact jacobian entry, is put in a cache. i.e the function maps the keys of the dictionary to their values using an 'if-statement.. This approach does not depend on the size of the problem.     # Example:   \n\nusing QuantizedSystemSolver\nexacteJacExpr=Dict{Expr,Union{Float64,Int,Symbol,Expr}}(:((1, 1)) => :(-2.0 * (q[2])[0]), :((1, 2)) => :(1 - 2.0 * (q[1])[0]),:(((2, 9), i - 1)) => :((q[i])[0]), :(((2, 9), i)) => :((q[i - 1])[0]),:((10, 10)) => -1, :((10, 1)) => 1);\nexactJac=QuantizedSystemSolver.createExactJacFun(:(),exacteJacExpr,:f,0);\nexactJac\n\n# output\n\n:(function exactJacf(q::Vector{Taylor0}, p::Vector{Float64}, cache::AbstractVector{Float64}, i::Int, j::Int, t::Float64, f_)\n      (if i == 0\n              return nothing\n          elseif i == 1 && j == 1\n              cache[1] = -2.0 * (q[2])[0]\n              return nothing\n          elseif i == 10 && j == 10\n              cache[1] = -1\n              return nothing\n          elseif 2 <= i <= 9 && j == i - 1\n              cache[1] = (q[i])[0]\n              return nothing\n          elseif i == 1 && j == 2\n              cache[1] = 1 - 2.0 * (q[1])[0]\n              return nothing\n          elseif 2 <= i <= 9 && j == i\n              cache[1] = (q[i - 1])[0]\n              return nothing\n          elseif i == 10 && j == 1\n              cache[1] = 1\n              return nothing\n          end,)\n  end)\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.createContEqFun(otherCode::Expr,equs::Dict{Union{Int,Expr},Union{Int,Symbol,Expr}},fname::Symbol,f)","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.createContEqFun-Tuple{Expr, Dict{Union{Int64, Expr}, Union{Int64, Expr, Symbol}}, Symbol, Any}","page":"Problem Internals","title":"QuantizedSystemSolver.createContEqFun","text":"createContEqFun(otherCode::Expr,equs::Dict{Union{Int,Expr},Union{Int,Symbol,Expr}},fname::Symbol,f)\n\nconstructs one function from all differential equations in the problem, which are transformed and stored in a dictionary in the NLodeProblemFunc function.\n\nThe function maps the keys of the dictionary to their values using an 'if-statement.     # Example:   \n\nusing QuantizedSystemSolver\nequs = Dict{Union{Int,Expr},Union{Int,Symbol,Expr}}(10 => :(subT(q[1], q[10], cache[1])), :((2, 9)) => :(mulT(q[i], q[i - 1], cache[1])), 1 => :(subT(q[2], mulTT(2.0, q[1], q[2], cache[2], cache[3]), cache[1])));\ndiffEqfun=QuantizedSystemSolver.createContEqFun(:(),equs,:f,0); \ndiffEqfun \n\n# output\n\n:(function f(i::Int, q::Vector{Taylor0}, p::Vector{Float64}, t::Taylor0, cache::Vector{Taylor0}, f_)    \n      (if i == 0\n              return nothing\n          elseif i == 10\n              subT(q[1], q[10], cache[1])\n              return nothing\n          elseif 2 <= i <= 9\n              mulT(q[i], q[i - 1], cache[1])\n              return nothing\n          elseif i == 1\n              subT(q[2], mulTT(2.0, q[1], q[2], cache[2], cache[3]), cache[1])\n              return nothing\n          end,)\n  end)\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.extractJacDepNormal(varNum::Int,rhs::Expr,jac :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},exactJacExpr :: Dict{Expr,Union{Float64,Int,Symbol,Expr}},jac_mode ::Symbol,symDict::Dict{Symbol,Expr},dD :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}}) ","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}","page":"Problem Internals","title":"QuantizedSystemSolver.extractJacDepNormal","text":"extractJacDepNormal(varNum::Int,rhs::Expr,jac :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},exactJacExpr :: Dict{Expr,Union{Float64,Int,Symbol,Expr}},jac_mode ::Symbol,symDict::Dict{Symbol,Expr},dD :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}})\n\nExtracts the jacobian dependency (jac) as well as the exacte symbolic jacobian expression (exactJacExpr) and the dependency of state derivatives to discrete variables (dD), in the form of dictionaries, from the simple differential equations.\n\nFor the continuous part, similar to extractJacDepNormal  function, this function sarts by looking for the 'i' in q[i] in the RHS and storing this 'i' in a jacSet for the varNum. Then, it changes q[i] to qi for symbolic differentiation. After finding fracpartial f_ipartial q_i as the exact jacobian entry, it changes back qi to q[i]. Also, any mute variable from the differential equations is changed to 'i'.\n\nFor the discrete part, the function puts the index of the differential equation in a set, and stores this set in a dictionary dD with the key being the index of the discrete variable.\n\nExample:\n\nusing QuantizedSystemSolver\n(varNum, rhs, jac, exactJacExpr, symDict, dD) = (1, :(p[2] - 2.0 * q[1] * p[2]), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(), Dict{Symbol, Expr}(:q10 => :(q[10]), :p2 => :(p[2]), :qiminus1 => :(q[i - 1]), :p1 => :(p[1]), :q1 => :(q[1])), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}())\nQuantizedSystemSolver.extractJacDepNormal(varNum, rhs, jac, exactJacExpr,:symbolic, symDict, dD )\n(jac, exactJacExpr, dD) \n\n# output\n\n(Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(1 => Set([1])), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(:((1, 1)) => :(-2.0 * p[2])), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(2 => Set([1])))\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.extractJacDepLoop(b::Int,niter::Int,rhs::Expr,jac :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},exactJacExpr :: Dict{Expr,Union{Float64,Int,Symbol,Expr}},jac_mode ::Symbol,symDict::Dict{Symbol,Expr},dD :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}}) ","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Expr, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}","page":"Problem Internals","title":"QuantizedSystemSolver.extractJacDepLoop","text":"extractJacDepLoop(b::Int,niter::Int,rhs::Expr,jac :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},exactJacExpr :: Dict{Expr,Union{Float64,Int,Symbol,Expr}},jac_mode ::Symbol,symDict::Dict{Symbol,Expr},dD :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}})\n\nThis function is similar to the extractJacDepNormal  function by using the tuple (b,niter) instead of the integer varNum. Itextracts the jacobian dependency (jac) as well as the exacte symbolic jacobian expression (exactJacExpr) and the dependency of state derivatives to discrete variables (dD), in the form of dictionaries, from the differential equations that are written in a loop.\n\nFor the continuous part, it sarts by looking for the 'i' in q[i] in the RHS and storing this 'i' in a jacSet. Then, it changes q[i] to qi for symbolic differentiation. After finding fracpartial f_ipartial q_i as the exact jacobian entry, it changes back qi to q[i]. Also, any mute variable from the differential equations is changed to 'i'.\n\nFor the discrete part, the function puts the the tuple (b,niter) in a set, and stores this set in a dictionary dD with the key being the index of the discrete variable.     # Example:\n\nusing QuantizedSystemSolver\n(b, niter, rhs, jac, exactJacExpr, symDict, dD) = (2, 9, :(p[1] * q[i - 1] * 1.5), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(1 => Set([1])), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(:((1, 1)) => :(-2.0 * p[2])), Dict{Symbol, Expr}(:q10 => :(q[10]), :p2 => :(p[2]), :qiminus1 => :(q[i - 1]), :p1 => :(p[1]), :q1 => :(q[1])), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(2 => Set([1])))\nQuantizedSystemSolver.extractJacDepLoop(b, niter, rhs, jac, exactJacExpr,:symbolic, symDict, dD )\n(jac, exactJacExpr, dD) \n\n# output\n\n(Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(:((2, 9)) => Set([:(i - 1)]), 1 => Set([1])), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(:((1, 1)) => :(-2.0 * p[2]), :(((2, 9), i - 1)) => :(1.5 * p[1])), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(2 => Set([1]), 1 => Set([:((2, 9))])))\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.extractZCJacDep(counter::Int,zcf::Expr,zcjac :: Vector{Vector{Int}},SZ ::Dict{Int,Set{Int}},dZ :: Dict{Int,Set{Int}})","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.extractZCJacDep-Tuple{Int64, Expr, Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Dict{Int64, Set{Int64}}}","page":"Problem Internals","title":"QuantizedSystemSolver.extractZCJacDep","text":"extractZCJacDep(counter::Int,zcf::Expr,zcjac :: Vector{Vector{Int}},SZ ::Dict{Int,Set{Int}},dZ :: Dict{Int,Set{Int}})\n\nExtracts the zero-crossing jacobian dependency as a vector (zcjac), the dependency of the zero-crossing functions to continuous (SZ) and discrete variables (dZ) in the form of dictionaries, from the 'if-statements' (zcf).\n\nThe zcjac is a vector of vectors, where each vector contains the indices of the continuous variables that the zero-crossing function depends on. The SZ dictionary contains the indices of the zero-crossing functions as values and the indices of the continuous variables as keys. Similarly, the dZ dictionary contains the indices of the zero-crossing functions as values and the indices of the discrete variables as keys.\n\nExample:\n\nusing QuantizedSystemSolver\n(counter, zcf, zcjac, SZ, dZ) = (2, :(q[2] - p[1]), [[1]], Dict{Int64, Set{Int64}}(1 => Set([1])), Dict{Int64, Set{Int64}}())\nQuantizedSystemSolver.extractZCJacDep(counter, zcf, zcjac, SZ, dZ)\n(zcjac, SZ, dZ) \n\n# output\n\n([[1], [2]], Dict{Int64, Set{Int64}}(2 => Set([2]), 1 => Set([1])), Dict{Int64, Set{Int64}}(1 => Set([2])))\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.EventDependencyStruct","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.EventDependencyStruct","page":"Problem Internals","title":"QuantizedSystemSolver.EventDependencyStruct","text":"EventDependencyStruct\n\nA struct that holds the event dependency information. It has the following fields:\n\nid::Int: the id of the event\nevCont::Vector{Int}: the index tracking used for HD & HZ. Also it is used to update q,quantum,recomputeNext when x is modified in an event\nevDisc::Vector{Int}: the index tracking used for HD & HZ.\nevContRHS::Vector{Int}: the index tracking used to update other Qs before executing the event\n\n\n\n\n\n","category":"type"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.createSZVect(SZ :: Dict{Int64, Set{Int64}},::Val{T}) where {T} ","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.createSZVect-Union{Tuple{T}, Tuple{Dict{Int64, Set{Int64}}, Val{T}}} where T","page":"Problem Internals","title":"QuantizedSystemSolver.createSZVect","text":"createSZVect(SZ :: Dict{Int64, Set{Int64}},::Val{T}) where {T}\n\nconstructs the zero-crossing dependency to state variables as a vector from the existing dictionary SZ resulted from the extractZCJacDep function. The continuous variables are the keys and the zero-crossing are the values.\n\nExample:\n\nusing QuantizedSystemSolver\n(SZ, T) = (Dict{Int64, Set{Int64}}(2 => Set([2]), 1 => Set([1])), 10)\nszVec=QuantizedSystemSolver.createSZVect(SZ, Val(T))\nstring(szVec)\n\n# output\n\n\"[[1], [2], Int64[], Int64[], Int64[], Int64[], Int64[], Int64[], Int64[], Int64[]]\"\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.createdDVect(dD::Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}},::Val{D}) where {D}","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.createdDVect-Union{Tuple{D}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{D}}} where D","page":"Problem Internals","title":"QuantizedSystemSolver.createdDVect","text":"createdDVect(dD::Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}},::Val{D}) where {D}\n\nconstructs the State to derivative dependency to discrete variables as a vector from the existing dictionary dD resulted from the extractJacDepNormal and the extractJacDepLoop functions. The discrete variables are the keys and the differential equations are the values. This dependency is needed only in createDependencyToEventsDiscr  .\n\nExample:\n\nusing QuantizedSystemSolver\n(dD, D) = (Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(2 => Set([10, 1]), 1 => Set([:((2, 9))])), 2)\ndDVect=QuantizedSystemSolver.createdDVect(dD, Val(D) )\nstring(dDVect)\n\n# output\n\n\"[[2, 3, 4, 5, 6, 7, 8, 9], [10, 1]]\"\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.createDependencyToEventsDiscr(dD::Vector{Vector{Int}},dZ::Dict{Int64, Set{Int64}},eventDep::Vector{EventDependencyStruct}) ","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.createDependencyToEventsDiscr-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}","page":"Problem Internals","title":"QuantizedSystemSolver.createDependencyToEventsDiscr","text":"createDependencyToEventsDiscr(dD::Vector{Vector{Int}},dZ::Dict{Int64, Set{Int64}},eventDep::Vector{EventDependencyStruct})\n\nconstructs the dependency of zero-crossing functions and state derivatives to events using only discrete variables.\n\narguments\n\ndD::Vector{Vector{Int}}: the dependency of state derivatives to discrete variables as a vector\ndZ::Dict{Int64, Set{Int64}}: the dependency of zero-crossing functions to discrete variables as a dictionary\neventDep::Vector{EventDependencyStruct}: the event dependency information as a vector of structs\n\nreturns\n\nHZ1::Vector{Vector{Int}}: the dependency of zero-crossing functions to events using only discrete variables\nHD1::Vector{Vector{Int}}: the dependency of differential equations to events using only discrete variables\nExample:\n\nusing QuantizedSystemSolver\n(dD, dZ, eventDep) = ([[2, 3, 4, 5, 6, 7, 8, 9], [10, 1]], Dict{Int64, Set{Int64}}(1 => Set([2])), QuantizedSystemSolver.EventDependencyStruct[QuantizedSystemSolver.EventDependencyStruct(1, Int64[], [1], Int64[]), QuantizedSystemSolver.EventDependencyStruct(2, Int64[], Int64[], Int64[]), QuantizedSystemSolver.EventDependencyStruct(3, [3], [2], [3, 1, 2]), QuantizedSystemSolver.EventDependencyStruct(4, Int64[], Int64[], Int64[])])\n(HZ1, HD1) =QuantizedSystemSolver.createDependencyToEventsDiscr(dD, dZ, eventDep )\n(HZ1, HD1) \n\n# output\n\n([[2], Int64[], Int64[], Int64[]], [[5, 4, 6, 7, 2, 9, 8, 3], Int64[], [10, 1], Int64[]])\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.createDependencyToEventsCont(SD::Vector{Vector{Int}},sZ::Dict{Int64, Set{Int64}},eventDep::Vector{EventDependencyStruct}) ","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.createDependencyToEventsCont-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}","page":"Problem Internals","title":"QuantizedSystemSolver.createDependencyToEventsCont","text":"createDependencyToEventsCont(SD::Vector{Vector{Int}},sZ::Dict{Int64, Set{Int64}},eventDep::Vector{EventDependencyStruct})\n\nconstructs the dependency of zero-crossing functions and state derivatives to events using only continuous variables.\n\narguments\n\nSD::Vector{Vector{Int}}: the dependency of state derivatives to continuous variables as a vector\nsZ::Dict{Int64, Set{Int64}}: the dependency of zero-crossing functions to continuous variables as a dictionary\neventDep::Vector{EventDependencyStruct}: the event dependency information as a vector of structs\n\nreturns\n\nHZ2::Vector{Vector{Int}}: the dependency of zero-crossing functions to events using only continuous variables\nHD2::Vector{Vector{Int}}: the dependency of differential equations to events using only continuous variables\nExample:\n\nusing QuantizedSystemSolver\n(SD, sZ, eventDep) = ([[10, 2, 1], [3], [4], [5], [6], [7], [8], [9], Int64[], [10]], Dict{Int64, Set{Int64}}(2 => Set([2]), 1 => Set([1])), QuantizedSystemSolver.EventDependencyStruct[QuantizedSystemSolver.EventDependencyStruct(1, Int64[], [1], Int64[]), QuantizedSystemSolver.EventDependencyStruct(2, Int64[], Int64[], Int64[]), QuantizedSystemSolver.EventDependencyStruct(3, [3], [2], [3, 1, 2]), QuantizedSystemSolver.EventDependencyStruct(4, Int64[], Int64[], Int64[])])\n(HZ2, HD2) =QuantizedSystemSolver.createDependencyToEventsCont(SD, sZ, eventDep)\n(HZ2, HD2) \n\n# output\n\n([Int64[], Int64[], Int64[], Int64[]], [Int64[], Int64[], [4], Int64[]])\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"QuantizedSystemSolver.unionDependency(HZD1::Vector{Vector{Int}},HZD2::Vector{Vector{Int}})","category":"page"},{"location":"developer/problem_references/#QuantizedSystemSolver.unionDependency-Tuple{Vector{Vector{Int64}}, Vector{Vector{Int64}}}","page":"Problem Internals","title":"QuantizedSystemSolver.unionDependency","text":"unionDependency(HZD1::Vector{Vector{Int}},HZD2::Vector{Vector{Int}})\n\nmerges the state derivatives and zero-crossing functions dependencies to events using both continuous and discrete variables.\n\nExample:\n\nusing QuantizedSystemSolver\n(HD1, HD2) = ([[5, 4, 6, 7, 2, 9, 8, 3], Int64[], [10, 1], Int64[]], [Int64[], Int64[], [4], Int64[]])\nHD=QuantizedSystemSolver.unionDependency(HD1, HD2)\nstring(HD)\n\n# output\n\n\"[[5, 4, 6, 7, 2, 9, 8, 3], Int64[], [4, 10, 1], Int64[]]\"\n\n\n\n\n\n","category":"method"},{"location":"developer/problem_references/#Index","page":"Problem Internals","title":"Index","text":"","category":"section"},{"location":"developer/problem_references/","page":"Problem Internals","title":"Problem Internals","text":"Pages = [\"problem.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"developer/taylor/#Taylor-Variables","page":"Taylor Variables","title":"Taylor Variables","text":"","category":"section"},{"location":"developer/taylor/#Purpose","page":"Taylor Variables","title":"Purpose","text":"","category":"section"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"QSS methods rely heavily on root finding and derivative computation. The approximation through Taylor variables transforms any complicated equations to polynomials, which makes root finding cheaper. In addition, the use of Taylor variables provide easily the different derivatives for complex expressions. The implementation includes various constructors and methods to manipulate and evaluate the Taylor series.","category":"page"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"In the quantized system solver, and similar to the Taylor struct from the package TaylorSeries.jl, the Taylor0 struct serves as a convenient representation of Taylor series approximations while avoiding memory allocation. ","category":"page"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"New functions are created to match each old function but with a different name and added caches in the parameters. These new functions are designed to optimize performance by avoiding memory allocation during their execution where arithmetic operations and mathematical functions leverage the existing cached data rather than creating new instances of taylor variables. In addition, the old Taylor is kept, with minimum functionalities, as a fallback in case there is an expression that does not use the available cache vector. ","category":"page"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"Arithmetic operations: The provided code introduces personalized arithmetic operations such as addsub, subsub, and mulT that are designed to operate directly on existing data structures, utilizing a caching mechanism to store intermediate results.","category":"page"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"Mathematical functions: Similar to arithmetic operations, new mathematical functions are designed to leverage in-place operations. Functions like exp, log, sin, and cos, sqrt, power iterate over the input Taylor series and apply the corresponding operation without allocating additional arrays.","category":"page"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"Transformation of expressions: The transformF function is designed to translate userdefined mathematical expressions into optimized forms that leverage the custom arithmetic and function implementations. By traversing the expression tree with the prewalk function, it identifies operations such as addition, subtraction, multiplication, division, and specific mathematical functions (like exponential and logarithmic functions). For each identified operation, the code modifies the expression to call specialized versions (e.g., subT, addT, mulT). Additionally, it tracks the number of caches needed for these operations.","category":"page"},{"location":"developer/taylor/#Example:","page":"Taylor Variables","title":"Example:","text":"","category":"section"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"function (+)(a::Taylor0, b::Taylor0)\n    v = similar(a.coeffs)\n    @__dot__ v = (+)(a.coeffs, b.coeffs)\n    return Taylor0(v, a.order)\nend\n\nfunction addT(a::Taylor0, b::Taylor0, cache::Taylor0)\n  @__dot__ cache.coeffs = (+)(a.coeffs, b.coeffs)\n  return cache\nend","category":"page"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"The first function (+) from the TaylorSeries.jl creates a new Taylor variable every time, while the customized arithmetic operation addT uses an existing cache.","category":"page"},{"location":"developer/taylor/#Taylor-references","page":"Taylor Variables","title":"Taylor references","text":"","category":"section"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"Taylor0 is defined for many functions. However, other functions can also be added.","category":"page"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"Taylor0","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.Taylor0","page":"Taylor Variables","title":"QuantizedSystemSolver.Taylor0","text":"Taylor0\n\ndefines a Taylor Variable. It has the following fields:\n\ncoeffs: An array of Float64 that holds the coefficients of the Taylor series\norder: The order of the Taylor series\n\n\n\n\n\n","category":"type"},{"location":"developer/taylor/#non-allocation-operations","page":"Taylor Variables","title":"non-allocation operations","text":"","category":"section"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"createT(a::Taylor0, cache::Taylor0)","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.createT-Tuple{Taylor0, Taylor0}","page":"Taylor Variables","title":"QuantizedSystemSolver.createT","text":"createT(a::Taylor0, cache::Taylor0)\n\nputs the coefficients of a into cache and returns cache.\n\nusing QuantizedSystemSolver\na = Taylor0([1.0, 1.0])\ncache = Taylor0([0.0, 0.0])\ncreateT(a, cache)\ncache[0]\n\n# output\n\n1.0\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"createT(a::T, cache::Taylor0) where {T<:Number}","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.createT-Union{Tuple{T}, Tuple{T, Taylor0}} where T<:Number","page":"Taylor Variables","title":"QuantizedSystemSolver.createT","text":"createT(a::T,cache::Taylor0) where {T<:Number}\n\ncreates a Taylor0 from a constant. In case of order 2, cache=[a,0,0]\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"addT(a::Taylor0, b::Taylor0, cache::Taylor0)","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.addT-Tuple{Taylor0, Taylor0, Taylor0}","page":"Taylor Variables","title":"QuantizedSystemSolver.addT","text":"addT(a::Taylor0, b::Taylor0,cache::Taylor0)\n\ncache=a+b\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"subT(a::Taylor0, b::Taylor0, cache::Taylor0)","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.subT-Tuple{Taylor0, Taylor0, Taylor0}","page":"Taylor Variables","title":"QuantizedSystemSolver.subT","text":"subT(a::Taylor0, b::Taylor0,cache::Taylor0)\n\ncache=a-b\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"mulT(a::Taylor0, b::Taylor0, cache1::Taylor0)","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.mulT-Tuple{Taylor0, Taylor0, Taylor0}","page":"Taylor Variables","title":"QuantizedSystemSolver.mulT","text":"mulT(a::Taylor0, b::Taylor0,cache1::Taylor0)\n\ncache1=a*b\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"divT(a::Taylor0, b::Taylor0, cache1::Taylor0)","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.divT-Tuple{Taylor0, Taylor0, Taylor0}","page":"Taylor Variables","title":"QuantizedSystemSolver.divT","text":"divT(a::Taylor0, b::Taylor0,cache1::Taylor0)\n\ncache1=a/b\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"addsub(a::Taylor0, b::Taylor0, c::Taylor0, cache::Taylor0)","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.addsub-NTuple{4, Taylor0}","page":"Taylor Variables","title":"QuantizedSystemSolver.addsub","text":"addsub(a::Taylor0, b::Taylor0,c::Taylor0,cache::Taylor0)\n\ncache=a+b-c\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"addsub(a::Taylor0, b::Taylor0, c::T, cache::Taylor0) where {T<:Number}","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.addsub-Union{Tuple{T}, Tuple{Taylor0, Taylor0, T, Taylor0}} where T<:Number","page":"Taylor Variables","title":"QuantizedSystemSolver.addsub","text":"addsub(a::Taylor0, b::Taylor0, c::T, cache::Taylor0) where {T<:Number}\n\nPerforms an addition and subtraction operation on Taylor series objects.\n\nArguments\n\na::Taylor0: The first Taylor series object.\nb::Taylor0: The second Taylor series object.\nc::T: A scalar value to be subtracted from the constant term of b.\ncache::Taylor0: A Taylor series object used as a cache to store the result.\n\nReturns\n\ncache::Taylor0: The result of the operation, stored in the cache object.\n\nDescription\n\nThis function performs the following operations:\n\nCopies the coefficients of b into cache.\nSubtracts the scalar c from the constant term of cache.\nAdds the coefficients of a to cache.\n\nThe result is stored in the cache object and returned.\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"addsub(a::T, b::Taylor0, c::Taylor0, cache::Taylor0) where {T<:Number}","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.addsub-Union{Tuple{T}, Tuple{T, Taylor0, Taylor0, Taylor0}} where T<:Number","page":"Taylor Variables","title":"QuantizedSystemSolver.addsub","text":"addsub(a::T, b::Taylor0,c::Taylor0,cache::Taylor0) where {T<:Number}\n\nExample:\n\nOrder2 case: cache=[a+b[0]-c[0],b[1]-c[1],b[2]-c[2]]\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"subsub(a::Taylor0, b::Taylor0,c::Taylor0,cache::Taylor0) ","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.subsub-NTuple{4, Taylor0}","page":"Taylor Variables","title":"QuantizedSystemSolver.subsub","text":"subsub(a::Taylor0, b::Taylor0,c::Taylor0,cache::Taylor0)\n\ncache=a-b-c\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"mulsub(a::P,b::Q,c::R,cache1::Taylor0) where {P,Q,R <:Union{Taylor0,Number}}","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.mulsub-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{P, Q, R, Taylor0}} where {P, Q, R<:Union{Number, Taylor0}}","page":"Taylor Variables","title":"QuantizedSystemSolver.mulsub","text":"mulsub(a::P,b::Q,c::R,cache1::Taylor0) where {P,Q,R <:Union{Taylor0,Number}}\n\ncache1=a*b-c\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"muladdT(a::P,b::Q,c::R,cache1::Taylor0) where {P,Q,R <:Union{Taylor0,Number}}","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.muladdT-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{P, Q, R, Taylor0}} where {P, Q, R<:Union{Number, Taylor0}}","page":"Taylor Variables","title":"QuantizedSystemSolver.muladdT","text":"muladdT(a::P,b::Q,c::R,cache1::Taylor0) where {P,Q,R <:Union{Taylor0,Number}}\n\ncache1=a*b+c\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"negateT(a::Taylor0, cache::Taylor0)","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.negateT-Tuple{Taylor0, Taylor0}","page":"Taylor Variables","title":"QuantizedSystemSolver.negateT","text":"negateT(a::Taylor0,cache::Taylor0)\n\ncache=-a\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"powerT(a::T, r::S, cache1::Taylor0) where {S<:Real,T<:Number}","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.powerT-Union{Tuple{T}, Tuple{S}, Tuple{T, S, Taylor0}} where {S<:Real, T<:Number}","page":"Taylor Variables","title":"QuantizedSystemSolver.powerT","text":"powerT(a::T, r::S, cache1::Taylor0) where {S<:Real,T<:Number}\n\nRaises a to the power r and stores the result in cache1.\n\nArguments\n\na::T: The base, a number.\nr::S: The exponent, a real number.\ncache1::Taylor0: The cache to store the result.\n\nReturns\n\ncache1::Taylor0: The result of a^r.\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"QuantizedSystemSolver.square(a::Taylor0, cache1::Taylor0)","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.square-Tuple{Taylor0, Taylor0}","page":"Taylor Variables","title":"QuantizedSystemSolver.square","text":"square(a::Taylor0, cache1::Taylor0)\n\nCalculates the square of a and stores the result in cache1.\n\nArguments\n\na::Taylor0: The input Taylor series.\ncache1::Taylor0: The cache to store the result.\n\nReturns\n\ncache1::Taylor0: The result of a^2.\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/#non-allocation-functions","page":"Taylor Variables","title":"non-allocation functions","text":"","category":"section"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"sqrt(a::Taylor0, cache1::Taylor0)","category":"page"},{"location":"developer/taylor/#Base.sqrt-Tuple{Taylor0, Taylor0}","page":"Taylor Variables","title":"Base.sqrt","text":"sqrt(a::Taylor0, cache1::Taylor0)\n\nCalculates the square root of a and stores the result in cache1.\n\nArguments\n\na::Taylor0: The input Taylor series.\ncache1::Taylor0: The cache to store the result.\n\nReturns\n\ncache1::Taylor0: The result of sqrt(a).\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"sqrt(a::T, cache1::Taylor0) where {T<:Number}","category":"page"},{"location":"developer/taylor/#Base.sqrt-Union{Tuple{T}, Tuple{T, Taylor0}} where T<:Number","page":"Taylor Variables","title":"Base.sqrt","text":"sqrt(a::T, cache1::Taylor0) where {T<:Number}\n\nCalculates the square root of a and stores the result in cache1.\n\nArguments\n\na::T: The input number.\ncache1::Taylor0: The cache to store the result.\n\nReturns\n\ncache1::Taylor0: The result of sqrt(a).\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"exp(a::Taylor0, c::Taylor0)","category":"page"},{"location":"developer/taylor/#Base.exp-Tuple{Taylor0, Taylor0}","page":"Taylor Variables","title":"Base.exp","text":"exp(a::Taylor0, c::Taylor0)\n\nCalculates the exponential of a and stores the result in c.\n\nArguments\n\na::Taylor0: The input Taylor series.\nc::Taylor0: The cache to store the result.\n\nReturns\n\nc::Taylor0: The result of exp(a).\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"exp(a::T, c::Taylor0) where {T<:Number}","category":"page"},{"location":"developer/taylor/#Base.exp-Union{Tuple{T}, Tuple{T, Taylor0}} where T<:Number","page":"Taylor Variables","title":"Base.exp","text":"exp(a::T, c::Taylor0) where {T<:Number}\n\nCalculates the exponential of a and stores the result in c.\n\nArguments\n\na::T: The input number.\nc::Taylor0: The cache to store the result.\n\nReturns\n\nc::Taylor0: The result of exp(a).\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"log(a::Taylor0, c::Taylor0)","category":"page"},{"location":"developer/taylor/#Base.log-Tuple{Taylor0, Taylor0}","page":"Taylor Variables","title":"Base.log","text":"log(a::Taylor0, c::Taylor0)\n\nCompute the logarithm of a Taylor0 object a and stores the result in Taylor0 object c.\n\nArguments\n\na::Taylor0: The Taylor0 object for which the logarithm is to be computed.\nc::Taylor0: to store the result\n\nReturns\n\nobject c .\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"sin(a::T, s::Taylor0, c::Taylor0) where {T<:Number}","category":"page"},{"location":"developer/taylor/#Base.sin-Union{Tuple{T}, Tuple{T, Taylor0, Taylor0}} where T<:Number","page":"Taylor Variables","title":"Base.sin","text":"sin(a::T, s::Taylor0, c::Taylor0) where {T<:Number}\n\nCalculates the sine of the number a and stores the result in the Taylor series s.\n\nArguments\n\na::T: The input number.\ns::Taylor0: The Taylor series to store the result.\nc::Taylor0: An auxiliary Taylor series (not used in this function).\n\nReturns\n\ns::Taylor0: The result of sin(a).\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"cos(a::T, s::Taylor0, c::Taylor0) where {T<:Number}","category":"page"},{"location":"developer/taylor/#Base.cos-Union{Tuple{T}, Tuple{T, Taylor0, Taylor0}} where T<:Number","page":"Taylor Variables","title":"Base.cos","text":"cos(a::T, s::Taylor0, c::Taylor0) where {T<:Number}\n\nCalculates the cosine of the number a and stores the result in the Taylor series s.\n\nArguments\n\na::T: The input number.\ns::Taylor0: The Taylor series to store the result.\nc::Taylor0: An auxiliary Taylor series (not used in this function).\n\nReturns\n\ns::Taylor0: The result of cos(a).\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"tan(a::Taylor0, c::Taylor0, c2::Taylor0)","category":"page"},{"location":"developer/taylor/#Base.tan-Tuple{Taylor0, Taylor0, Taylor0}","page":"Taylor Variables","title":"Base.tan","text":"tan(a::Taylor0, c::Taylor0, c2::Taylor0)\n\nCalculates the tangent of the Taylor series a and stores the result in c.\n\nArguments\n\na::Taylor0: The input Taylor series.\nc::Taylor0: The Taylor series to store the result.\nc2::Taylor0: An auxiliary Taylor series used in the calculation.\n\nReturns\n\nc::Taylor0: The result of tan(a).\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"asin(a::Taylor0, c::Taylor0, r::Taylor0, cache3::Taylor0)","category":"page"},{"location":"developer/taylor/#Base.asin-NTuple{4, Taylor0}","page":"Taylor Variables","title":"Base.asin","text":"asin(a::Taylor0, c::Taylor0, r::Taylor0, cache3::Taylor0)\n\nCalculates the arcsine of a and stores the result in c.\n\nArguments\n\na::Taylor0: The input Taylor series.\nc::Taylor0: The cache to store the result.\nr::Taylor0: An auxiliary Taylor series.\ncache3::Taylor0: Another auxiliary Taylor series.\n\nReturns\n\nc::Taylor0: The result of acos(a).\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"acos(a::Taylor0, c::Taylor0, r::Taylor0, cache3::Taylor0)","category":"page"},{"location":"developer/taylor/#Base.acos-NTuple{4, Taylor0}","page":"Taylor Variables","title":"Base.acos","text":"acos(a::Taylor0, c::Taylor0, r::Taylor0, cache3::Taylor0)\n\nCalculates the arccosine of a and stores the result in c.\n\nArguments\n\na::Taylor0: The input Taylor series.\nc::Taylor0: The cache to store the result.\nr::Taylor0: An auxiliary Taylor series.\ncache3::Taylor0: Another auxiliary Taylor series.\n\nReturns\n\nc::Taylor0: The result of acos(a).\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"atan(a::Taylor0, c::Taylor0, r::Taylor0)","category":"page"},{"location":"developer/taylor/#Base.atan-Tuple{Taylor0, Taylor0, Taylor0}","page":"Taylor Variables","title":"Base.atan","text":"atan(a::Taylor0, c::Taylor0, r::Taylor0)\n\nCalculates the arctangent of a and stores the result in c.\n\nArguments\n\na::Taylor0: The input Taylor series.\nc::Taylor0: The cache to store the result.\nr::Taylor0: An auxiliary Taylor series.\n\nReturns\n\nc::Taylor0: The result of atan(a).\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"abs(a::Taylor0, cache1::Taylor0)","category":"page"},{"location":"developer/taylor/#Base.abs-Tuple{Taylor0, Taylor0}","page":"Taylor Variables","title":"Base.abs","text":"abs(a::Taylor0, cache1::Taylor0)\n\nCompute the absolute value of a Taylor0 object a and store the result in cache1.\n\nArguments\n\na::Taylor0: The input Taylor0 object whose absolute value is to be computed.\ncache1::Taylor0: A Taylor0 object to store the result of the absolute value computation.\n\nReturns\n\ncache1::Taylor0: The Taylor0 object containing the absolute value of a.\n\n\n\n\n\n","category":"method"},{"location":"developer/taylor/#Internals","page":"Taylor Variables","title":"Internals","text":"","category":"section"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"All internals functions of the TaylorSeries.jl are used with the exception of the  following two functions, which are rewritten to avoid one allocation.","category":"page"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"QuantizedSystemSolver.asin!","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.asin!","page":"Taylor Variables","title":"QuantizedSystemSolver.asin!","text":"asin!(c::Taylor0, a::Taylor0, r::Taylor0, cache3::Taylor0, k::Int)\n\nCompute the arcsine of a Taylor series a and store the result in c.  The computation uses intermediate results stored in r and cache3.  The parameter k specifies the order of the Taylor series expansion.  This is a copy of the function asin! as written in the package TaylorSeries.jl but with an added cache to avoid allocation.\n\nArguments\n\nc::Taylor0: The Taylor series where the result will be stored.\na::Taylor0: The input Taylor series for which the arcsine is computed.\nr::Taylor0: An intermediate Taylor series used in the computation.\ncache3::Taylor0: Another intermediate Taylor series used in the computation to avoid one allocation of function square inside.\nk::Int: The order of the Taylor series expansion.\n\nReturns\n\nnothing: The result of the arcsine computation stored in c.\n\n\n\n\n\n","category":"function"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"QuantizedSystemSolver.acos!","category":"page"},{"location":"developer/taylor/#QuantizedSystemSolver.acos!","page":"Taylor Variables","title":"QuantizedSystemSolver.acos!","text":"    acos!(c::Taylor0, a::Taylor0, r::Taylor0, cache3::Taylor0, k::Int)\n\nCompute the arccosine of a Taylor series a and store the result in c.  The computation uses intermediate results stored in r and cache3.  The parameter k specifies the order of the Taylor series expansion. This is a copy of the function acos! as written in the package TaylorSeries.jl but with an added cache to avoid one allocation.\n\nArguments\n\nc::Taylor0: The Taylor series where the result will be stored.\na::Taylor0: The input Taylor series for which the arcsine is computed.\nr::Taylor0: An intermediate Taylor series used in the computation.\ncache3::Taylor0: Another intermediate Taylor series used in the computation to avoid allocation of function square inside.\nk::Int: The order of the Taylor series expansion.\n\nReturns\n\nnothing: The result of the arcsine computation stored in c.\n\n\n\n\n\n","category":"function"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"note: Allocating TaylorSeries functions\nAs a fallback all TaylorSeries functions are used in case an expression is not transformed to one of the existing personalized functions above.","category":"page"},{"location":"developer/taylor/#Index","page":"Taylor Variables","title":"Index","text":"","category":"section"},{"location":"developer/taylor/","page":"Taylor Variables","title":"Taylor Variables","text":"Pages = [\"taylor.md\"]\nOrder = [:type, :function]","category":"page"},{"location":"developer/algorithm/#QSS-Algorithms","page":"QSS Algorithms","title":"QSS Algorithms","text":"","category":"section"},{"location":"developer/algorithm/","page":"QSS Algorithms","title":"QSS Algorithms","text":"The Algorithm type is parametric on the solver name (N) and order (O). Currently there are three specific algorithm names: (QSS Algorithm, LiQSS Algorithm, and mLiQSS Algorithm), and two orders (1 and 2).","category":"page"},{"location":"developer/algorithm/#Algorithm-extension","page":"QSS Algorithms","title":"Algorithm extension","text":"","category":"section"},{"location":"developer/algorithm/","page":"QSS Algorithms","title":"QSS Algorithms","text":"Any new algorithm can be added via the name N which is of type Val, and with the order O which also of type Val according to this type:","category":"page"},{"location":"developer/algorithm/","page":"QSS Algorithms","title":"QSS Algorithms","text":" QuantizedSystemSolver.Algorithm{N,O}","category":"page"},{"location":"developer/algorithm/#QuantizedSystemSolver.Algorithm","page":"QSS Algorithms","title":"QuantizedSystemSolver.Algorithm","text":"Algorithm{N,O}\n\nThis is a superclass for all QSS algorithms. It is parametric on:\n\nThe name of the algorithm N\nThe order of the algorithm O\n\n\n\n\n\n","category":"type"},{"location":"developer/algorithm/","page":"QSS Algorithms","title":"QSS Algorithms","text":" QSSAlgorithm{N,O}","category":"page"},{"location":"developer/algorithm/#QuantizedSystemSolver.QSSAlgorithm","page":"QSS Algorithms","title":"QuantizedSystemSolver.QSSAlgorithm","text":"QSSAlgorithm{N,O}\n\nThis is the first subclass for QSS algorithms. It is parametric on:\n\nThe name of the algorithm N\nThe order of the algorithm O\n\n\n\n\n\n","category":"type"},{"location":"developer/algorithm/#What-is-needed-with-a-new-algorithm:","page":"QSS Algorithms","title":"What is needed with a new algorithm:","text":"","category":"section"},{"location":"developer/algorithm/","page":"QSS Algorithms","title":"QSS Algorithms","text":"A new algorithm with the same old name and a different order (>2) requires an addition only of the quantizer methods.\nA new algorithm with a new name and an old order (1,2) requires an addition of an integrate method only.\nA new algorithm with a new name and a new order requires an addition of an integrate method and addition of the quantizer methods.\nCreating a new superclass similar to the QSSAlgorithm requires an addition of a new solve function.","category":"page"},{"location":"developer/algorithm/#Example","page":"QSS Algorithms","title":"Example","text":"","category":"section"},{"location":"developer/algorithm/","page":"QSS Algorithms","title":"QSS Algorithms","text":"my_new_algorithm()=QSSAlgorithm(Val(:my_new_algorithm),Val(3))","category":"page"},{"location":"developer/algorithm/","page":"QSS Algorithms","title":"QSS Algorithms","text":"This is a new algorithm name of order 3 belongs to the family of the QSSAlgorithm. Only an addition of the integrate and the quantizer methods is needed.","category":"page"},{"location":"developer/solve/#Solve","page":"Solve","title":"Solve","text":"","category":"section"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"The solve function is the primary interface for solving ODE problems using various QSS (Quantized State Systems) algorithms. It does this by dispatching on the problem and algorithm types to select the right solver.","category":"page"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"Based on the QSS Algorithm provided, the solve function either selects a basic QSS integration method or, in the case of LiQSS, constructs additional data structures needed for implicit integration. The method defaults to cycle detection (Val(2)), tolerances (abstol=1e-3 and reltol=1e-3), and a maximum number of iterations (maxiters=1e7). These parameters can be adjusted based on the problem's complexity and desired accuracy. When a user doesn't provide a solver explicitly, the solve function defaults to using the modified second-order implicit algorith (mLiQSS2). ","category":"page"},{"location":"developer/solve/#Helper-Functions:","page":"Solve","title":"Helper Functions:","text":"","category":"section"},{"location":"developer/solve/#createCommonData:","page":"Solve","title":"createCommonData:","text":"","category":"section"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"Sets up the common data required by the QSS solver. It initializes all necessary vectors (x, q, tx, tq, nextStateTime, etc.) used in the integration process, and it pre-allocates a cache of Taylor series to avoid repeated memory allocation during integration (taylorOpsCache).","category":"page"},{"location":"developer/solve/#getClosure:","page":"Solve","title":"getClosure:","text":"","category":"section"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"Creates a closure for the Jacobian and the dependency matrices, allowing easy extension. The closure is used to access the Jacobian matrix during the integration process.","category":"page"},{"location":"developer/solve/#createLiqssData:","page":"Solve","title":"createLiqssData:","text":"","category":"section"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"Initializes internal data structures required by LiQSS solvers for managing linear approximations. This function has two methods, depending on how the Jacobian is specified during problem definition (via the ODEProblem function):","category":"page"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"Symbolic Jacobian (:symbolic):","category":"page"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"  createLiqssData(::Val{:symbolic}, ::Val{M}, ::Val{T}, ::Val{Order}) where {T, Order, M}","category":"page"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"Constructs and returns an AexprLiQSS_data object, which stores symbolic expressions for the Jacobian entries.","category":"page"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"Approximated Jacobian (:approximate):","category":"page"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"createLiqssData(::Val{:approximate}, ::Val{M}, ::Val{T}, ::Val{Order}) where {T, Order, M}","category":"page"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"Constructs and returns an AmanualLiQSS_data object, which stores coefficient data to be used for the approximation of the jacobian entries.","category":"page"},{"location":"developer/solve/#Internals","page":"Solve","title":"Internals","text":"","category":"section"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"QuantizedSystemSolver.custom_Solve(prob::ODEProblemData{F,PRTYPE,T,D,Z,CS},al::QSSAlgorithm{Solver, Order},::Val{M},finalTime::Float64,saveat::Float64,initialTime::Float64,abstol::Float64,reltol::Float64,maxErr::Float64,maxiters::Int,verbose::Bool) where{F,PRTYPE,T,D,Z,CS,Solver,Order,M}    ","category":"page"},{"location":"developer/solve/#QuantizedSystemSolver.custom_Solve-Union{Tuple{M}, Tuple{Order}, Tuple{Solver}, Tuple{CS}, Tuple{Z}, Tuple{D}, Tuple{T}, Tuple{PRTYPE}, Tuple{F}, Tuple{ODEProblemData{F, PRTYPE, T, D, Z, CS}, QSSAlgorithm{Solver, Order}, Val{M}, Float64, Float64, Float64, Float64, Float64, Float64, Int64, Bool}} where {F, PRTYPE, T, D, Z, CS, Solver, Order, M}","page":"Solve","title":"QuantizedSystemSolver.custom_Solve","text":"custom_Solve(prob::ODEProblemData{F,PRTYPE,T,D,Z,CS},al::QSSAlgorithm{Solver, Order},::Val{M},finalTime::Float64,saveat::Float64,initialTime::Float64,abstol::Float64,reltol::Float64,maxErr::Float64,maxiters::Int,verbose::Bool) where{F,PRTYPE,T,D,Z,CS,Solver,Order,M}\n\ndefault solve method: calls the integrator to solve the nonlinear ODE problem.\n\nArguments\n\nprob::ODEProblemData{F,PRTYPE,T,D,Z,CS}: The nonlinear ODE problem to solve.\nal::QSSAlgorithm{Solver, Order}: The QSS algorithm to use for solving the problem.\n::Val{M}: A type parameter indicating which detection mechanism to use.\nfinalTime::Float64: The final time for the simulation.\nsaveat::Float64: The time interval at which to save the solution.\ninitialTime::Float64: The initial time for the simulation.\nabstol::Float64: The absolute tolerance for the solver.\nreltol::Float64: The relative tolerance for the solver.\nmaxErr::Float64: The maximum allowable error.\nmaxiters::Int: The maximum number of iterations.\n\n\n\n\n\n","category":"method"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"QuantizedSystemSolver.createCommonData(prob::ODEProblemData{F,PRTYPE,T,D,Z,CS},::Val{Order},finalTime::Float64,saveat::Float64,initialTime::Float64,abstol::Float64,reltol::Float64,maxErr::Float64,maxiters::Int,verbose::Bool) where{F,PRTYPE,T,D,Z,CS,Order}","category":"page"},{"location":"developer/solve/#QuantizedSystemSolver.createCommonData-Union{Tuple{Order}, Tuple{CS}, Tuple{Z}, Tuple{D}, Tuple{T}, Tuple{PRTYPE}, Tuple{F}, Tuple{ODEProblemData{F, PRTYPE, T, D, Z, CS}, Val{Order}, Float64, Float64, Float64, Float64, Float64, Float64, Int64, Bool}} where {F, PRTYPE, T, D, Z, CS, Order}","page":"Solve","title":"QuantizedSystemSolver.createCommonData","text":"createCommonData(prob::ODEProblemData{F,PRTYPE,T,D,Z,CS},::Val{Order},finalTime::Float64,saveat::Float64,initialTime::Float64,abstol::Float64,reltol::Float64,maxErr::Float64,maxiters::Int,verbose::Bool) where{F,PRTYPE,T,D,Z,CS,Order}\n\ncreates the necessary data for the simulation and stores it in a CommonQSS_Data struct.\n\nArguments\n\nprob::ODEProblemData{F,PRTYPE,T,D,Z,CS}: The nonlinear ODE problem to solve.\n::Val{Order}: The order of the algorithm.\nfinalTime::Float64: The final time for the simulation.\nsaveat::Float64: The time interval at which to save the solution.\ninitialTime::Float64: The initial time for the simulation.\nabstol::Float64: The absolute tolerance for the solver.\nreltol::Float64: The relative tolerance for the solver.\nmaxErr::Float64: The maximum allowable error.\nmaxiters::Int: The maximum number of iterations.\n\nReturns\n\nA data structure containing common data required for the QSS algorithm.\n\n\n\n\n\n","category":"method"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"QuantizedSystemSolver.createLiqssData(::Val{:symbolic},::Val{M},::Val{T},::Val{Order}) where{T,Order,M} ","category":"page"},{"location":"developer/solve/#QuantizedSystemSolver.createLiqssData-Union{Tuple{M}, Tuple{Order}, Tuple{T}, Tuple{Val{:symbolic}, Val{M}, Val{T}, Val{Order}}} where {T, Order, M}","page":"Solve","title":"QuantizedSystemSolver.createLiqssData","text":"createLiqssData(::Val{:symbolic},::Val{M},::Val{T},::Val{Order}) where{T,Order,M}\n\nCreates LIQSS-specific data required for solving an ODE problem.\n\nArguments\n\n::Val{M}: A type parameter indicating which detection mechanism to use.\n::Val{T}: The number of continuous variables.\n::Val{Order}: The order of the algorithm.\n\nReturns\n\nA data structure containing LIQSS-specific data required for liQSS algorithms.\n\n\n\n\n\n","category":"method"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":"QuantizedSystemSolver.CommonQSS_Data{Z}","category":"page"},{"location":"developer/solve/#QuantizedSystemSolver.CommonQSS_Data","page":"Solve","title":"QuantizedSystemSolver.CommonQSS_Data","text":"CommonQSS_Data{Z}\n\nhelper datastructures that hold settings, temporary saved data needed for simulation, and results. \n\n\n\n\n\n","category":"type"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":" QuantizedSystemSolver.LiQSS_Data{O,M}","category":"page"},{"location":"developer/solve/#QuantizedSystemSolver.LiQSS_Data","page":"Solve","title":"QuantizedSystemSolver.LiQSS_Data","text":"LiQSS_Data{O,M}\n\nAn abstract type representing the data structure for the LiQSS (Linearly Quantized State System) solver.\n\nType Parameters\n\nO: The type parameter representing the order of the QSS method.\nM: The cycle detection mechanism number, which can be used to specify different cycle detection strategies.\n\n\n\n\n\n","category":"type"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":" QuantizedSystemSolver.AexprLiQSS_data{O,M}","category":"page"},{"location":"developer/solve/#QuantizedSystemSolver.AexprLiQSS_data","page":"Solve","title":"QuantizedSystemSolver.AexprLiQSS_data","text":"AexprLiQSS_data{O,M}\n\nhelper datastructures needed only for implicit case to store the Jacobian coefficients from an expression function. The field variables are:\n\ncycleDetection::Val{M} # cycle detection mechanism\ncacheA::MVector{1,Float64} # the coef a is computed from a function and the result is saved in a chache.\nqaux::Vector{MVector{O,Float64}} # to update u, q^- and dx^- are needed, so these 2 are to save the old values\ndxaux::Vector{MVector{O,Float64}} # so these 2 are to save the old values\nolddx::Int64 # not needed for coefficient 'a' precomputed as expression, but kept for compatibility with parent type\n\n\n\n\n\n","category":"type"},{"location":"developer/solve/","page":"Solve","title":"Solve","text":" QuantizedSystemSolver.AmanualLiQSS_data{O,M}","category":"page"},{"location":"developer/solve/#QuantizedSystemSolver.AmanualLiQSS_data","page":"Solve","title":"QuantizedSystemSolver.AmanualLiQSS_data","text":"AmanualLiQSS_data{O,M}\n\nA data structure for storing information specific to the manual implementation of the LiQSS (Linear Quantized State System) method.\n\nType Parameters\n\nO: The order of the QSS method.\nM: The cycle detection mechanism number.\n\nDescription\n\nThis struct extends LiQSS_Data and is intended for use in scenarios where a manual computation of the jacobian coefficient is recommended or required. It includes fields for storing the cycle detection mechanism, coefficient 'a', auxiliary vectors for quantized states and old values, and an additional vector for storing old dx values.\n\nThe field variables are:\n- `cycleDetection::Val{M}`: Cycle detection mechanism.\n- `a::Vector{Vector{Float64}}`: Coefficient 'a' computed manually.\n- `cacheA::Int64`: Not needed when coefficient 'a' is computed manually, but kept for compatibility with parent type.\n- `qaux::Vector{MVector{O,Float64}}`: Auxiliary vectors to update `u`, `q^-`.\n- `dxaux::Vector{MVector{O,Float64}}`: Auxiliary vectors `dx^- to save the old values (and high order derivatives).\n- `olddx::Vector{MVector{1,Float64}}`: Needed to compute the coefficient 'a' manually, storing old dx values (only first derivative).\n\nSee Also\n\nLiQSS_Data\n\n\n\n\n\n","category":"type"},{"location":"examples/linearTimeInvariantSystemEvents/#Linear-Time-Invariant-with-events","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"","category":"section"},{"location":"examples/linearTimeInvariantSystemEvents/","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"The same previous LTI example is extended to contain events (discontinuities). At times 2.5 and 5.0 the differential equations are changed. This is modeled through discrete variables passed in the p vector. The events are defined through if-statements.","category":"page"},{"location":"examples/linearTimeInvariantSystemEvents/","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"using QuantizedSystemSolver\nfunction funcName(du,u,p,t)\n    du[1] = p[1]*u[1]+p[2]*u[2]+p[3]\n    du[2] = p[4]*u[1]+p[5]*u[2]+p[6]\n    if t>2.5\n        p[1]=-22.0\n        p[3]=1000.0\n    end\n    if t>5.0\n        p[2]=-20.0\n        p[5]=-10.0\n        p[6]=-0.5\n    end\nend\ntspan = (0.0,7.0)\nu0= [-1.0, -2.0]\np=[-20.0,-80.0,1600.0,1.24,0.01,0.2]\nprob = ODEProblem(funcName,u0,tspan,p)\n#Solve the problem\nsol = solve(prob,nmliqss2(),abstol = 1e-4, reltol = 1e-2)\np1 = plot(sol);","category":"page"},{"location":"examples/linearTimeInvariantSystemEvents/","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"The analytic solution is given by the following equations:","category":"page"},{"location":"examples/linearTimeInvariantSystemEvents/","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"using Plots\nfunction A1() \n    x1(t)=105.83453057676363*-8.83362618880318*exp(-10.943696474115944*t)-127.91533865757171*-7.303470585390368*exp(-9.046303525884058*t)-0.32323232323231316\n    x2(t)=105.83453057676363*exp(-10.943696474115944*t)-127.91533865757171*exp(-9.046303525884058*t)+20.08080808080808\n    return (x1,x2) \nend   \nfunction B1() \n    x1(t)=-5.300798816237515e17*-12.649850456341543*exp(-15.675814565863513*t)+9.014692147675046e7*-5.10014954365846*exp(-6.314185434136489*t)-0.26267932915740405\n    x2(t)=-5.300798816237515e17*exp(-15.675814565863513*t)+9.014692147675046e7*exp(-6.314185434136489*t)+12.572236815518284\n    return (x1,x2) \nend \nfunction C1() \n    x1(t)=4.746452513218909e42*-7.537612988819599*exp(-19.346640106136302*t)+8.75190264440514e27*-2.139806366019111*exp(-12.653359893863698*t)+40.890522875817\n    x2(t)=4.746452513218909e42*exp(-19.346640106136302*t)+8.75190264440514e27*exp(-12.653359893863698*t)+5.020424836601308\n    return (x1,x2) \nend \nfunction x1(t)\n    if t<2.5\n        return A1()[1](t)\n    elseif t<5.0\n        return B1()[1](t)\n    else\n        return C1()[1](t)\n    end\nend\nfunction x2(t)\n    if t<2.5\n        return A1()[2](t)\n    elseif t<5.0\n        return B1()[2](t)\n    else\n        return C1()[2](t)\n    end\nend\np1=plot!(x1,0,10,label=\"x1\")\np1=plot!(x2,0,10,label=\"x2\")","category":"page"},{"location":"examples/linearTimeInvariantSystemEvents/","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"Then use DifferentialEquations instead of QuantizedSystemSolver, and use callbacks instead of if-statements.","category":"page"},{"location":"examples/linearTimeInvariantSystemEvents/","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"using DifferentialEquations\nfunction funcName(du,u,p,t)\n    du[1] = p[1]*u[1]+p[2]*u[2]+p[3]\n    du[2] = p[4]*u[1]+p[5]*u[2]+p[6]\nend\ntspan = (0.0,10.0)\nu0= [-1.0, -2.0]\np=[-20.0,-80.0,1600.0,1.24,0.01,0.2]\nprob = ODEProblem(funcName,u0,tspan,p)\nfunction condition1( u, t, integrator) \n    (t-2.5)\nend\nfunction condition2( u, t, integrator) \n    (t-5.0)\nend\nfunction affect1!(integrator)\n    p[1]=-22.0\n    p[3]=1000.0\nend\nfunction affect2!(integrator)\n    p[2]=-20.0\n    p[5]=-10.0\n    p[6]=-0.5\nend\ncb1 = ContinuousCallback(condition1, affect1!,nothing;  )\ncb2 = ContinuousCallback(condition2, affect2!,nothing; )\ncbs = CallbackSet(cb1, cb2)\nsolRosenbrock23 = solve(prob,Rosenbrock23(),callback = cbs,abstol = 1e-4, reltol = 1e-2) \np1=plot!(solRosenbrock23,title=\"Rosenbrock23\")","category":"page"},{"location":"examples/linearTimeInvariantSystemEvents/","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"The plots are displayed below:","category":"page"},{"location":"examples/linearTimeInvariantSystemEvents/","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"LTI with events using QuantizedSystemSolver.jl","category":"page"},{"location":"examples/linearTimeInvariantSystemEvents/","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"(Image: LTI_events plot with nmliqss2)","category":"page"},{"location":"examples/linearTimeInvariantSystemEvents/","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"LTI with events using DifferentialEquation.jl","category":"page"},{"location":"examples/linearTimeInvariantSystemEvents/","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"(Image: LTI_events plot with Rosenbrock23)","category":"page"},{"location":"examples/linearTimeInvariantSystemEvents/","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"LTI with events using the analytic solution","category":"page"},{"location":"examples/linearTimeInvariantSystemEvents/","page":"Linear Time Invariant with events","title":"Linear Time Invariant with events","text":"(Image: LTI_events Analytic plot)","category":"page"},{"location":"background/qss/#Quantized-State-System-Methods","page":"Quantized State System Methods","title":"Quantized State System Methods","text":"","category":"section"},{"location":"background/qss/#QSS1","page":"Quantized State System Methods","title":"QSS1","text":"","category":"section"},{"location":"background/qss/","page":"Quantized State System Methods","title":"Quantized State System Methods","text":"The QSS1 method is the simplest of the QSS methods. It is based on the assumption that the state variables are piecewise constant between the thresholds. The state variables are updated only when a threshold is crossed. The time of the next threshold crossing is computed explicitly. The QSS1 method is a first-order method, and the state variables are updated using a taylor expansion, similar to the Euler method, given by the following equations:","category":"page"},{"location":"background/qss/","page":"Quantized State System Methods","title":"Quantized State System Methods","text":"    beginalign*\n       x_i=x_i+dot x_ie_i  \n    endalign*","category":"page"},{"location":"background/qss/","page":"Quantized State System Methods","title":"Quantized State System Methods","text":"where x_i is the i^th state variable, dot x_i is the derivative of this state variable, and e is the elapsed time since its last update. The next time of change is computed as t_i^n=t_current+fracDelta_idot x_i where Delta_i is the quantum of the variable x_i. The QSS1 method is defined in the foloowing Algorithm.","category":"page"},{"location":"background/qss/","page":"Quantized State System Methods","title":"Quantized State System Methods","text":"QSS1 algorithm","category":"page"},{"location":"background/qss/","page":"Quantized State System Methods","title":"Quantized State System Methods","text":"If a variable i needs to change\nCompute the elapsed time e_i since the last update of variable i\nUpdate the variable x_i=x_i+dot x_ie_i\nUpdate the quantum Delta_i\nUpdate the Quantized variable q_i = x_i\nCompute the next time of change t_i^n\nFor any variable j depends on i\nUpdate the variable x_j=x_j+dot x_je_j\nUpdate the derivative dot x_j=f_j(Qt) \nCompute the next time when q_j=x_j  or q_j-x_j=2Delta_j \nFor any zero crossing function zc depends on i\nUpdate zc\nCompute the next event time of zc \nIf an event needs to occur\nrecheck validity of the event\nexecute the event and update the related quantized variables\nFor any variable j depends on the event\nUpdate the variable x_j=x_j+dot x_je_j\nUpdate the derivative dot x_j=f_j(Qt) \nCompute the next time when q_j=x_j  or q_j-x_j=2Delta_j \nFor any zero crossing function zc depends on the event\nUpdate zc\nCompute the next event time of zc ","category":"page"},{"location":"background/qss/#QSS2","page":"Quantized State System Methods","title":"QSS2","text":"","category":"section"},{"location":"background/qss/","page":"Quantized State System Methods","title":"Quantized State System Methods","text":"The QSS2 method is a second-order method. The state variables are updated using a Taylor expansion given by the following equations:","category":"page"},{"location":"background/qss/","page":"Quantized State System Methods","title":"Quantized State System Methods","text":"  beginalign*\n     x_i=x_i+dot x_ie_i+frac12ddot x_ie_i^2  \n     dot x_i=dot x_i+ddot x_ie_i \n  endalign*","category":"page"},{"location":"background/qss/","page":"Quantized State System Methods","title":"Quantized State System Methods","text":"where ddot x_i is the second derivative of this state variable. The next time of change is computed as t_i^n=t_current+sqrt(fracDelta_iddot x_i). The QSS2 method is defined in the following Algorithm.","category":"page"},{"location":"background/qss/","page":"Quantized State System Methods","title":"Quantized State System Methods","text":"QSS2 algorithm","category":"page"},{"location":"background/qss/","page":"Quantized State System Methods","title":"Quantized State System Methods","text":"If a variable i needs to change\nCompute the elapsed time e_i since the last update of variable i\nUpdate the variable x_i=x_i+dot x_ie_i+frac12ddot x_ie_i^2\nUpdate the quantum Delta_i\nUpdate the variable dot x_i=dot x_i+ddot x_ie\nUpdate the Quantized variable q_i = x_i\nUpdate the Quantized derivative dot q_i = dot x_i\nCompute the next time of change t_i^n\nFor any variable j depends on i\nUpdate the variable x_j=x_j+dot x_je_j+frac12ddot x_je_j^2\nFor any variable k that f_j depends upon\nUpdate the Quantized variable q_k=q_k+dot q_ke_k\nUpdate the derivative dot x_j=f_j(Qt) \nUpdate the second derivative ddot x_j=dot f_j(Qt) \nCompute the next time when q_j=x_j  or q_j-x_j=2Delta_j \nFor any zero crossing function zc depends on i\nFor any variable k that zc depends upon\nUpdate the Quantized variable q_k=q_k+dot q_ke_k\nUpdate zc\nCompute the next event time of zc \nIf an event needs to occur\nrecheck validity of the event\nexecute the event and update the related quantized variables\nFor any variable j depends on the event\nUpdate the variable x_j=x_j+dot x_je_j+frac12ddot x_je_j^2\nFor any variable k that f_j depends upon\nUpdate the Quantized variable q_k=q_k+dot q_ke_k\nUpdate the derivative dot x_j=f_j(Qt) \nUpdate the second derivative ddot x_j=dot f_j(Qt) \nCompute the next time when q_j=x_j  or q_j-x_j=2Delta_j \nFor any zero crossing function zc depends on the event\nFor any variable k that zc depends upon\nUpdate the Quantized variable q_k=q_k+dot q_ke_k\nUpdate zc\nCompute the next event time of zc ","category":"page"},{"location":"developer/utils/#Utils-references","page":"Utils references","title":"Utils references","text":"","category":"section"},{"location":"developer/utils/#Root-finding","page":"Utils references","title":"Root finding","text":"","category":"section"},{"location":"developer/utils/","page":"Utils references","title":"Utils references","text":"These methods find the minimum positive root of a linear and quadratic equations for order 1 and 2 respectively. For order 3, similar methods should be added to solve the cubic equation.","category":"page"},{"location":"developer/utils/","page":"Utils references","title":"Utils references","text":"QuantizedSystemSolver.minPosRoot(c::Float64,b::Float64, ::Val{1})","category":"page"},{"location":"developer/utils/#QuantizedSystemSolver.minPosRoot-Tuple{Float64, Float64, Val{1}}","page":"Utils references","title":"QuantizedSystemSolver.minPosRoot","text":"minPosRoot(c::Float64,b::Float64, ::Val{1})\n\nFinds the minimum positive root for a linear equation represented by the coefficients.\n\nReturns\n\nThe minimum positive root of the linear equation. \n\n\n\n\n\n","category":"method"},{"location":"developer/utils/","page":"Utils references","title":"Utils references","text":"QuantizedSystemSolver.minPosRoot(c::Float64,b::Float64,a::Float64,::Val{2})","category":"page"},{"location":"developer/utils/#QuantizedSystemSolver.minPosRoot-Tuple{Float64, Float64, Float64, Val{2}}","page":"Utils references","title":"QuantizedSystemSolver.minPosRoot","text":"minPosRoot(c::Float64,b::Float64,a::Float64,::Val{2})\n\nFinds the minimum positive root for a quadratic equation represented by the coefficients.\n\nReturns\n\nThe minimum positive root of the quadratic equation.\n\n\n\n\n\n","category":"method"},{"location":"developer/utils/","page":"Utils references","title":"Utils references","text":"QuantizedSystemSolver.minPosRoot(coeff::Taylor0, ::Val{1})","category":"page"},{"location":"developer/utils/#QuantizedSystemSolver.minPosRoot-Tuple{Taylor0, Val{1}}","page":"Utils references","title":"QuantizedSystemSolver.minPosRoot","text":"minPosRoot(coeff::Taylor0, ::Val{1})\n\nFinds the minimum positive root for a linear equation represented by the Taylor series coefficients.\n\nArguments\n\ncoeff::Taylor0: The Taylor series coefficients of the linear equation.\n::Val{1}: A type parameter indicating the order.\n\nReturns\n\nThe minimum positive root of the linear equation.\n\n\n\n\n\n","category":"method"},{"location":"developer/utils/","page":"Utils references","title":"Utils references","text":"QuantizedSystemSolver.minPosRoot(coeff::Taylor0, ::Val{2})","category":"page"},{"location":"developer/utils/#QuantizedSystemSolver.minPosRoot-Tuple{Taylor0, Val{2}}","page":"Utils references","title":"QuantizedSystemSolver.minPosRoot","text":"minPosRoot(coeff::Taylor0, ::Val{2})\n\nFinds the minimum positive root for a quadratic equation represented by the Taylor series coefficients.\n\nArguments\n\ncoeff::Taylor0: The Taylor series coefficients of the quadratic equation.\n::Val{2}: A type parameter indicating the order.\n\nReturns\n\nThe minimum positive root of the quadratic equation.\n\n\n\n\n\n","category":"method"},{"location":"developer/utils/#Scheduler","page":"Utils references","title":"Scheduler","text":"","category":"section"},{"location":"developer/utils/","page":"Utils references","title":"Utils references","text":"The scheduler component retrieves the next index (a state change or an event) for processing. It determines the next action by comparing three types of timing events: state updates, events, and input updates. It initializes minimum time variables for each action type to infinity and iterates through the provided vectors to find the minimum times and their corresponding indices. Based on these comparisons, it decides whether the next scheduled action is an input update, an event, or a state update. If no valid actions are found (indicated by a zero index), the function assigns a default state indicating the next action is a state update at time infinity. Finally, it returns a tuple containing the index of the next action, its time, and a symbol representing the type of action to take next (:STINPUT, :STEVENT, or :STSTATE). This structure ensures that the simulation progresses accurately and efficiently.","category":"page"},{"location":"developer/utils/","page":"Utils references","title":"Utils references","text":"QuantizedSystemSolver.updateScheduler(::Val{T}, nextStateTime::Vector{Float64}, nextEventTime::MVector{Z,Float64}, nextInputTime::Vector{Float64}) where {T, Z}","category":"page"},{"location":"developer/utils/#QuantizedSystemSolver.updateScheduler-Union{Tuple{Z}, Tuple{T}, Tuple{Val{T}, Vector{Float64}, MVector{Z, Float64}, Vector{Float64}}} where {T, Z}","page":"Utils references","title":"QuantizedSystemSolver.updateScheduler","text":"updateScheduler(::Val{T}, nextStateTime::Vector{Float64}, nextEventTime::MVector{Z,Float64}, nextInputTime::Vector{Float64}) where {T, Z}\n\nUpdates the scheduler by finding the minimum times among state, event, and input transitions.\n\nArguments\n\n::Val{T}: A type parameter indicating the number of state transitions.\nnextStateTime::Vector{Float64}: A vector of times for the next state transitions.\nnextEventTime::MVector{Z,Float64}: A mutable vector of times for the next event transitions.\nnextInputTime::Vector{Float64}: A vector of times for the next input transitions.\n\nReturns\n\nA tuple containing the minimum (state index,state time), (event index, event tim, or (input index, input time).\n\n\n\n\n\n","category":"method"},{"location":"examples/vanderpol/#Van-der-Pol","page":"Van der Pol","title":"Van der Pol","text":"","category":"section"},{"location":"examples/vanderpol/","page":"Van der Pol","title":"Van der Pol","text":"The Van der Pol oscillator is a nonlinear system that is often used to model biological rhythms, electrical circuits, and other systems with nonlinear dynamics. The equations for the Van der Pol oscillator are:","category":"page"},{"location":"examples/vanderpol/","page":"Van der Pol","title":"Van der Pol","text":"beginalign*\ndotx = y \ndoty = (1 - x^2)y - x\nendalign*","category":"page"},{"location":"examples/vanderpol/","page":"Van der Pol","title":"Van der Pol","text":"The QuantizedSystemSolver code to solve this system:","category":"page"},{"location":"examples/vanderpol/","page":"Van der Pol","title":"Van der Pol","text":"using QuantizedSystemSolver\nfunction vanderpol(du,u,p,t)\n    du[1] = u[2]\n    du[2] = (1.0-u[1]*u[1])*u[2]-u[1] \nend\nu0 = [0.0,1.7];tspan=(0.0,10.0)\n#Construct the problem\nodeprob = ODEProblem(vanderpol,u0,tspan)\n#Solve the problem\nsol=solve(odeprob,nmliqss2())\np1=plot(sol);\nsavefig(p1, \"vanderpol_$(nmliqss2())\") ","category":"page"},{"location":"examples/vanderpol/","page":"Van der Pol","title":"Van der Pol","text":"Replace nmliqss2 by ABDF2() from the DifferentialEquations.jl, to obtain the following plots.","category":"page"},{"location":"examples/vanderpol/","page":"Van der Pol","title":"Van der Pol","text":"(Image: plot_vanderpol_nmliqss2) (Image: plot_vanderpol_nmliqss2)","category":"page"},{"location":"examples/vanderpol/","page":"Van der Pol","title":"Van der Pol","text":"Variable 2 can viewed wrt variable 1 using:","category":"page"},{"location":"examples/vanderpol/","page":"Van der Pol","title":"Van der Pol","text":"p1=plot(sol,idxs=(1,2),title=\"...\");","category":"page"},{"location":"examples/vanderpol/","page":"Van der Pol","title":"Van der Pol","text":"(Image: plot_vanderpol_nmliqss2) (Image: plot_vanderpol_nmliqss2)","category":"page"},{"location":"examples/dosing/#Conditional-Dosing-in-Pharmacometrics","page":"Conditional Dosing in Pharmacometrics","title":"Conditional Dosing in Pharmacometrics","text":"","category":"section"},{"location":"examples/dosing/","page":"Conditional Dosing in Pharmacometrics","title":"Conditional Dosing in Pharmacometrics","text":"This section shows the Conditional Dosing in Pharmacometrics example tested using the Tsit5() of the DifferentialEquations.jl","category":"page"},{"location":"examples/dosing/","page":"Conditional Dosing in Pharmacometrics","title":"Conditional Dosing in Pharmacometrics","text":"using Plots\nusing DifferentialEquations\nfunction f(du,u,p,t) \n    du[1] =-u[1]\nend \nu0 = [10.0]\ntspan=(0.0,10.0)\nprob = ODEProblem(f, u0, tspan)\ncondition(u, t, integrator) = t == 4 && u[1] < 4\naffect!(integrator) = integrator.u[1] += 10\ncb = DiscreteCallback(condition, affect!)\nsol=solve(prob, Rosenbrock23(), callback = cb,abstol=1e-3,reltol=1e-2)\np1=plot(sol);\nsavefig(p1, \"dosing---\")","category":"page"},{"location":"examples/dosing/","page":"Conditional Dosing in Pharmacometrics","title":"Conditional Dosing in Pharmacometrics","text":"The same problem is handled using QuantizedSystemSolver. First, the differential equation is defined. Then we have two conditions t == 4 && u[1] < 4 .","category":"page"},{"location":"examples/dosing/","page":"Conditional Dosing in Pharmacometrics","title":"Conditional Dosing in Pharmacometrics","text":"using Plots\nfunction dosing(du,u,p,t) \n  du[1] =-u[1]\n  if t==4.0 && u[1]<4.0\n      u[1]=u[1]+10.0\n  end\nend \nu0 = [10.0]\ntspan=(0.0,10.0)\nodeprob = ODEProblem(dosing,u0,tspan)\nsol=solve(odeprob,liqss2(),abstol=1e-3,reltol=1e-2)\np1=plot(sol);\nsavefig(p1, \"dosing---\")","category":"page"},{"location":"examples/dosing/","page":"Conditional Dosing in Pharmacometrics","title":"Conditional Dosing in Pharmacometrics","text":"(Image: dosingPharma)","category":"page"},{"location":"examples/dosing/","page":"Conditional Dosing in Pharmacometrics","title":"Conditional Dosing in Pharmacometrics","text":"The 2 conditions can be replaced by using another discrete variable p (flag) that is changed when t==4. This change triggers the check of  u[1] < 4.","category":"page"},{"location":"examples/dosing/","page":"Conditional Dosing in Pharmacometrics","title":"Conditional Dosing in Pharmacometrics","text":"using QuantizedSystemSolver\nfunction dosing(du,u,p,t) \n  du[1] =-u[1]\n  if t>4.0\n      p[1]=0.0\n  end\n  if p[1]+(4.0-u[1])>0.0\n      u[1]=u[1]+10.0\n      p[1]=-1e5\n  end\nend ","category":"page"},{"location":"examples/dosing/#Benchmarks","page":"Conditional Dosing in Pharmacometrics","title":"Benchmarks","text":"","category":"section"},{"location":"examples/dosing/","page":"Conditional Dosing in Pharmacometrics","title":"Conditional Dosing in Pharmacometrics","text":"Solver @btime\nliqss2 using @NLodeProblem 8.33 μs (44 allocations: 3.33 KiB)\nliqss2 using ODEProblem: 2.006 ms (3353 allocations: 196.96 KiB)\nRosenbrock23: 31.600 μs (355 allocations: 21.38 KiB)","category":"page"},{"location":"examples/dosing/","page":"Conditional Dosing in Pharmacometrics","title":"Conditional Dosing in Pharmacometrics","text":"Comparing the solve method, we get:","category":"page"},{"location":"examples/dosing/","page":"Conditional Dosing in Pharmacometrics","title":"Conditional Dosing in Pharmacometrics","text":"@btime sol=solve($odeprob,liqss2(),abstol=1e-3,reltol=1e-2)\n#8.300 μs (44 allocations: 3.34 KiB)\n@btime sol=solve($odeprob,Rosenbrock23(),abstol=1e-3,reltol=1e-2)\n#22.500 μs (251 allocations: 16.89 KiB)\n@btime sol=solve($odeprob,Tsit5(),abstol=1e-3,reltol=1e-2)\n#7.775 μs (165 allocations: 12.33 KiB)","category":"page"},{"location":"developer/integrator/#Integrators","page":"Integrators","title":"Integrators","text":"","category":"section"},{"location":"developer/integrator/","page":"Integrators","title":"Integrators","text":"QuantizedSystemSolver.integrate(alg::QSSAlgorithm{:qss,O}, commonQssData::CommonQSS_Data{0}, odep::ODEProblemData{F,PRTYPE,T,D,0,CS}, f::Function, jac::Function, SD::Function) where {F,PRTYPE,O,T,CS,D}   \n","category":"page"},{"location":"developer/integrator/#QuantizedSystemSolver.integrate-Union{Tuple{D}, Tuple{CS}, Tuple{T}, Tuple{O}, Tuple{PRTYPE}, Tuple{F}, Tuple{QSSAlgorithm{:qss, O}, CommonQSS_Data{0}, ODEProblemData{F, PRTYPE, T, D, 0, CS}, Function, Function, Function}} where {F, PRTYPE, O, T, CS, D}","page":"Integrators","title":"QuantizedSystemSolver.integrate","text":"integrate(alg::QSSAlgorithm{:qss,O}, commonQssData::CommonQSS_Data{0}, odep::ODEProblemData{F,PRTYPE,T,D,0,CS}, f::Function, jac::Function, SD::Function) where {F,PRTYPE,O,T,CS,D}\n\nIntegrates a nonlinear ordinary differential equation (ODE) problem using a Quantized State System (QSS) algorithm.\n\nArguments\n\nAl::QSSAlgorithm{:qss,O}: The QSS algorithm to be used for integration.\ncommonQssData::CommonQSS_Data{0}: Common data structure for QSS integration.\nodep::ODEProblemData{F,PRTYPE,T,0,0,CS}: The nonlinear ODE problem to be solved.\nf::Function: The function defining the ODE system.\njac::Function: The Jacobian dependency function of the ODE system.\nSD::Function: The state derivative dependency function.\n\nReturns\n\nA solution\n\n\n\n\n\n","category":"method"},{"location":"developer/integrator/","page":"Integrators","title":"Integrators","text":"QuantizedSystemSolver.integrate(alg::QSSAlgorithm{:qss,O}, commonQssData::CommonQSS_Data{Z}, odep::ODEProblemData{F,PRTYPE,T,D,Z,CS}, f::Function, jac::Function, SD::Function) where {F,PRTYPE,O,T,D,Z,CS}","category":"page"},{"location":"developer/integrator/#QuantizedSystemSolver.integrate-Union{Tuple{CS}, Tuple{Z}, Tuple{D}, Tuple{T}, Tuple{O}, Tuple{PRTYPE}, Tuple{F}, Tuple{QSSAlgorithm{:qss, O}, CommonQSS_Data{Z}, ODEProblemData{F, PRTYPE, T, D, Z, CS}, Function, Function, Function}} where {F, PRTYPE, O, T, D, Z, CS}","page":"Integrators","title":"QuantizedSystemSolver.integrate","text":"integrate(alg::QSSAlgorithm{:qss,O}, commonQssData::CommonQSS_Data{Z}, odep::ODEProblemData{F,PRTYPE,T,D,Z,CS}, f::Function, jac::Function, SD::Function) where {F,PRTYPE,O,T,D,Z,CS}\n\nIntegrates a nonlinear ordinary differential equation (ODE) problem with events using a Quantized State System (QSS) algorithm.\n\nArguments\n\nAl::QSSAlgorithm{:qss,O}: The QSS algorithm to be used for integration.\ncommonQssData::CommonQSS_Data{Z}: Common data structure for QSS algorithms.\nodep::ODEProblemData{F,PRTYPE,T,D,Z,CS}: The nonlinear ODE problem to be solved.\nf::Function: The function defining the ODE system.\njac::Function: The Jacobian dependency function of the ODE system.\nSD::Function: The state derivative dependency function.\n\nType Parameters\n\nPRTYPE: The type of the problem.\nO: The order of the QSS algorithm.\nT: The number of continuous variables.\nZ: The number of zero crossing functions.\nD: The number of discrete variables\nCS: The cache size.\n\nReturns\n\nA solution\n\n\n\n\n\n","category":"method"},{"location":"developer/integrator/","page":"Integrators","title":"Integrators","text":"QuantizedSystemSolver.integrate(alg::QSSAlgorithm{:liqss,O}, commonQssData::CommonQSS_Data{Z}, liqssdata::LiQSS_Data{O,M}, odep::ODEProblemData{F,PRTYPE,T,D,Z,CS}, f::Function, jac::Function, SD::Function, exactA::Function) where {F,PRTYPE,O,T,D,Z,CS,M} ","category":"page"},{"location":"developer/integrator/#QuantizedSystemSolver.integrate-Union{Tuple{M}, Tuple{CS}, Tuple{Z}, Tuple{D}, Tuple{T}, Tuple{O}, Tuple{PRTYPE}, Tuple{F}, Tuple{QSSAlgorithm{:liqss, O}, CommonQSS_Data{Z}, LiQSS_Data{O, M}, ODEProblemData{F, PRTYPE, T, D, Z, CS}, Function, Function, Function, Function}} where {F, PRTYPE, O, T, D, Z, CS, M}","page":"Integrators","title":"QuantizedSystemSolver.integrate","text":"integrate(alg::QSSAlgorithm{:liqss,O}, commonQssData::CommonQSS_Data{Z}, liqssdata::LiQSS_Data{O,M}, odep::ODEProblemData{F,PRTYPE,T,D,Z,CS}, f::Function, jac::Function, SD::Function, exactA::Function) where {F,PRTYPE,O,T,D,Z,CS,M}\n\nIntegrates a nonlinear ordinary differential equation (ODE) problem with events using the LiQSS (Linearized Quantized State System) algorithm.\n\nArguments\n\nAl::QSSAlgorithm{:liqss,O}: The QSS algorithm type for LiQSS.\ncommonQssData::CommonQSS_Data{Z}: Common data structure for QSS algorithms.\nliqssdata::LiQSS_Data{O,1}: Data structure specific to the LiQSS algorithm.\nodep::ODEProblemData{F,PRTYPE,T,D,Z,CS}: The nonlinear ODE problem to be solved.\nf::Function: The function defining the ODE system.\njac::Function: The Jacobian dependency function of the ODE system.\nSD::Function: The state derivative dependency function.\nexactA::Function: The exact jacobian expression function for the ODE system.\n\nReturns\n\nA solution after the integration process.\n\n\n\n\n\n","category":"method"},{"location":"developer/integrator/","page":"Integrators","title":"Integrators","text":"QuantizedSystemSolver.integrate(alg::QSSAlgorithm{:liqss,O}, commonQssData::CommonQSS_Data{0}, liqssdata::LiQSS_Data{O,M}, odep::ODEProblemData{F,PRTYPE,T,D,0,CS}, f::Function, jac::Function, SD::Function, exactA::Function) where {F,PRTYPE,CS,O,T,M,D}","category":"page"},{"location":"developer/integrator/#QuantizedSystemSolver.integrate-Union{Tuple{D}, Tuple{M}, Tuple{T}, Tuple{O}, Tuple{CS}, Tuple{PRTYPE}, Tuple{F}, Tuple{QSSAlgorithm{:liqss, O}, CommonQSS_Data{0}, LiQSS_Data{O, M}, ODEProblemData{F, PRTYPE, T, D, 0, CS}, Function, Function, Function, Function}} where {F, PRTYPE, CS, O, T, M, D}","page":"Integrators","title":"QuantizedSystemSolver.integrate","text":"integrate(alg::QSSAlgorithm{:liqss,O}, commonQssData::CommonQSS_Data{Z}, liqssdata::LiQSS_Data{O,M}, odep::ODEProblemData{F,PRTYPE,T,D,Z,CS}, f::Function, jac::Function, SD::Function, exactA::Function) where {F,PRTYPE,O,T,D,Z,CS,M}\n\nIntegrates a nonlinear ordinary differential equation (ODE) problem with events using the LiQSS (Linearized Quantized State System) algorithm.\n\nArguments\n\nAl::QSSAlgorithm{:liqss,O}: The QSS algorithm type for LiQSS.\ncommonQssData::CommonQSS_Data{Z}: Common data structure for QSS algorithms.\nliqssdata::LiQSS_Data{O,1}: Data structure specific to the LiQSS algorithm.\nodep::ODEProblemData{F,PRTYPE,T,D,Z,CS}: The nonlinear ODE problem to be solved.\nf::Function: The function defining the ODE system.\njac::Function: The Jacobian dependency function of the ODE system.\nSD::Function: The state derivative dependency function.\nexactA::Function: The exact jacobian expression function for the ODE system.\n\nReturns\n\nA solution after the integration process.\n\n\n\n\n\n","category":"method"},{"location":"developer/integrator/","page":"Integrators","title":"Integrators","text":"QuantizedSystemSolver.integrate(alg::QSSAlgorithm{:nmliqss,O}, commonQssData::CommonQSS_Data{Z}, liqssdata::LiQSS_Data{O,M}, odep::ODEProblemData{F,PRTYPE,T,D,Z,CS}, f::Function, jac::Function, SD::Function, exactA::Function) where {F,PRTYPE,O,T,D,Z,CS,M}\n\n","category":"page"},{"location":"developer/integrator/#QuantizedSystemSolver.integrate-Union{Tuple{M}, Tuple{CS}, Tuple{Z}, Tuple{D}, Tuple{T}, Tuple{O}, Tuple{PRTYPE}, Tuple{F}, Tuple{QSSAlgorithm{:nmliqss, O}, CommonQSS_Data{Z}, LiQSS_Data{O, M}, ODEProblemData{F, PRTYPE, T, D, Z, CS}, Function, Function, Function, Function}} where {F, PRTYPE, O, T, D, Z, CS, M}","page":"Integrators","title":"QuantizedSystemSolver.integrate","text":"integrate(alg::QSSAlgorithm{:nmliqss,O}, commonQssData::CommonQSS_Data{Z}, liqssdata::LiQSS_Data{O,M}, odep::ODEProblemData{F,PRTYPE,T,D,Z,CS}, f::Function, jac::Function, SD::Function, exactA::Function) where {F,PRTYPE,O,T,D,Z,CS,M}\n\nIntegrates a nonlinear ordinary differential equation (ODE) problem with events using the nmLiqss (modified Liqss that detect events) discrete integrator algorithm.\n\nArguments\n\nAl::QSSAlgorithm{:nmliqss,O}: The QSS algorithm type for nmLiqss.\ncommonQssData::CommonQSS_Data{Z}: Common QSS data structure.\nliqssdata::LiQSS_Data{O,M}: LiQSS data structure.\nodep::ODEProblemData{F,PRTYPE,T,D,Z,CS}: Nonlinear ODE problem to be solved.\nf::Function: The function defining the ODE system.\njac::Function: The Jacobian dependency function of the ODE system.\nSD::Function: The state derivative dependency function.\nexactA::Function: The exact jacobian expression function for the ODE system.\n\nReturns\n\nA solution.\n\n\n\n\n\n","category":"method"},{"location":"developer/integrator/","page":"Integrators","title":"Integrators","text":"QuantizedSystemSolver.integrate(alg::QSSAlgorithm{:nmliqss,O}, commonQssData::CommonQSS_Data{0}, liqssdata::LiQSS_Data{O,M}, odep::ODEProblemData{F,PRTYPE,T,D,0,CS}, f::Function, jac::Function, SD::Function, exactA::Function) where {F,PRTYPE,CS,O,T,D,M}\n                        ","category":"page"},{"location":"developer/integrator/#QuantizedSystemSolver.integrate-Union{Tuple{M}, Tuple{D}, Tuple{T}, Tuple{O}, Tuple{CS}, Tuple{PRTYPE}, Tuple{F}, Tuple{QSSAlgorithm{:nmliqss, O}, CommonQSS_Data{0}, LiQSS_Data{O, M}, ODEProblemData{F, PRTYPE, T, D, 0, CS}, Function, Function, Function, Function}} where {F, PRTYPE, CS, O, T, D, M}","page":"Integrators","title":"QuantizedSystemSolver.integrate","text":"integrate(alg::QSSAlgorithm{:nmliqss,O}, commonQssData::CommonQSS_Data{0}, liqssdata::LiQSS_Data{O,M}, odep::ODEProblemData{F,PRTYPE,T,D,0,CS}, f::Function, jac::Function, SD::Function, exactA::Function) where {F,PRTYPE,CS,O,T,D,M}\n\nIntegrates a nonlinear ordinary differential equation (ODE) problem (without events) using the nmLiqss (modified Liqss that detect events) algorithm.\n\nArguments\n\nAl::QSSAlgorithm{:nmliqss,O}: The QSS algorithm to be used for integration.\ncommonQssData::CommonQSS_Data{0}: Common data structure for QSS algorithms.\nliqssdata::LiQSS_Data{O,M}: Data specific to the LiQSS algorithm.\nodep::ODEProblemData{F,PRTYPE,T,0,0,CS}: The nonlinear ODE problem to be solved.\nf::Function: The function defining the ODE system.\njac::Function: The Jacobian dependency function of the ODE system.\nSD::Function: The state derivative dependency function.\nexactA::Function: The exact jacobian expression function for the ODE system.\n\nReturns\n\nA solution \n\n\n\n\n\n","category":"method"},{"location":"#QuantizedSystemSolver.jl","page":"Home","title":"QuantizedSystemSolver.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for solving systems of ODEs with events.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Statement-of-need","page":"Home","title":"Statement of need","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Traditional solvers are challenged by frequent discontinuities where the state of the system abruptly changes at specific points or intervals. They struggle to accurately capture the dynamics around discontinuities especially in large sparse and stiff systems. They either undergo expensive iterations to pinpoint exact discontinuity instances or resort to interpolating their locations, resulting in unreliable outcomes.  Written in the easy-to-learn Julia programming language,  and taking advantage of its features such as multiple dispatch and metaprogramming, the QuantizedSystemSolver.jl is a solver that aims to efficiently solve a set of Ordinary differential Equations with a set of events via implementing the QSS and LIQSS methods. It is the first such tool to be published in the Julia ecosystem.","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mongi Bellili, Belgian Royal Military Academy and Ku Leuven.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantizedSystemSolver is licensed under the MIT license; see LICENSE for the full license text.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantizedSystemSolver.jl is a registered package, and is simply installed by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia\n\njulia> ]\n\n(@v1.x) pkg> add QuantizedSystemSolver","category":"page"},{"location":"","page":"Home","title":"Home","text":"For new users, take a look at the Tutorial section. If you see something wrong, please open an issue","category":"page"},{"location":"","page":"Home","title":"Home","text":"For developpers, take a look at the Developer Guide section. The, if you have an idea, do a pull request!","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DifferentialEquations.jl: Differential Equations solver using classic integration methods.\nQuantizedStateSystems.jl: julia qss-solver\nqss-solver: C qss-solver","category":"page"},{"location":"examples/tysonModel/#The-Tyson-Model","page":"The Tyson Model","title":"The Tyson Model","text":"","category":"section"},{"location":"examples/tysonModel/","page":"The Tyson Model","title":"The Tyson Model","text":"This is a model that is of a great interest in the field of biology. The Tyson model describes the mechanism of a cell: the division, the growth, and the interactions amongst its components. The model contains six components (C2CPpMMYYP), which are the variables of the following system of equations:","category":"page"},{"location":"examples/tysonModel/","page":"The Tyson Model","title":"The Tyson Model","text":"beginalign*\n fracC2dt=k_6 M-k_8 C2 + k_9 CPnonumber\n fracCPdt=k_3 CP Y+ k_8 C2 - k_9 CPnonumber\n fracpMdt=k_3 CP Y- pM (k_10+k_4 fracM(C2+CP+pM+M))^2 + k_5 Mnonumber\n fracMdt= pM (k_10+k_4 fracM(C2+CP+pM+M))^2 + k_5 M -k_6 Mnonumber\n fracYdt= k_1-k_2 Y -k_3 CP Ynonumber\n fracYPdt= k_6 M-k_7 YP\nendalign*","category":"page"},{"location":"examples/tysonModel/","page":"The Tyson Model","title":"The Tyson Model","text":"where k_i are parameters, and the model variation that was tested in this article uses these values: k_1=0015k_2=0k_3=200k_4=180k_5=0k_6=1k_7=06k_8=10^6k_9=10^3k_10=0018. see [1] and [2] for more details.","category":"page"},{"location":"examples/tysonModel/","page":"The Tyson Model","title":"The Tyson Model","text":"The QuantizedSystemSolver code to solve this system:","category":"page"},{"location":"examples/tysonModel/","page":"The Tyson Model","title":"The Tyson Model","text":"using QuantizedSystemSolver\nfunction tyson(du,u,p,t)\n    k_1=0.015;k_3=200.0;k_4=180.0;k_7=0.6;k_8=1e6;k_9=1e3;k_10=0.018\n    du[1] = u[4]-k_8*u[1]+k_9*u[2]\n    du[2] =-k_3*u[2]*u[5]+k_8*u[1]-k_9*u[2]\n    du[3] = k_3*u[2]*u[5]-u[3]*(k_10+k_4*(u[4]/(u[1]+u[2]+u[3]+u[4]))^2)\n    du[4] =u[3]*(k_10+k_4*(u[4]/(u[1]+u[2]+u[3]+u[4]))^2)-u[4]\n    du[5] = k_1-k_3*u[2]*u[5]\n    du[6] =u[4]-k_7*u[6]\nend\nu0 = [0.0,0.75,0.25,0.0,0.0,0.0];tspan=(0.0,25.0)\n#Construct the problem\nodeprob = ODEProblem(tyson,u0,tspan)\n#Solve the problem\nsol=solve(odeprob,nmliqss2())\np1=plot(sol);\nsavefig(p1, \"tyson_$(nmliqss2())\") ","category":"page"},{"location":"examples/tysonModel/","page":"The Tyson Model","title":"The Tyson Model","text":"Replace nmliqss2 by ABDF2() from the DifferentialEquations.jl, to obtain the following plots.","category":"page"},{"location":"examples/tysonModel/","page":"The Tyson Model","title":"The Tyson Model","text":"(Image: plot_tyson_nmliqss2) (Image: plot_tyson_abdf)","category":"page"},{"location":"examples/tysonModel/#refs5","page":"The Tyson Model","title":"References","text":"","category":"section"},{"location":"examples/tysonModel/","page":"The Tyson Model","title":"The Tyson Model","text":"[1] J. Tyson. Modeling the cell division cycle: cdc2 and cyclin interactions. Proceedings of the National Academy of Sciences, vol.88:pp.7328–7332, 1991.","category":"page"},{"location":"examples/tysonModel/","page":"The Tyson Model","title":"The Tyson Model","text":"[2]  F. Pietro, G. Migoni, and E. Kofman. Improving linearly implicit quantized state system methods. Simulation: Transactions of the Society for Modeling and Simulation International, vol.95(no.2):pp.127–144, 2019.","category":"page"}]
}
