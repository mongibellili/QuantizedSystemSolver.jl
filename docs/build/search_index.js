var documenterSearchIndex = {"docs":
[{"location":"dependencies/#Dependencies","page":"Dependencies","title":"Dependencies","text":"","category":"section"},{"location":"dependencies/","page":"Dependencies","title":"Dependencies","text":"In addition, the package contains several shared helper functions used during the integration process by the algorithm such as the scheduler that organizes which variable of the system to update at any specific time of the simulation. The solver uses other packages such as MacroTools for user-code parsing, SymEngine for Jacobian computation and dependencies extraction, and a modified TaylorSeries that uses caching to obtain free Taylor variable operations as the current version of TaylorSeries creates a heap allocated object for every operation. The approximation through Taylor variables transforms any complicated equations to polynomials, which makes root finding cheaper, which the QSS methods relies heavily on it.","category":"page"},{"location":"dependencies/#MacroTools","page":"Dependencies","title":"MacroTools","text":"","category":"section"},{"location":"dependencies/","page":"Dependencies","title":"Dependencies","text":"MacroTools offers a comprehensive library of tools for manipulating Julia expressions, enabling deep code transformations through features such as ð‘ð‘œð‘ ð‘¡ð‘¤ð‘Žð‘™ð‘˜ and @ð‘ð‘Žð‘ð‘¡ð‘¢ð‘Ÿð‘’. The ð‘ð‘œð‘ ð‘¡ð‘¤ð‘Žð‘™ð‘˜ function plays a pivotal role within the NLodeProblem function, particularly for user code parsing. By systematically traversing each operation, ð‘ð‘œð‘ ð‘¡ð‘¤ð‘Žð‘™ð‘˜ allows the code to recognize and differentiate between symbols. For instance, it is crucial for integrating parameters and helper functions directly into the equations. Furthermore, ð‘ð‘œð‘ ð‘¡ð‘¤ð‘Žð‘™ð‘˜ is used to traverse both the right-hand side of differential equations and zero-crossing functions, facilitating the construction of the Jacobian matrix and identifying variable dependencies. It also transforms specific expressions like ð‘ž[1] into ð‘ž[1] [0] within events, and converts ð‘ž[ð‘–] to ð‘žð‘–, making the equations more tractable for differentiation and Jacobian construction. Additionally, the @ð‘ð‘Žð‘ð‘¡ð‘¢ð‘Ÿð‘’ function efficiently handles the case where differential equations are defined as expressions within a for loop, ensuring smooth parsing and processing of these equations. The ability to transform and capture expressions ensures that user-defined code is processed efficiently, making MacroTools an indispensable component in the QSS solver workflow.","category":"page"},{"location":"dependencies/#SymEngine","page":"Dependencies","title":"SymEngine","text":"","category":"section"},{"location":"dependencies/","page":"Dependencies","title":"Dependencies","text":"SymEngine is a high-performance symbolic manipulation library designed for efficient mathematical computations. A key feature of SymEngine is its ability to convert expressions into a symbolic form using the convert(Basic, m) function, where m is typically an expression, such as the right-hand side of a differential equation. This conversion transforms the expression into a Basic type, which is a fundamental structure in SymEngine for symbolic computation. Once the expression is in Basic form, the diff(basi, symarg) function can be applied to perform symbolic differentiation, where basi is the converted expression and symarg is the symbol with respect to which the derivative is taken. This returns the partial derivative of the expression, making it particularly useful for deriving system Jacobians. SymEngineâ€™s ability to handle symbolic differentiation with speed and accuracy makes it an essential tool in Jacobian computation for the QSS solver.","category":"page"},{"location":"dependencies/#Taylor-Variables","page":"Dependencies","title":"Taylor Variables","text":"","category":"section"},{"location":"dependencies/","page":"Dependencies","title":"Dependencies","text":"In the quantized system solver, and similar to the Taylor struct from the package TaylorSeries.jl, the Taylor0 struct serves as a convenient representation of Taylor series approximations. Each instance encapsulates an array of coefficients, which correspond to the Taylor series expansion, along with an order indicating the degree of the expansion. This structure allows for efficient storage of state values and their derivatives, as the first coefficient represents the variable value, while subsequent coefficients represent higher-order derivatives. The use of Taylor variables enables the computation of derivatives for complex expressions seamlessly, enhancing the solverâ€™s capability to analyze and simulate dynamic systems. The implementation includes various constructors and methods to manipulate and evaluate the Taylor series, ensuring that users can easily derive the necessary values from the stored Taylor variables, thus facilitating precise calculations of system behavior over time. New functions are created to match each old function but with a different name and added caches in the parameters. These new functions are designed to optimize performance by avoiding memory allocation during their execution. This is achieved through careful design and implementation of the functions, where arithmetic operations and mathematical functions leverage the existing cached data rather than creating new instances of taylor variables. In addition, the old Taylor is kept, with minimum functionalities, as a fallback in case there is an expression that does not use the available cache vector. As a result, this approach enhances the efficiency of the Taylor variable framework, making it more suitable for complex simulations and calculations without sacrificing flexibility or usability.","category":"page"},{"location":"dependencies/","page":"Dependencies","title":"Dependencies","text":"arithmetic operations: The provided code introduces personalized arithmetic operations that optimize performance by eliminating memory allocation during calculations. Functions such as addsub, subsub, and mulT are designed to operate directly on existing data structures, utilizing a caching mechanism to store intermediate results. This is in stark contrast to traditional arithmetic operations that typically allocate memory with each computation, creating overhead and potentially slowing down performance in computationally intensive tasks. The previous approach required reallocation for each arithmetic operation, leading to inefficiencies when processing large datasets or performing numerous calculations. mathematical functions: Similar to arithmetic operations, new mathematical functions are designed to leverage in-place operations, which reduces the overhead associated with creating new memory for intermediate results. For instance, functions like exp, log, sin, and cos, sqrt, power iterate over the input Taylor series and apply the corresponding operation without allocating additional arrays. By implementing these new methods, the code significantly reduces the number of allocations, improving both execution speed and resource management, while still maintaining the flexibility and functionality required for complex mathematical operations. transformation of expressions: The transformF function is designed to translate userdefined mathematical expressions into optimized forms that leverage the custom arithmetic and function implementations. By traversing the expression tree with the prewalk function, it identifies operations such as addition, subtraction, multiplication, division, and specific mathematical functions (like exponential and logarithmic functions). For each identified operation, the code modifies the expression to call specialized versions (e.g., subT, addT, mulT) that avoid memory allocation, enhancing performance during calculations. Additionally, it tracks the number of caches needed for these operations, which are essential for efficient computation of Taylor series. Each time a transformation occurs, a reference to a cache is added, ensuring that a necessary cache is available for the optimized functions. This systematic approach effectively restructures the original expressions, maintaining their functionality while improving computational efficiency by reducing unnecessary allocations.","category":"page"},{"location":"interface/#Application-Programming-Interface","page":"Application Programming Interface","title":"Application Programming Interface","text":"","category":"section"},{"location":"interface/","page":"Application Programming Interface","title":"Application Programming Interface","text":"NLodeProblem(odeExprs) ","category":"page"},{"location":"interface/#QuantizedSystemSolver.NLodeProblem-Tuple{Any}","page":"Application Programming Interface","title":"QuantizedSystemSolver.NLodeProblem","text":"NLodeProblem(odeExprs)  This function parses the user code to dispatches on a specific problem construction. It returns a Problem object to be passed to the solve function.\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"Application Programming Interface","title":"Application Programming Interface","text":"solve(prob::NLODEProblem{PRTYPE,T,Z,D,CS},al::QSSAlgorithm{SolverType, OrderType},tspan::Tuple{Float64, Float64};sparsity::Val{Sparsity}=Val(false),saveat=1e-9::Float64,abstol=1e-4::Float64,reltol=1e-3::Float64,maxErr=Inf::Float64,maxStepsAllowed=10000000) where{PRTYPE,T,Z,D,CS,SolverType,OrderType,Sparsity}     ","category":"page"},{"location":"interface/#QuantizedSystemSolver.solve-Union{Tuple{Sparsity}, Tuple{OrderType}, Tuple{SolverType}, Tuple{CS}, Tuple{D}, Tuple{Z}, Tuple{T}, Tuple{PRTYPE}, Tuple{NLODEProblem{PRTYPE, T, Z, D, CS}, QSSAlgorithm{SolverType, OrderType}, Tuple{Float64, Float64}}} where {PRTYPE, T, Z, D, CS, SolverType, OrderType, Sparsity}","page":"Application Programming Interface","title":"QuantizedSystemSolver.solve","text":"solve(prob::NLODEProblem{PRTYPE,T,Z,D,CS},al::QSSAlgorithm{SolverType, OrderType},tspan::Tuple{Float64, Float64};sparsity::Val{Sparsity}=Val(false),saveat=1e-9::Float64,abstol=1e-4::Float64,reltol=1e-3::Float64,maxErr=Inf::Float64,maxStepsAllowed=10000000) where{PRTYPE,T,Z,D,CS,SolverType,OrderType,Sparsity}  \n\nThis function dispatches on a specific integrator based on the algorithm provided. With the exception of the argument prob and tspan, all other arguments are optional and have default values:\n\n-The algorithm defaults to nmliqss2, and it is specified by the QSSAlgorithm type, which is a composite type that has a name and an order. It can be extended independently of the solver.\n\n-The sparsity argument defaults to false. If true, the integrator will use a sparse representation of the Jacobian matrix (not implemented).\n\n-The saveat argument defaults to 1e-9. It specifies the time step at which the integrator will save the solution (not implemented).\n\n-The abstol argument defaults to 1e-4. It specifies the absolute tolerance of the integrator.\n\n-The reltol argument defaults to 1e-3. It specifies the relative tolerance of the integrator.\n\n-The maxErr argument defaults to Inf. It specifies the maximum error allowed by the integrator. This is used as an upper bound for the quantum when a variable goes large.\n\n-The maxStepsAllowed argument defaults to 10000000. It specifies the maximum number of steps allowed by the integrator. If the user wants to extend the limit on the maximum number of steps, this argument can be used.\n\nAfter the simulation, the solution is returned as a Solution object.\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"Application Programming Interface","title":"Application Programming Interface","text":"plot_Sol(sol::Sol{T,O},xvars::Int...;note=\" \"::String,xlims=(0.0,0.0)::Tuple{Float64, Float64},ylims=(0.0,0.0)::Tuple{Float64, Float64},legend=:true::Bool,marker=:circle::Symbol) where{T,O}","category":"page"},{"location":"interface/#QuantizedSystemSolver.plot_Sol-Union{Tuple{O}, Tuple{T}, Tuple{Sol{T, O}, Vararg{Int64}}} where {T, O}","page":"Application Programming Interface","title":"QuantizedSystemSolver.plot_Sol","text":"plot_Sol(sol::Sol{T,O},xvars::Int...;note=\" \"::String,xlims=(0.0,0.0)::Tuple{Float64, Float64},ylims=(0.0,0.0)::Tuple{Float64, Float64},legend=:true::Bool,marker=:circle::Symbol) where{T,O}\n\nThis function generates a plot of the solution of the system (returned as a plot object).     With the exception of the solution object, all arguments are optional.   The default values are:\n\nnote = \" \"\nxlims = (0.0,0.0)\nylims = (0.0,0.0)\nlegend = true\nmarker=:circle\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"Application Programming Interface","title":"Application Programming Interface","text":"save_Sol(sol::Sol{T,O},xvars::Int...;note=\" \"::String,xlims=(0.0,0.0)::Tuple{Float64, Float64},ylims=(0.0,0.0)::Tuple{Float64, Float64},legend=:true::Bool) where{T,O}","category":"page"},{"location":"interface/#QuantizedSystemSolver.save_Sol-Union{Tuple{O}, Tuple{T}, Tuple{Sol{T, O}, Vararg{Int64}}} where {T, O}","page":"Application Programming Interface","title":"QuantizedSystemSolver.save_Sol","text":"save_Sol(sol::Sol{T,O},xvars::Int...;note=\" \"::String,xlims=(0.0,0.0)::Tuple{Float64, Float64},ylims=(0.0,0.0)::Tuple{Float64, Float64},legend=:true::Bool) where{T,O}\n\nSave the plot of the system solution for the variables xvars.   With the exception of the solution object, all arguments are optional.   The default values are:\n\nnote = \" \"\nxlims = (0.0,0.0)\nylims = (0.0,0.0)\nlegend = true\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"Application Programming Interface","title":"Application Programming Interface","text":"getError(sol::Sol{T,O},index::Int,f::Function) where{T,O}","category":"page"},{"location":"interface/#QuantizedSystemSolver.getError-Union{Tuple{O}, Tuple{T}, Tuple{Sol{T, O}, Int64, Function}} where {T, O}","page":"Application Programming Interface","title":"QuantizedSystemSolver.getError","text":"getError(sol::Sol{T,O},index::Int,f::Function) where{T,O}\n\nThis function calculates the relative error of the solution with respect to a reference function.\n\n\n\n\n\n","category":"method"},{"location":"interface/","page":"Application Programming Interface","title":"Application Programming Interface","text":"getAverageErrorByRefs(sol::Sol{T,O},solRef::Vector{Any}) where{T,O}","category":"page"},{"location":"interface/#QuantizedSystemSolver.getAverageErrorByRefs-Union{Tuple{O}, Tuple{T}, Tuple{Sol{T, O}, Vector{Any}}} where {T, O}","page":"Application Programming Interface","title":"QuantizedSystemSolver.getAverageErrorByRefs","text":"getAverageErrorByRefs(sol::Sol{T,O},solRef::Vector{Any}) where{T,O}\n\nThis function calculates the average relative error of the solution with respect to a reference solution.   The relative error is calculated for each variable, and then it is averaged over all variables.\n\n\n\n\n\n","category":"method"},{"location":"algorithmDev/#Algorithm-Extension","page":"Algorithm Extension","title":"Algorithm Extension","text":"","category":"section"},{"location":"algorithmDev/","page":"Algorithm Extension","title":"Algorithm Extension","text":"Currently only QSS1,2,3 ; LiQSS1,2,3 ; and mLiQSS1,2,3 exist. Any new algorithm can be added via the name N which is of type Val, with O is the order which also of type Val. For example qss1 is created by:","category":"page"},{"location":"algorithmDev/","page":"Algorithm Extension","title":"Algorithm Extension","text":"qss1()=QSSAlgorithm(Val(:qss),Val(1))","category":"page"},{"location":"algorithmDev/","page":"Algorithm Extension","title":"Algorithm Extension","text":" QuantizedSystemSolver.ALGORITHM{N,O}","category":"page"},{"location":"algorithmDev/#QuantizedSystemSolver.ALGORITHM","page":"Algorithm Extension","title":"QuantizedSystemSolver.ALGORITHM","text":"ALGORITHM{N,O} This is superclass for all QSS algorithms. It is parametric on these:\n\n- The name of the algorithm N\n\n- The order of the algorithm O\n\n\n\n\n\n","category":"type"},{"location":"userGuide/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"userGuide/#Solving-a-Nonlinear-ODE-Problem-with-NLodeProblem-in-Julia","page":"Tutorial","title":"Solving a Nonlinear ODE Problem with NLodeProblem in Julia","text":"","category":"section"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we will go through the process of setting up, solving, querying, and plotting a nonlinear ordinary differential equation (ODE) problem using the NLodeProblem function. We will use a buck converter circuit model as an example.","category":"page"},{"location":"userGuide/#Step-1:-Define-the-ODE-Problem","page":"Tutorial","title":"Step 1: Define the ODE Problem","text":"","category":"section"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"The first step is to define the ODE problem using the NLodeProblem function. We provide the function with user code that specifies the parameters, variables, and differential equations. Here is the example code for a buck converter circuit model with detailed explanations:","category":"page"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"odeprob = NLodeProblem(quote\n    name = (buck,) # Define the name of the problem for identification\n    \n    # Parameters\n    C = 1e-4          # Capacitance in farads\n    L = 1e-4          # Inductance in henrys\n    R = 10.0          # Resistance in ohms\n    U = 24.0          # Input voltage in volts\n    T = 1e-4          # Switching period in seconds\n    DC = 0.5          # Duty cycle\n    ROn = 1e-5        # On-state resistance of the switch in ohms\n    ROff = 1e5        # Off-state resistance of the switch in ohms\n    \n    # Discrete and continuous variables\n    discrete = [1e5, 1e-5, 1e-4, 0.0, 0.0] # Initial discrete states\n    u = [0.0, 0.0]                        # Initial continuous states\n    \n    # Rename for convenience\n    rd = discrete[1]       # Diode resistance\n    rs = discrete[2]       # Switch resistance\n    nextT = discrete[3]    # Next switching time\n    lastT = discrete[4]    # Last switching time\n    diodeon = discrete[5]  # Diode state (on/off)\n    il = u[1]              # Inductor current\n    uc = u[2]              # Capacitor voltage\n    \n    # Helper equations\n    id = (il * rs - U) / (rd + rs)  # Diode current calculation\n    \n    # Differential equations\n    du[1] = (-id * rd - uc) / L     # Derivative of inductor current\n    du[2] = (il - uc / R) / C       # Derivative of capacitor voltage\n    \n    # Events\n    if t - nextT > 0.0 \n        lastT = nextT             # Update last switching time\n        nextT = nextT + T         # Schedule next switching time\n        rs = ROn                  # Set switch to on-state\n    end\n    \n    if t - lastT - DC * T > 0.0 \n        rs = ROff                 # Set switch to off-state\n    end\n    \n    if diodeon * id + (1.0 - diodeon) * (id * rd - 0.6) > 0\n        rd = ROn                  # Diode is on\n        diodeon = 1.0\n    else\n        rd = ROff                 # Diode is off\n        diodeon = 0.0\n    end\nend)","category":"page"},{"location":"userGuide/#Explanation:","page":"Tutorial","title":"Explanation:","text":"","category":"section"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"Parameters: These are constants used in the model. C, L, R, U, T, DC, ROn, ROff are physical constants related to the buck converter circuit.\nDiscrete and continuous variables: These represent the initial states of discrete and continuous variables in the model.\nRenaming variables: For convenience, the elements of discrete and u are renamed to more descriptive variable names (rd, rs, nextT, lastT, diodeon, il, uc).\nHelper equations: These are intermediate expressions needed for the differential equations. id is the current through the diode.\nDifferential equations: These represent the system's dynamics. du[1] is the rate of change of the inductor current. du[2] is the rate of change of the capacitor voltage.\nEvents: These are conditions that modify the continous and discrete variables. They handle the switching behavior of the buck converter and the diode's state transitions.","category":"page"},{"location":"userGuide/#Step-2:-Solve-the-ODE-Problem","page":"Tutorial","title":"Step 2: Solve the ODE Problem","text":"","category":"section"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"Next, we solve the ODE problem using the solve function. We need to specify the problem, the algorithm, and the simulation settings.","category":"page"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"# Define the time span for the simulation\ntspan = (0.0, 0.001)  # Start at 0 seconds, end at 0.001 seconds\n# Solve the ODE problem with the chosen algorithm and settings\nsol = solve(odeprob, nmliqss2(), tspan, abstol=1e-4, reltol=1e-3)","category":"page"},{"location":"userGuide/#Explanation:-2","page":"Tutorial","title":"Explanation:","text":"","category":"section"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"Time span: tspan defines the interval over which the solution is computed, from 0.0 to 0.001 seconds.\nSolver function: solve is used to compute the solution.\nodeprob is the ODE problem we defined.\nnmliqss2() specifies the algorithm used to solve the problem (e.g., qss2,nmliqss1... might be other algorithms).\nabstol and reltol are the absolute and relative tolerances for the solver, controlling the accuracy of the solution.","category":"page"},{"location":"userGuide/#Step-3:-Query-the-Solution","page":"Tutorial","title":"Step 3: Query the Solution","text":"","category":"section"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"After solving the problem, we can query the solution to extract useful information such as variable values at specific times, the number of steps, events, and more.","category":"page"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"# Get the value of variable 2 at time 0.0005\nvalue_at_time = sol(2, 0.0005)\n\n# Get the total number of steps to end the simulation\ntotal_steps = sol.totalSteps\n\n# Get the number of simultaneous steps during the simulation\nsimul_step_count = sol.simulStepCount\n\n# Get the total number of events during the simulation\nevent_count = sol.evCount\n\n# Get the saved times and variables\nsaved_times = sol.savedTimes\nsaved_vars = sol.savedVars\n\n# Print the results\nprintln(\"Value of variable 2 at time 0.0005: \", value_at_time)\nprintln(\"Total number of steps: \", total_steps)\nprintln(\"Number of simultaneous steps: \", simul_step_count)\nprintln(\"Total number of events: \", event_count)","category":"page"},{"location":"userGuide/#Explanation:-3","page":"Tutorial","title":"Explanation:","text":"","category":"section"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"Value of variable 2 at a specific time: sol(2, 0.0005) returns the value of the second variable (capacitor voltage uc) at time 0.0005 seconds. Total steps: sol.totalSteps gives the total number of steps taken by the solver to reach the end of the simulation.\nSimultaneous steps: sol.simulStepCount provides the number of steps where simultaneous updates occurred.\nTotal events: sol.evCount gives the total number of events (e.g., switch state changes) during the simulation.\nSaved times and variables: sol.savedTimes and sol.savedVars store the time points and corresponding variable values computed during the simulation.","category":"page"},{"location":"userGuide/#Step-4:-Plot-the-Solution","page":"Tutorial","title":"Step 4: Plot the Solution","text":"","category":"section"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"Finally, we can plot the solution to visualize the results. We have two options: generate a plot object for further customization or save the plot directly to a file.","category":"page"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"# Generate a plot object for all variables of the solution\nplot_obj = plot_Sol(sol)\n# Generate a plot object for variable 1 of the solution\nplot_Sol(sol,1)\n# Display the plot\ndisplay(plot_obj)\n\n\n#plot  variables 1 and 2 of the solution\nplot_Sol(sol,1,2,note=\" \",xlims=(0.0,1.0),ylims=(-0.5,0.5),legend=false) \n#plot  the sum of variables 1 and 2 of the solution\nplot_SolSum(sol,1,2)\n\n# Save the plot to a file\nsave_Sol(sol, note=\" \",xlims=(0.0,1.0),ylims=(-0.5,0.5),legend=false)\n","category":"page"},{"location":"userGuide/#Explanation:-4","page":"Tutorial","title":"Explanation:","text":"","category":"section"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"Generate plot object: plotSol(sol) creates a plot object from the solution data. Display the plot: display(plotobj) shows the plot in the current environment. Save the plot: save_Sol(sol, ...) saves the plot to a file *.png.","category":"page"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"(Image: plot_buck_qss2)","category":"page"},{"location":"userGuide/#User-Documentation","page":"Tutorial","title":"User Documentation","text":"","category":"section"},{"location":"userGuide/","page":"Tutorial","title":"Tutorial","text":"More about the user documentation can be found in:","category":"page"},{"location":"userGuide/#[Application-Programming-Interface](@ref)","page":"Tutorial","title":"Application Programming Interface","text":"","category":"section"},{"location":"userGuide/#[Available-Algorithms](@ref)","page":"Tutorial","title":"Available Algorithms","text":"","category":"section"},{"location":"Taylor0/#Taylor0","page":"Taylor0","title":"Taylor0","text":"","category":"section"},{"location":"Taylor0/","page":"Taylor0","title":"Taylor0","text":"These are just some examples. Taylor0 is defined for many other functions. However, other functions can also be added.","category":"page"},{"location":"Taylor0/","page":"Taylor0","title":"Taylor0","text":"Taylor0","category":"page"},{"location":"Taylor0/#QuantizedSystemSolver.Taylor0","page":"Taylor0","title":"QuantizedSystemSolver.Taylor0","text":"Taylor0 A struct that defines a Taylor Variable. It has the following fields:\n\n- coeffs: An array of Float64 that holds the coefficients of the Taylor series\n\n- order: The order of the Taylor series\n\n\n\n\n\n","category":"type"},{"location":"Taylor0/","page":"Taylor0","title":"Taylor0","text":"createT(a::T,cache::Taylor0) where {T<:Number}","category":"page"},{"location":"Taylor0/#QuantizedSystemSolver.createT-Union{Tuple{T}, Tuple{T, Taylor0}} where T<:Number","page":"Taylor0","title":"QuantizedSystemSolver.createT","text":"createT(a::T,cache::Taylor0) where {T<:Number}\n\ncreates a Taylor0 from a constant. In case of order 2, cache=[a,0,0]\n\n\n\n\n\n","category":"method"},{"location":"Taylor0/","page":"Taylor0","title":"Taylor0","text":"addT(a::Taylor0, b::Taylor0,cache::Taylor0) ","category":"page"},{"location":"Taylor0/#QuantizedSystemSolver.addT-Tuple{Taylor0, Taylor0, Taylor0}","page":"Taylor0","title":"QuantizedSystemSolver.addT","text":"addT(a::Taylor0, b::Taylor0,cache::Taylor0)  cache=a+b\n\n\n\n\n\n","category":"method"},{"location":"Taylor0/","page":"Taylor0","title":"Taylor0","text":"subT(a::Taylor0, b::Taylor0,cache::Taylor0)","category":"page"},{"location":"Taylor0/#QuantizedSystemSolver.subT-Tuple{Taylor0, Taylor0, Taylor0}","page":"Taylor0","title":"QuantizedSystemSolver.subT","text":"subT(a::Taylor0, b::Taylor0,cache::Taylor0) cache=a-b\n\n\n\n\n\n","category":"method"},{"location":"Taylor0/","page":"Taylor0","title":"Taylor0","text":"mulT(a::Taylor0, b::Taylor0,cache1::Taylor0)","category":"page"},{"location":"Taylor0/#QuantizedSystemSolver.mulT-Tuple{Taylor0, Taylor0, Taylor0}","page":"Taylor0","title":"QuantizedSystemSolver.mulT","text":"mulT(a::Taylor0, b::Taylor0,cache1::Taylor0)  cache1=a*b\n\n\n\n\n\n","category":"method"},{"location":"Taylor0/","page":"Taylor0","title":"Taylor0","text":"divT(a::Taylor0, b::Taylor0,cache1::Taylor0) ","category":"page"},{"location":"Taylor0/#QuantizedSystemSolver.divT-Tuple{Taylor0, Taylor0, Taylor0}","page":"Taylor0","title":"QuantizedSystemSolver.divT","text":"divT(a::Taylor0, b::Taylor0,cache1::Taylor0)  cache1=a/b\n\n\n\n\n\n","category":"method"},{"location":"Taylor0/","page":"Taylor0","title":"Taylor0","text":"addsub(a::Taylor0, b::Taylor0,c::Taylor0,cache::Taylor0) ","category":"page"},{"location":"Taylor0/#QuantizedSystemSolver.addsub-NTuple{4, Taylor0}","page":"Taylor0","title":"QuantizedSystemSolver.addsub","text":"addsub(a::Taylor0, b::Taylor0,c::Taylor0,cache::Taylor0)     cache=a+b-c\n\n\n\n\n\n","category":"method"},{"location":"Taylor0/","page":"Taylor0","title":"Taylor0","text":"addsub(a::T, b::Taylor0,c::Taylor0,cache::Taylor0) where {T<:Number} ","category":"page"},{"location":"Taylor0/#QuantizedSystemSolver.addsub-Union{Tuple{T}, Tuple{T, Taylor0, Taylor0, Taylor0}} where T<:Number","page":"Taylor0","title":"QuantizedSystemSolver.addsub","text":"addsub(a::T, b::Taylor0,c::Taylor0,cache::Taylor0) where {T<:Number}    Order2 case: cache=[a+b[0]-c[0],b[1]-c[1],b[2]-c[2]]\n\n\n\n\n\n","category":"method"},{"location":"Taylor0/","page":"Taylor0","title":"Taylor0","text":"negateT(a::Taylor0,cache::Taylor0)","category":"page"},{"location":"Taylor0/#QuantizedSystemSolver.negateT-Tuple{Taylor0, Taylor0}","page":"Taylor0","title":"QuantizedSystemSolver.negateT","text":"negateT(a::Taylor0,cache::Taylor0) cache=-a\n\n\n\n\n\n","category":"method"},{"location":"Taylor0/","page":"Taylor0","title":"Taylor0","text":"subsub(a::Taylor0, b::Taylor0,c::Taylor0,cache::Taylor0) ","category":"page"},{"location":"Taylor0/#QuantizedSystemSolver.subsub-NTuple{4, Taylor0}","page":"Taylor0","title":"QuantizedSystemSolver.subsub","text":"subsub(a::Taylor0, b::Taylor0,c::Taylor0,cache::Taylor0)  cache=a-b-c\n\n\n\n\n\n","category":"method"},{"location":"Taylor0/","page":"Taylor0","title":"Taylor0","text":"muladdT(a::P,b::Q,c::R,cache1::Taylor0) where {P,Q,R <:Union{Taylor0,Number}}","category":"page"},{"location":"Taylor0/#QuantizedSystemSolver.muladdT-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{P, Q, R, Taylor0}} where {P, Q, R<:Union{Number, Taylor0}}","page":"Taylor0","title":"QuantizedSystemSolver.muladdT","text":"muladdT(a::P,b::Q,c::R,cache1::Taylor0) where {P,Q,R <:Union{Taylor0,Number}} cache1=a*b+c\n\n\n\n\n\n","category":"method"},{"location":"Taylor0/","page":"Taylor0","title":"Taylor0","text":"mulsub(a::P,b::Q,c::R,cache1::Taylor0) where {P,Q,R <:Union{Taylor0,Number}}","category":"page"},{"location":"Taylor0/#QuantizedSystemSolver.mulsub-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{P, Q, R, Taylor0}} where {P, Q, R<:Union{Number, Taylor0}}","page":"Taylor0","title":"QuantizedSystemSolver.mulsub","text":"mulsub(a::P,b::Q,c::R,cache1::Taylor0) where {P,Q,R <:Union{Taylor0,Number}} cache1=a*b-c\n\n\n\n\n\n","category":"method"},{"location":"developerGuide/#Developer-Guide","page":"Developer Guide","title":"Developer Guide","text":"","category":"section"},{"location":"developerGuide/","page":"Developer Guide","title":"Developer Guide","text":"While the package is optimized to be fast, extensibility is not compromised. It is divided into 3 entities that can be extended separately: Problem, Algorithm, and Solution. The package uses other packages such as MacroTools.jl for user-code parsing, SymEngine.jl for Jacobian computation, and a modified TaylorSeries.jl that uses caching to obtain free Taylor variables. The approximation through Taylor variables transforms any complicated equations to polynomials, which makes root finding cheaper.","category":"page"},{"location":"developerGuide/#[Implementation-](@ref)","page":"Developer Guide","title":"Implementation ","text":"","category":"section"},{"location":"developerGuide/#[Dependencies-](@ref)","page":"Developer Guide","title":"Dependencies ","text":"","category":"section"},{"location":"developerGuide/#[Algorithm-Extension-](@ref)","page":"Developer Guide","title":"Algorithm Extension ","text":"","category":"section"},{"location":"developerGuide/#[Algorithm-Extension-](@ref)-2","page":"Developer Guide","title":"Algorithm Extension ","text":"","category":"section"},{"location":"developerGuide/#[Problem-Extension](@ref)","page":"Developer Guide","title":"Problem Extension","text":"","category":"section"},{"location":"developerGuide/#[Solution-Extension](@ref)","page":"Developer Guide","title":"Solution Extension","text":"","category":"section"},{"location":"developerGuide/#[Taylor0-](@ref)","page":"Developer Guide","title":"Taylor0 ","text":"","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Systems-of-2-Linear-Time-Invariant-Differential-equations","page":"Examples","title":"Systems of 2 Linear Time Invariant Differential equations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"odeprob = NLodeProblem(quote\n     name=(sysb53,)\n    u = [-1.0, -2.0]\n    du[1] = -20.0*u[1]-80.0*u[2]+1600.0\n    du[2] =1.24*u[1]-0.01*u[2]+0.2\nend)  \ntspan=(0.0,1.0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is a great example that shows when we need to use the explicit qss, the implicit liqss, or the modified implicit nmliqss. This is a stiff problem so we need to use the implicit methods, but it also contains larger entries outside the main diagonal of the Jacobian. Therefore, nmliqss should the most appropriate algorithm to use. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sol=solve(odeprob,qss1(),tspan)\nsave_Sol(sol)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: plot_sysb53_qss1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sol=solve(odeprob,qss2(),tspan)\nsave_Sol(sol)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: plot_sysb53_qss2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sol=solve(odeprob,liqss1(),tspan)\nsave_Sol(sol)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: plot_sysb53_liqss1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sol=solve(odeprob,liqss2(),tspan)\nsave_Sol(sol)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: plot_sysb53_liqss2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sol=solve(odeprob,nmliqss1(),tspan)\nsave_Sol(sol)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: plot_sysb53_nmliqss1)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"sol=solve(odeprob,nmliqss2(),tspan)\nsave_Sol(sol)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: plot_sysb53_nmliqss2) The nmliqss plot does not finish at the final time because it terminated when it reached the equilibrium in which the values are the same as the values at the final time.","category":"page"},{"location":"examples/#The-Tyson-Model","page":"Examples","title":"The Tyson Model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"function test(solvr,absTol,relTol)\nodeprob = NLodeProblem(quote\n    name=(tyson,)\n    u = [0.0,0.75,0.25,0.0,0.0,0.0]\n    du[1] = u[4]-1e6*u[1]+1e3*u[2]\n    du[2] =-200.0*u[2]*u[5]+1e6*u[1]-1e3*u[2]\n    du[3] = 200.0*u[2]*u[5]-u[3]*(0.018+180.0*(u[4]/(u[1]+u[2]+u[3]+u[4]))^2)\n    du[4] =u[3]*(0.018+180.0*(u[4]/(u[1]+u[2]+u[3]+u[4]))^2)-u[4]\n    du[5] = 0.015-200.0*u[2]*u[5]\n    du[6] =u[4]-0.6*u[6]\nend ) \nprintln(\"start tyson solving\")\ntspan=(0.0,25.0)\nsol=solve(odeprob,solvr,abstol=absTol,reltol=relTol,tspan)\nprintln(\"start saving plot\")\nsave_Sol(sol)\nend\n\nabsTol=1e-5\nrelTol=1e-2\nsolvrs=[qss1(),liqss1(),nmliqss1(),nmliqss2()]\nfor solvr in solvrs\n    test(solvr,absTol,relTol)\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This model also is stiff and it needs a stiff method, but also the normal liqss will produce unnecessary cycles. Hence, the nmliqss is again the most appropriate. (Image: plot_tyson_qss1) (Image: plot_tyson_liqss1) (Image: plot_tyson_nmliqss1) (Image: plot_tyson_nmliqss2)","category":"page"},{"location":"examples/#Oregonator;-Vanderpl","page":"Examples","title":"Oregonator; Vanderpl","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"odeprob = NLodeProblem(quote\n    name=(vanderpol,)\n    u  = [0.0,1.7]\n    du[1] = u[2]\n    du[2] = (1.0-u[1]*u[1])*u[2]-u[1] \n    \nend)  \ntspan=(0.0,10.0)\nsol=solve(odeprob,nmliqss2(),tspan)\nsave_Sol(sol)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: plot_vanderpol_nmliqss2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"odeprob = NLodeProblem(quote\n    name=(oregonator,)\n    u  = [1.0,1.0,0.0]\n    du[1] = 100.8*(9.523809523809524e-5*u[2]-u[1]*u[2]+u[1]*(1.0-u[1]))\n    du[2] =40320.0*(-9.523809523809524e-5*u[2]-u[1]*u[2]+u[3])\n    du[3] = u[1] -u[3]\nend)  \ntspan=(0.0,10.0)\nsol=solve(odeprob,nmliqss2(),tspan)\nsave_Sol(sol)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: plot_oregonator_nmliqss2)","category":"page"},{"location":"examples/#Bouncing-Ball","page":"Examples","title":"Bouncing Ball","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"odeprob = NLodeProblem(quote \n    name=(sysd0,)\n    u = [50.0,0.0]\n    discrete=[0.0]\n    du[1] = u[2]\n    du[2] = -9.8#+discrete[1]*u[1]\n    if -u[1]>0.0\n        u[2]=-u[2]\n    end\nend)  \ntspan=(0.0,15.0)\nsol=solve(odeprob,qss2(),tspan)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: BBall)","category":"page"},{"location":"examples/#Conditional-Dosing-in-Pharmacometrics","page":"Examples","title":"Conditional Dosing in Pharmacometrics","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This section shows the Conditional Dosing in Pharmacometrics example tested using the Tsit5() of the DifferentialEquations.jl","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"odeprob = NLodeProblem(quote \n    name=(sysd0,)\n    u = [10.0]\n    discrete=[-1e5]\n    du[1] =-u[1]\n    if t-4.0>0.0\n        discrete[1]=0.0\n    end\n    if t-4.00000001>0.0\n        discrete[1]=-1e5\n    end\n    if discrete[1]+(4.0-u[1])>0.0\n        u[1]=u[1]+10.0\n    end\nend)  \ntspan=(0.0,10.0)\nsol=solve(odeprob,nmliqss2(),tspan)\nsave_Sol(sol)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The condition t == 4 && u[1] < 4 can be replaced by using another discrete variable (flag) that is triggered when t==4 , and it triggers the check of  u[1] < 4. (Image: dosingPharma)","category":"page"},{"location":"examples/#Four-stage-Cuk-Converter-:","page":"Examples","title":"Four stage Cuk Converter :","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: cuk4circuit)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"odeprob = NLodeProblem(quote\nname=(cuk4sym,)\n   C = 1e-4; L = 1e-4; R = 10.0;U = 24.0; T = 1e-4; DC = 0.25; ROn = 1e-5;ROff = 1e5;L1=1e-4;C1=1e-4;C2 = 1e-4;L2 = 1e-4;\n   #discrete Rd(start=1e5), Rs(start=1e-5), nextT(start=T),lastT,diodeon;\n   discrete = [1e5,1e-5,1e-4,0.0,0.0]\n   Rd=discrete[1];Rs=discrete[2];nextT=discrete[3];lastT=discrete[4];diodeon=discrete[5]\n   u[1:13]=0.0\n   uc2=u[13]\n   il2_1=u[i] ;il2_2=u[i-4] ;il2_3=u[i-8] ;il1_1=u[i+4] ;il1_2=u[i] ;il1_3=u[i-4] ;uc1_1=u[i+8];uc1_2=u[i+4] ;uc1_3=u[i] ;\n   id1=(((il2_1+il1_1)*Rs-uc1_1)/(Rd+Rs))\n   id2=(((il2_2+il1_2)*Rs-uc1_2)/(Rd+Rs))\n   id3=(((il2_3+il1_3)*Rs-uc1_3)/(Rd+Rs))\n  for i=1:4    #il2\n    du[i] =(-uc2-Rs*id1)/L2\n  end\n  for i=5:8    #il1\n    du[i]=(U-uc1_2-id2*Rs)/L1\n  end\n  for i=9:12    #uc1\n    du[i]=(id3-il2_3)/C1\n  end\n  du[13]=(u[1]+u[2]+u[3]+u[4]-uc2/R)/C2\n  if t-nextT>0.0 \n    lastT=nextT\n    nextT=nextT+T\n    Rs=ROn\n   \nend\nif t-lastT-DC*T>0.0 \n    Rs=ROff\nend                          \nif diodeon*(((u[1]+u[5])*Rs-u[9])/(Rd+Rs))+(1.0-diodeon)*(((u[1]+u[5])*Rs-u[9])*Rd/(Rd+Rs))>0\n  Rd=ROn\n  diodeon=1.0\nelse\n  Rd=ROff\n  diodeon=0.0\nend \nif diodeon*(((u[2]+u[6])*Rs-u[10])/(Rd+Rs))+(1.0-diodeon)*(((u[2]+u[6])*Rs-u[10])*Rd/(Rd+Rs))>0\n  Rd=ROn\n  diodeon=1.0\nelse\n  Rd=ROff\n  diodeon=0.0\nend \nif diodeon*(((u[3]+u[7])*Rs-u[11])/(Rd+Rs))+(1.0-diodeon)*(((u[3]+u[7])*Rs-u[11])*Rd/(Rd+Rs))>0\n  Rd=ROn\n  diodeon=1.0\nelse\n  Rd=ROff\n  diodeon=0.0\nend \nif diodeon*(((u[4]+u[8])*Rs-u[12])/(Rd+Rs))+(1.0-diodeon)*(((u[4]+u[8])*Rs-u[12])*Rd/(Rd+Rs))>0\n  Rd=ROn\n  diodeon=1.0\nelse\n  Rd=ROff\n  diodeon=0.0\nend \nend)\n\ntspan=(0.0,0.0005)\nsol= solve(odeprob,nmliqss2(),abstol=1e-4,reltol=1e-3,tspan)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: plot_cuk4sym_nmLiqss2)","category":"page"},{"location":"algorithm/#Available-Algorithms","page":"Available Algorithms","title":"Available Algorithms","text":"","category":"section"},{"location":"algorithm/","page":"Available Algorithms","title":"Available Algorithms","text":" qss1()  ","category":"page"},{"location":"algorithm/#QuantizedSystemSolver.qss1-Tuple{}","page":"Available Algorithms","title":"QuantizedSystemSolver.qss1","text":"qss1() calls the explicit quantized state system solver with order 1\n\n\n\n\n\n","category":"method"},{"location":"algorithm/","page":"Available Algorithms","title":"Available Algorithms","text":" qss2()  ","category":"page"},{"location":"algorithm/#QuantizedSystemSolver.qss2-Tuple{}","page":"Available Algorithms","title":"QuantizedSystemSolver.qss2","text":"qss2() calls the explicit quantized state system solver with order 2\n\n\n\n\n\n","category":"method"},{"location":"algorithm/","page":"Available Algorithms","title":"Available Algorithms","text":" liqss1()  ","category":"page"},{"location":"algorithm/#QuantizedSystemSolver.liqss1-Tuple{}","page":"Available Algorithms","title":"QuantizedSystemSolver.liqss1","text":"liqss1() calls the  imlicit quantized state system solver with order 1.\n\n\n\n\n\n","category":"method"},{"location":"algorithm/","page":"Available Algorithms","title":"Available Algorithms","text":" liqss2()  ","category":"page"},{"location":"algorithm/#QuantizedSystemSolver.liqss2-Tuple{}","page":"Available Algorithms","title":"QuantizedSystemSolver.liqss2","text":"liqss2() calls the  imlicit quantized state system solver with order 2.\n\n\n\n\n\n","category":"method"},{"location":"algorithm/","page":"Available Algorithms","title":"Available Algorithms","text":" nmliqss1()  ","category":"page"},{"location":"algorithm/#QuantizedSystemSolver.nmliqss1-Tuple{}","page":"Available Algorithms","title":"QuantizedSystemSolver.nmliqss1","text":"nmliqss1() calls the modified imlicit quantized state system solver with order 1. It is efficient when the system contains large entries outside the main diagonal of the Jacobian .\n\n\n\n\n\n","category":"method"},{"location":"algorithm/","page":"Available Algorithms","title":"Available Algorithms","text":" nmliqss2()  ","category":"page"},{"location":"algorithm/#QuantizedSystemSolver.nmliqss2-Tuple{}","page":"Available Algorithms","title":"QuantizedSystemSolver.nmliqss2","text":"nmliqss2() calls the modified imlicit quantized state system solver with order 2. It is efficient when the system contains large entries outside the main diagonal of the Jacobian .\n\n\n\n\n\n","category":"method"},{"location":"solutionDev/#Solution-Extension","page":"Solution Extension","title":"Solution Extension","text":"","category":"section"},{"location":"solutionDev/","page":"Solution Extension","title":"Solution Extension","text":"Similar to extending the entities Problem and Algorithm, the Solution entity can be extended by subclassing :","category":"page"},{"location":"solutionDev/","page":"Solution Extension","title":"Solution Extension","text":"Sol{T,O}","category":"page"},{"location":"solutionDev/#QuantizedSystemSolver.Sol","page":"Solution Extension","title":"QuantizedSystemSolver.Sol","text":"Sol{T,O} This is superclass for all QSS solutions. It is parametric on these:\n\n- The number of continuous variables T\n\n- The order of the algorithm O\n\n\n\n\n\n","category":"type"},{"location":"solutionDev/","page":"Solution Extension","title":"Solution Extension","text":"A current implemented concrete solution type is: ","category":"page"},{"location":"solutionDev/","page":"Solution Extension","title":"Solution Extension","text":"QuantizedSystemSolver.LightSol{T,O}","category":"page"},{"location":"solutionDev/#QuantizedSystemSolver.LightSol","page":"Solution Extension","title":"QuantizedSystemSolver.LightSol","text":"LightSol{T,O} A struct that holds the solution of a system of ODEs. It has the following fields:\n\n- size: The number of continuous variables T\n\n- order: The order of the algorithm O\n\n- savedTimes: A vector of vectors of Float64 that holds the times at which the continuous variables were saved\n\n- savedVars: A vector of vectors of Float64 that holds the values of the continuous variables at the times they were saved\n\n- algName: The name of the algorithm used to solve the system\n\n- sysName: The name of the system\n\n- absQ: The absolute tolerance used in the simulation\n\n- totalSteps: The total number of steps taken by the algorithm\n\n- simulStepCount: The number of simultaneous updates during the simulation\n\n- evCount: The number of events that occurred during the simulation\n\n- numSteps: A vector of Int that holds the number of steps taken by the algorithm for each continuous variable\n\n- ft: The final time of the simulation\n\n\n\n\n\n","category":"type"},{"location":"Problem/#Problem-Extension","page":"Problem Extension","title":"Problem Extension","text":"","category":"section"},{"location":"Problem/","page":"Problem Extension","title":"Problem Extension","text":"Problem extension can be achieved easily via PRTYPE which is of type Val, or another subtype of the superclass can be created.","category":"page"},{"location":"Problem/","page":"Problem Extension","title":"Problem Extension","text":" QuantizedSystemSolver.NLODEProblem{PRTYPE,T,Z,Y,CS}","category":"page"},{"location":"Problem/#QuantizedSystemSolver.NLODEProblem","page":"Problem Extension","title":"QuantizedSystemSolver.NLODEProblem","text":"NLODEProblem{PRTYPE,T,Z,Y,CS} This is superclass for all NLODE problems. It is parametric on these:\n\n- The problem type PRTYPE.\n\n- The number of continuous variables T\n\n- The number of events (zero crossing functions) Z\n\n- The actual number of events (an if-else statment has one zero crossing functions and two events) Y\n\n- The cache size CS.\n\n\n\n\n\n","category":"type"},{"location":"Problem/","page":"Problem Extension","title":"Problem Extension","text":"QuantizedSystemSolver.NLODEContProblem{PRTYPE,T,Z,Y,CS}","category":"page"},{"location":"Problem/#QuantizedSystemSolver.NLODEContProblem","page":"Problem Extension","title":"QuantizedSystemSolver.NLODEContProblem","text":"NLODEContProblem{PRTYPE,T,Z,Y,CS} A struct that holds the Problem of a system of ODEs. It has the following fields:\n\n- prname: The name of the problem\n\n- prtype: The type of the problem\n\n- a: The size of the problem\n\n- b: The number of zero crossing functions\n\n- c: The number of discrete events\n\n- cacheSize: The size of the cache\n\n- initConditions: The initial conditions of the problem\n\n- eqs: The function that holds all the ODEs\n\n- jac: The Jacobian dependency\n\n- SD: The state derivative dependency\n\n- exactJac: The exact Jacobian function\n\n- jacDim: The Jacobian dimension (if sparsity to be exploited)\n\n\n\n\n\n","category":"type"},{"location":"#Quantized-System-Solver","page":"Home","title":"Quantized System Solver","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"userGuide.md\", \"developerGuide.md\",\"examples.md\"]\nDepth = 1","category":"page"},{"location":"implementation/#Implementation","page":"Implementation","title":"Implementation","text":"","category":"section"},{"location":"implementation/#Package-Structure-{#ch5:section:Package-description}","page":"Implementation","title":"Package Structure {#ch5:section:Package-description}","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"While the package is optimized to be fast, extensibility is not compromised. It is divided into 3 entities that can be extended separately: Problem, Algorithm, and Solution. The rest of the code is to create these entities and glue them together as shown in the Figure.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"::: center (Image: The QSS Solver Structure.){#fig:qssdiag width=\"10cm\" height=\"6cm\"} :::","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The API was designed to provide an easier way to handle events than the approach provided by the classic integration solvers. Inside an NLodeProblem function, the user may introduce any parameters, variables, equations, and events:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"    odeprob = NLodeProblem(quote \n    name\n    parameters\n    discrete and continous variables\n    helper expressions\n    differential equations\n    if-statments for events)","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The output of this function is an object of type Problem, and it is passed to the solve function along any other configuration arguments such as the algorithm type, the time span and the tolerance. The solve function dispatches on the given algorithm and start the numerical integration.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"    tspan = (start time, end time)\n    sol= solve(odeprob,algorithm,tspan,abstol=...,reltol=...)","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"A the end, a solution object is produced that can be queried and plotted.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"    sol(time,idxs=variable index) \n    sol.stats\n    plot(sol)","category":"page"},{"location":"implementation/#Internal-Code-Explained-{#ch5:section:code-explained}","page":"Implementation","title":"Internal Code Explained {#ch5:section:code-explained}","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The solver structure is designed for modularity, allowing for different QSS algorithms and quantizer orders to be used in the simulation. The core components of the solver include the NLodeProblem function, the solve function, the scheduler, the quantizer, and the solution object. These components work together to parse user-provided code, solve the system of ODEs using QSS algorithms, and store the results for analysis. The following sections provide an in-depth explanation of the key components and their interactions within the solver framework.","category":"page"},{"location":"implementation/#creating-the-problem","page":"Implementation","title":"creating the problem","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The NLodeProblem function is the entry point for defining a new problem to be solved by the QSS solver. It takes user-provided code, which includes system parameters, variables, equations, and event logic, and constructs a Problem object that encapsulates all the necessary information for the solver to simulate the system such as problem dimensions, dependencies, and equations. The function works by parsing the user code and extracting relevant data to populate the Problem object.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"NLODEDiscProblem{PRTYPE,T,Z,Y,CS}: This is the struct that holds all the necessary data for a nonlinear ordinary differential equation (ODE) problem with discrete events. The structure includes various fields such as initial conditions, discrete variables, Jacobians, event dependencies, and other data related to how the problem is formulated. This structure serves as the core data holder for the problem and will be used in the solver. It is a parametric abstract type that has the following parameters:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"PRTYPE: The type of the problem (to distinguish between various types, and allow future extension of the solver to handle new types).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"T: The number of continuous variables (state variables).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Z: The number of zero-crossing functions, which are used to detect events.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Y: The actual number of events.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"CS: Cache size, which is used to store intermediate operations.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The use of abstract types in this context allows for flexibility and extensibility in the solver. By defining these abstract types, the code can be easily adapted to handle different types of problems, algorithms, and solutions without needing to modify the core solver logic. This design choice enhances the maintainability and scalability of the solver, making it easier to add new features or support additional problem types in the future.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"NLodeProblemFunc: After an initial preparation performed by the The NLodeProblem function, The function NLodeProblemFunc takes the resulting expressions to continue constructing an instance of the NLODEDiscProblem structure. It works in several key stages:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Initialization: The function begins by initializing vectors and dictionaries that will hold equations (equs), Jacobian dependencies (jac), zero-crossing functions (ZCjac), and event dependencies. These serve to store the different types of equations and their relationships.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Processing ODEs: It loops through each of the ODE expressions provided by the user. Depending on the type of expression (discrete variables, differential equations, or loop constructs), it processes the right-hand side (RHS) of the equation. For differential equations, it extracts dependencies to build the Jacobian and transform the equations into a more appropriate form for further use. Special cases are handled, such as if the RHS is a number or a symbol.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Handling Events: The function also processes event-related constructs (if conditions) that correspond to different points where the system might undergo discrete changes. It process the RHS of the event equations, transforms them into a suitable form, and builds the necessary dependency structures. Specifically, it constructs how discrete and continuous variables influence one another through the events.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Constructing the Function Code: After processing all ODEs and events, the function dynamically generates a Julia function code needed to store the system of ODEs and events. This code is built into a function that handles different cases (i.e., which equation to evaluate based on an index of a state change or an event).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Building Dependencies: Several helper functions that build the dependencies between variables, events. They build dependency vectors that track how discrete and continous variables influence the system. This is used to know what variables to update and determine when specific events should be checked. By tracking the relationships between variables and events, the solver can determine the appropriate actions to take at each time step. The dependencies are stored in the following vectors:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"-jac: It determines which variables affect a derivative.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"-ZCjac: It determines which variables affect a zero-crossing function.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"-SD: It determines which derivatives that are affected by a given variable.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"-SZ: It determines which zero-crossing functions that are affected by a given variable.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"-HZ: It tells which Zero-crossing functions influenced by a given event.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"-HD: It tells which derivatives influenced by a given event.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Here's a quick summary and what each helper function is doing:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"extractJacDepNormal: It Extracts the dependencies for normal (non-loop) expressions. It updates the Jacobian matrix jac and a dictionary dD for tracking dependencies of derivatives to discrete variables.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"extractJacDepLoop: Similar to extractJacDepNormal, but specifically for loop expressions. It tracks dependencies across loop iterations.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"extractZCJacDepNormal: It Extracts zero-crossing Jacobian dependencies for discrete variables (dZ), and it updates zcjac, SZ.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"createDependencyToEventsDiscr: It maps discrete dependencies (dD, dZ) to specific events, it and constructs dependency matrices HZ and HD from the discrete variables only.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"createDependencyToEventsCont: Similar to createDependencyToEventsDiscr, but for continuous dependencies (SD, sZ), and it updates the matrices HZ and HD from the continuous variables only.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"unionDependency: Merges the two previous sets of dependencies (continuous and discrete) into the final matrices HZ and HD.","category":"page"},{"location":"implementation/#The-solve-function","page":"Implementation","title":"The solve function","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The solve function is the primary interface for solving non-linear ODE problems using various QSS (Quantized State Systems) algorithms. It does this by dispatching on the problem and algorithm types to select the right solver.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"QSS Algorithm: The diagram shows three specific algorithms: (QSS Algorithm, LiQSS Algorithm, mLiQSS Algorithm). The Algorithm type is parametric on the solver name (N) and order (O). When a user doesn't provide a solver explicitly, the solve function defaults to using the modified second-order implicit algorith (mLiQSS2). This approach allows flexibility: the user can select a different algorithm by providing an alternative QSS Algorithm without needing to modify the solve function. Based on the QSS Algorithm provided, it either selects a basic QSS integration method or, in the case of LiQSS, constructs additional data structures needed for implicit integration. The method defaults to sparse handling as false (Val(false)), tolerances (abstol=1e-4 and reltol=1e-3), and a maximum number of iterations (maxiters=1e7). These parameters can be adjusted based on the problem's complexity and desired accuracy.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Helper Functions:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"createCommonData: This function sets up the common data required by the QSS solver. It initializes all necessary vectors (x, q, tx, tq, nextStateTime, etc.) used in the integration process, and it pre-allocates a cache of Taylor series to avoid repeated memory allocation during integration (taylorOpsCache).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"getClosure: This function creates a closure for the Jacobian and the dependency matrices, allowing in a flexible in a way that enables easy extension. The closure is used to access the Jacobian matrix during the integration process.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"createLiqssData: For LiQSS solvers, this function sets up additional data structures and auxiliary variables used for storing linear approximation coefficients.","category":"page"},{"location":"implementation/#The-scheduler-function","page":"Implementation","title":"The scheduler function","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The scheduler component retrieves the next index (a state change or an event) for processing. It determines the next action by comparing three types of timing events: state updates, events, and input updates. It initializes minimum time variables for each action type to infinity and iterates through the provided vectors to find the minimum times and their corresponding indices. Based on these comparisons, it decides whether the next scheduled action is an input update, an event, or a state update. If no valid actions are found (indicated by a zero index), the function assigns a default state indicating the next action is a state update at time infinity. Finally, it returns a tuple containing the index of the next action, its time, and a symbol representing the type of action to take next (:STINPUT, :STEVENT, or :STSTATE). This structure ensures that the simulation progresses accurately and efficiently.","category":"page"},{"location":"implementation/#The-Quantizer-functions","page":"Implementation","title":"The Quantizer functions","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The system handles different quantizer orders (Order 1 and Order 2). It defines methods for state integration, derivative computation, event time computation, updating quantized values, and cycle detection updates.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Utils: This section contains utility functions like root finding that assist in the solution process.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"computeNextTime: for first-order, the state of the system changes at a constant rate. The core calculation takes place when the first derivative of the state, represented by xi1, is non-zero. In this case, the function determines the time to the next event by dividing a quantum threshold by this derivative. Additionally, to prevent numerical issues, it ensures that this calculated time-step does not fall below a predefined minimum value, absDeltaT. If the first derivative is extremely small or essentially zero, the function adjusts it to avoid potential numerical instabilities that could arise from very small time increments.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"For second-order, the system state evolves with both a rate of change (first derivative) and acceleration (second derivative). The core calculation occurs when the second derivative of the state, represented by xi2, is non-zero. In this case, the function computes the time to the next event by using the square root of the ratio between a quantum threshold and the second derivative. This ensures that the time-step reflects the influence of the system's acceleration. Additionally, to prevent numerical issues (such as division by zero or overly small time-steps), a minimum delta time (absDeltaT) is enforced. If the computed time-step is smaller than this threshold, the function adjusts the second derivative to maintain stability. If the second derivative is zero but the first derivative is non-zero, the time to the next event is calculated based on the first derivative. The function ensures that the time-step does not drop below absDeltaT, adjusting the first derivative if necessary. If both derivatives are zero, the system is assumed to have no change, and the next event time is set to infinity (Inf).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"recomputeNextTime: The reComputeNextTime functions are used in the explicit QSS algorithms to enable the recalculation of the next time after interactions between different variables, such as variable i and variable j. These functions determine the time until the system crosses the quantum threshold by solving polynomial equations derived from the difference between the quantized state and the actual state. In situations where the quantum threshold has already been surpassed, they promptly return a very small time increment (e.g., simt + 1e-12) to trigger an immediate update of the system's state.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"LiqssrecomputeNextTime: In the LIQSS methods of first-order, the recomputeNextTime function calculates the next event time based on the current state (x), its first derivative (x1), and the quantized state (q). First, if the difference between the current state and the quantized state exceeds twice the quantum size, the next event is scheduled almost immediately with a small time-step. Otherwise, if the derivative is non-zero, the function computes the time-step by dividing the state difference by the derivative. If the result is positive, this time is added to the current simulation time (simt). If negative, it adjusts the time-step by either adding or subtracting twice the quantum size based on the direction of change. If the derivative is zero, indicating no change, the event time is set to infinity. Lastly, if the computed time is in the past, the function resets it to a far future time to prevent any premature events. This ensures that the system evolves smoothly and accurately.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"In the second-order LIQSS method, the recomputeNextTime function calculates the next event time by considering both the state (x) and its first (x1) and second (x2) derivatives, along with the quantized state (q). The function constructs a polynomial using the current state, derivative values, and the second derivative, then calculates the next event time by finding the smallest positive root of this polynomial.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"computeNextInputTime: The computeNextInputTime functions focus on computing the next action when derivatives depend only on time. They assess changes in the derivatives over a specified elapsed time to compute the time increment until the next input action. If the derivatives are null, the function reverts to handling the system in a lower-order thus simplifying the calculation.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"computeNextEventTime: The computeNextEventTime function calculates the next event time based on the zero-crossing function (ZCFun) of a system. It first checks if a sign change has occurred in the zero-crossing function, indicating that the system is leaving zero and should be considered an event, provided the previous value is significantly different from zero (to prevent duplicate events). If a sign change is detected, the function updates the event time to the current simulation time. If both the old and new values of the zero-crossing function are zero, it sets the next event time to infinity, indicating no event should occur. For cases where the old and new values have the same sign, it calculates the minimum positive root of the zero-crossing function, representing the time of the next event, ensuring that this time is not too close to zero to avoid spurious events. The function then updates the old sign values for future comparisons.","category":"page"},{"location":"implementation/#The-solution","page":"Implementation","title":"The solution","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"This is where the results of the simulation are stored, including: Settings, Time points (times[]), Variables (vars[]), Statistics (stats).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The solution Struct The LightSol struct is specifically designed to hold the solution of a system of ODEs. It contains several fields, including size and order, which denote the number of continuous variables and the order of the algorithm used, respectively. The savedTimes and savedVars fields are vectors that store the time steps and corresponding values of the continuous variables at which they were recorded during the simulation. Other fields include algName and sysName, which specify the names of the algorithm and system being solved, alongside absQ, the absolute tolerance used during the simulation. The stats field contains an instance of the Stats struct, providing access to the performance metrics, while ft holds the final time of the simulation. The Stats struct includes fields for totalSteps, which counts the total number of steps taken throughout the simulation, simulStepCount, representing the number of simultaneous updates during the simulation, and evCount, which tallies the number of events that occurred. Additionally, the numSteps vector keeps track of the number of steps taken for each continuous variable involved in the simulation, allowing for detailed analysis of the performance for individual components.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The functions defined in conjunction with these structs enable various operations related to the simulation's solutions. The createSol function initializes a LightSol instance with the specified parameters, while the getindex function provides a helper to access either the saved times or variables easily. The evaluateSol function allows for the evaluation of the solution at a specified time, supporting linear interpolation between saved points. Furthermore, the solInterpolated functions enable the generation of interpolated solutions across specified intervals, creating new solution objects based on the interpolated values and times. The show function is tailored to present the statistics in a user-friendly format, offering insights into the performance of the simulation. Overall, these constructs provide a robust framework for managing and analyzing the outcomes of simulations involving ODEs.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Plotting the Solution: The plotSol function is designed to visually represent the solution of a system of ODEs stored in the solution object. It accepts a variety of optional parameters, allowing users to customize their plots significantly. The function takes in a solution object sol along with indices for the variables to be plotted (xvars). Users can also specify a title, axis limits (xlims and ylims), and visual styles, such as marker types and whether to display a legend. If a title is not provided, it defaults to a composite of various parameters, including the system name, algorithm name, absolute tolerance, total steps taken, and more.Within the function, each selected variable is plotted against its corresponding saved time, utilizing different line styles for better distinction. If no specific variables are selected, all variables in the solution are plotted by default. After constructing the plot, the function checks for specified axis limits and applies them accordingly. Finally, the function returns the plot object, which can be further modified or saved. In addition to basic plotting, the saveSol function allows users to save their plots as PNG files, automatically generating filenames based on relevant parameters and timestamps. This functionality is crucial for documentation and sharing results in a reproducible manner. This comprehensive plotting capability ensures that users can effectively visualize the behavior of their systems, making the analysis of results intuitive and informative.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Finding the Error: The getError function computes the relative error of a solution compared to a specified reference function, enabling users to assess the accuracy of their numerical results. The function iterates over the saved time points, and it calculates the sum of the squares of the differences between the numerical solution and the true values provided by the reference function, as well as the sum of the squares of the true values. The relative error is then derived as the square root of the ratio of these sums, providing a quantitative measure of the solution's deviation from the expected results. This comprehensive error analysis is essential for validating the performance of numerical methods and ensuring that the solutions produced are both reliable and precise. By comparing the numerical results to known reference values, users can gain insights into the accuracy and effectiveness of the solver, enabling them to make informed decisions about their simulations and analyses.","category":"page"}]
}
