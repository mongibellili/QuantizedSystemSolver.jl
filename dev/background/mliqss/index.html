<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modified Linearly Implicit Quantized State System Methods · Quantized System Solver</title><meta name="title" content="Modified Linearly Implicit Quantized State System Methods · Quantized System Solver"/><meta property="og:title" content="Modified Linearly Implicit Quantized State System Methods · Quantized System Solver"/><meta property="twitter:title" content="Modified Linearly Implicit Quantized State System Methods · Quantized System Solver"/><meta name="description" content="Documentation for Quantized System Solver."/><meta property="og:description" content="Documentation for Quantized System Solver."/><meta property="twitter:description" content="Documentation for Quantized System Solver."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Quantized System Solver logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quantized System Solver</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../guide/userTutorial/">Tutorial</a></li><li><a class="tocitem" href="../../guide/userAPI/">User API</a></li></ul></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../introductoryResources/">Introduction to Quantized System Methods</a></li><li><a class="tocitem" href="../qss/">Quantized State System Methods</a></li><li><a class="tocitem" href="../liqss/">Linearly Implicit Quantized State System Methods</a></li><li class="is-active"><a class="tocitem" href>Modified Linearly Implicit Quantized State System Methods</a><ul class="internal"><li><a class="tocitem" href="#mLIQSS2"><span>mLIQSS2</span></a></li><li><a class="tocitem" href="#refs3"><span>References</span></a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/linearTimeInvariantSystem/">Linear Time Invariant</a></li><li><a class="tocitem" href="../../examples/vanderpol/">Van der Pol</a></li><li><a class="tocitem" href="../../examples/tysonModel/">The Tyson Model</a></li><li><a class="tocitem" href="../../examples/adr/">ADR problem</a></li><li><a class="tocitem" href="../../examples/dosing/">Conditional Dosing in Pharmacometrics</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../../developer/devIntro/">Developer Guide</a></li><li><a class="tocitem" href="../../developer/problem/">Problem</a></li><li><a class="tocitem" href="../../developer/algorithm/">QSS Algorithms</a></li><li><a class="tocitem" href="../../developer/solve/">Solve</a></li><li><a class="tocitem" href="../../developer/integrator/">Integrators</a></li><li><a class="tocitem" href="../../developer/quantizer/">Quantizer</a></li><li><a class="tocitem" href="../../developer/solution/">Solution</a></li><li><a class="tocitem" href="../../developer/taylor/">Taylor Variables</a></li><li><a class="tocitem" href="../../developer/utils/">Utils references</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Background</a></li><li class="is-active"><a href>Modified Linearly Implicit Quantized State System Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modified Linearly Implicit Quantized State System Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mongibellili/QuantizedSystemSolver.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/main/docs/src/background/mliqss.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Modified-Linearly-Implicit-Quantized-State-System-Methods"><a class="docs-heading-anchor" href="#Modified-Linearly-Implicit-Quantized-State-System-Methods">Modified Linearly Implicit Quantized State System Methods</a><a id="Modified-Linearly-Implicit-Quantized-State-System-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Modified-Linearly-Implicit-Quantized-State-System-Methods" title="Permalink"></a></h1><p>In LIQSS, all steps involves single variable updates depending on the future direction of <span>$x_{i}$</span>, as shown in bullet 4 of the <strong>mLIQSS1 algorithm</strong>. While this intrinsic behavior of single cheap steps is advantageous, an issue arises from it. This asynchrony in updates can lead to unintended interactions between variables, causing them to stray from the true solution and trigger subsequent steps sooner than necessary. This behavior can result in cycles and unnecessary steps in the simulation.  In essence, the lack of synchronization in variable updates can introduce unintended feedback loops, disrupting the simulation dynamics and potentially leading to inaccuracies or inefficiencies in the simulation results. Addressing this issue involves cycle detection mechanisms <a href="#refs3">[1]</a>.</p><p>The following conditions in Eq.(3) are used to detect cycles for order 1:</p><p class="math-container">\[    \begin{align}
     &amp;  \dot x_j.dx_j&lt;0  \;\; \; and \;\;\; \dot x_i.dx_i&lt;0
    \end{align}\]</p><p>where <span>$dx_i$</span> and <span>$dx_j$</span> are linear approximations of the future derivatives. They are given as follows: </p><p class="math-container">\[\begin{align}
 &amp; dx_i=a_{ii}.q_i+a_{ij}.q_j+u_{ij}  \nonumber\\
 &amp; dx_j=a_{jj}.q_j+a_{ji}.q_i+u_{ji}
\end{align}\]</p><p>where <span>$a_{ij}$</span> is the entry (<span>$i$</span>,<span>$j$</span>) of the Jacobian of the linearized derivative function and <span>$u_{ij}$</span> is an affine coefficient.</p><p>A modification to the original LIQSS algorithm was implemented in the following Algorithm:</p><p><strong>mLIQSS1 algorithm</strong></p><ol><li>If a variable <span>$i$</span> needs to change<ul><li>Compute the elapsed time <span>$e$</span> since the last update of variable <span>$i$</span></li><li>Update its value using Taylor expansion: <span>$x_{i}=x_{i}+\dot x_i.e$</span></li><li>Update the quantum <span>$\Delta_i$</span></li><li>If <span>$\dot x . (a_{ii}.(x_i+sign(\dot x).\Delta_i)+u_{ii}) &gt;0$</span><ul><li>Update the Quantized variable <span>$q_i=x_i+sign(\dot x).\Delta_i$</span></li></ul></li><li>Else<ul><li>Update the Quantized variable <span>$q_i=\frac{-u_{ii}}{a_{ii}}$</span>   </li></ul></li><li>Compute the next time when <span>$q_i=x_i$</span> </li><li>For any variable <span>$j$</span> depends on <span>$i$</span> such that <span>$a_{ij}.a_{ji} \neq 0$</span><ul><li>compute the prediction of derivatives of <span>$i$</span> and <span>$j$</span> using Eq.(2)</li><li>If the conditions in Eq.(1) are met:<ul><li>perform a Backward Euler step as shown in Eq.(4) using <strong>The Iteration approach in the simultaneous update order 1</strong></li><li>For any variable <span>$k$</span> that depends on <span>$j$</span><ul><li>update <span>$x_k$</span>, <span>$\dot x_k$</span>, <span>$a_{kj}$</span>, and next time of change.</li></ul></li></ul></li></ul></li><li>For any variable <span>$j$</span> depends on <span>$i$</span><ul><li>Update the variable <span>$x_{j}=x_{j}+\dot x_j.e_j$</span></li><li>Update the derivative <span>$\dot x_{j}=f_j(q,t)$</span> </li><li>Compute the next time when <span>$q_j=x_j \; or |q_j-x_j|=2\Delta_i$</span> </li></ul></li><li>For any zero crossing function <span>$zc$</span> depends on <span>$i$</span><ul><li>Update <span>$zc$</span></li><li>Compute the next event time of <span>$zc$</span> </li></ul></li></ul></li><li>If an event needs to occur<ul><li>Recheck validity of the event</li><li>Execute the event and update the related quantized variables</li><li>For any variable <span>$j$</span> depends on the event<ul><li>Update the variable <span>$x_{j}=x_{j}+\dot x_j.e_j$</span></li><li>Update the derivative <span>$\dot x_j=f_j(Q,t)$</span> </li><li>Compute the next time when <span>$q_j=x_j \; or |q_j-x_j|=2\Delta_j$</span> </li></ul></li><li>For any zero crossing function <span>$zc$</span> depends on the event<ul><li>Update <span>$zc$</span></li><li>Compute the next event time of <span>$zc$</span> </li></ul></li></ul></li></ol><p><strong>The Iteration approach in the simultaneous update order 1</strong></p><ul><li>Update the step size <span>$h=Final\;Simulation\;Time-current\;Sim\;Time$</span>; </li><li><span>$q_i=x_i+ds_i(h)$</span> \; <span>$q_j=x_j+ds_j(h)$</span></li><li>If (<span>$|q_i-x_i|&gt;\Delta_i$</span> or <span>$|q_j-x_j|&gt;\Delta_j$</span>)<ul><li>Update the step size <span>$h_i=\frac{\Delta_i}{|\dot x_i|}$</span>;  <span>$h_j=\frac{\Delta_j}{|\dot x_j|}$</span>; <span>$h=min(h_i,h_j)$</span></li><li>Update the Quantized variable <span>$q_i=x_i+ds_i(h)$</span> ; <span>$q_j=x_j+ds_j(h)$</span></li></ul></li><li>While (<span>$|q_i-x_i|&gt;\Delta_i$</span> or <span>$|q_j-x_j|&gt;\Delta_j$</span>) and <span>$AllowedIters&gt;0$</span><ul><li>Update <span>$AllowedIters=AllowedIters-1$</span></li><li>Update the step size <span>$h_i=h_i.\sqrt{\frac{\Delta_i}{|q_i-x_i|}}$</span>; <span>$h_j=h_j.\sqrt{\frac{\Delta_j}{|q_j-x_j|}}$</span>; <span>$h=min(h_i,h_j)$</span></li><li>Update the Quantized variable <span>$q_i=x_i+ds_i(h)$</span> ; <span>$q_j=x_j+ds_j(h)$</span></li></ul></li><li>If <span>$AllowedIters=0$</span><ul><li>cancel the simultnaeous update and perform a LIQSS step</li></ul></li></ul><p>When a cycle is detected, a simultaneous update must occur.   In order to simultaneously update <span>$q_i$</span> and <span>$q_j$</span> as the future values of <span>$x_i$</span> and <span>$x_j$</span>, the following equation is used:</p><p class="math-container">\[\begin{align}
 &amp; q_i=x_i+h.dx_i   \nonumber\\
 &amp; q_j=x_j+h.dx_j 
\end{align}\]</p><p>Using this equation and Eq.(2) is equivalent to performing a Backward Euler step, and it can formulated as follows:</p><p class="math-container">\[\begin{equation}
Q_{ij}=(I-h.A_{ij})^{-1}.(X_{ij}+h.U_{ij})
\end{equation}\]</p><p>where  <span>$Q_{ij}=$</span> <span>$\begin{pmatrix}   q_i \\    q_j  \end{pmatrix}$</span>; <span>$A_{ij}=$</span>  <span>$\begin{pmatrix}   a_{ii} &amp; a_{ij}\\    a_{ji} &amp; a_{jj} \end{pmatrix}$</span>; <span>$X_{ij}=$</span> <span>$\begin{pmatrix}   x_i \\    x_j  \end{pmatrix}$</span>; and <span>$U_{ij}=$</span> <span>$\begin{pmatrix}   u_{ij} \\    u_{ji}  \end{pmatrix}$</span> </p><p>The value of <span>$h$</span> is computed analytically or via iterations as the maximum value that satisfies Eq.(5).</p><p class="math-container">\[\begin{align}
|q_i-x_i| \leq \Delta_i ;\ |q_j-x_j| \leq \Delta_j
\end{align}\]</p><p>Where <span>$\Delta_i $ and $\Delta_j $ are the quantums of the variables $x_i$</span> and <span>$x_j$</span> respectively.</p><h2 id="mLIQSS2"><a class="docs-heading-anchor" href="#mLIQSS2">mLIQSS2</a><a id="mLIQSS2-1"></a><a class="docs-heading-anchor-permalink" href="#mLIQSS2" title="Permalink"></a></h2><p>While higher-order methods offer improved accuracy in tracking the system&#39;s dynamics, they also introduce additional challenges. One of the key issues arises from the increased complexity in variable interactions, which can lead to discrepancies between the predicted and actual trajectories of the variables, potentially causing premature or unnecessary steps in the simulation.To address these challenges, conducting the cycle detection mechanism and updating the quatized states consider higher order terms.</p><p>Cycle detection mechanisms for Order 2 must consider both the first and second derivatives of the variables. The following conditions in Eq.(6) are used to detect cycles for Order 2:</p><p class="math-container">\[\begin{align}
  &amp;  |\dot x_j-dx_j|&gt;\frac{|\dot x_j+dx_j|}{2} \; or \; |\ddot x_j-ddx_j|&gt;\frac{|\ddot x_j+ddx_j|}{2} \nonumber\\
  &amp; \qquad \qquad \qquad  \qquad \qquad and \nonumber\\
  &amp;  |\dot x_i-dx_i|&gt;\frac{|\dot x_i+dx_i|}{2}  \; or \; |\ddot x_i-ddx_i|&gt;\frac{|\ddot x_i+ddx_i|}{2}

  \end{align}\]</p><p>where <span>$ddx_i$</span> and <span>$ddx_j$</span> are linear approximations of the future second derivatives. They are given as shown in Eq.(7). </p><p class="math-container">\[\begin{align}
 &amp; ddx_i=a_{ii}.\dot q_i+a_{ij}.\dot q_j+\dot u_{ij}  \nonumber\\
 &amp; ddx_j=a_{jj}.\dot q_j+a_{ji}.\dot q_i+\dot u_{ji}
\end{align}\]</p><p>where <span>$\dot u_{ij}$</span> is an affine coefficient.  </p><p>To account for these second-order effects, modifications to the original LIQSS algorithm were implemented, as shown in the <strong>mLIQSS2 algorithm</strong>. The algorithm ensures that the higher-order derivatives are properly integrated into the update rules.</p><p>The mLIQSS order 2 method is defined in the following Algorithm. <strong>mLIQSS2 algorithm</strong> </p><ol><li>If a variable <span>$i$</span> needs to change<ul><li>Compute the elapsed time <span>$e$</span> since the last update of variable <span>$i$</span></li><li>Update the variable <span>$x_{i}=x_{i}+\dot x_i.e_i+\frac{1}{2}\ddot x_i.e_i^2$</span></li><li>Update the quantum <span>$\Delta_i$</span></li><li>Update the derivative <span>$\dot x_{i}=\dot x_{i}+\ddot x_i.e$</span></li><li>Update the affine coefficient <span>$u_{ii} = \dot x_i - a_{ii} . (q_{i}+\dot q_i.e_i)$</span></li><li>Update the derivative of the affine coefficient <span>$\dot u_{ii} = \ddot x_i - a_{ii} . \dot q_i$</span></li><li>The Quantized variable <span>$q_i(h)=\frac{(x_i-h.a_{ii}.x_i-h^2.(a.u_{ii}+\dot u_{ii})/2)}{(1 - h . a_{ii} + h^2.a_{ii}^2 / 2)}$</span></li><li>Update the step size <span>$h=Final\;Simulation\;Time-current\;Sim\;Time$</span>;  <span>$q_i=q_i(h)$</span></li><li>If <span>$|q_i-x_i|&gt;\Delta_i$</span><ul><li>Update the step size <span>$h=\sqrt{\frac{2\Delta_i}{|ddx_i|}}$</span>;  <span>$q_i=q_i(h)$</span></li></ul></li><li>While <span>$|q_i-x_i|&gt;\Delta_i$</span><ul><li>Update the step size <span>$h=h\sqrt{\frac{\Delta_i}{|q_i-x_i|}}$</span>;  <span>$q_i=q_i(h)$</span></li></ul></li><li>Update the Quantized derivative <span>$\dot q_i=\frac{a_{ii}.q_i+u_{ii}+h.\dot u_{ii}}{1-h.a_{ii}}$</span></li><li>Compute the next time when <span>$q_i=x_i$</span> </li><li>For any variable <span>$j$</span> depends on <span>$i$</span> such that <span>$a_{ij}.a_{ji} \neq 0$</span><ul><li>compute the prediction of derivatives of <span>$i$</span> and <span>$j$</span> using Eq.(7)</li><li>If the conditions in Eq.(6) are met:<ul><li>perform a simultaneous update as shown in Eq.(9) using <strong>The Iteration approach in the simultaneous update order 2</strong></li><li>For any variable <span>$k$</span> that depends on <span>$j$</span><ul><li>update <span>$x_k$</span>, <span>$\dot x_k$</span>, <span>$\ddot x_k$</span>, <span>$a_{kj}$</span>, and next time of change.</li></ul></li></ul></li></ul></li><li>For any variable <span>$j$</span> depends on <span>$i$</span><ul><li>Update the variable <span>$x_{j}=x_{j}+\dot x_j.e_j+\frac{1}{2}\ddot x_j.e_j^2$</span></li><li>For any variable <span>$k$</span> that <span>$f_j$</span> depends upon<ul><li>Update the Quantized variable <span>$q_{k}=q_{k}+\dot q_k.e_k$</span> </li></ul></li><li>Update the derivatives <span>$\dot x_{j}=f_j(q,t) \; and \ddot x_j=\dot f_j(Q,t)$</span> </li><li>Compute the next time when <span>$q_j=x_j \; or |q_j-x_j|=2\Delta_i$</span> </li></ul></li><li>For any zero crossing function <span>$zc$</span> depends on <span>$i$</span><ul><li>For any variable <span>$k$</span> that <span>$zc$</span> depends upon<ul><li>Update the Quantized variable <span>$q_{k}=q_{k}+\dot q_k.e_k$</span></li></ul></li><li>Update <span>$zc$</span></li><li>Compute the next event time of <span>$zc$</span> </li></ul></li></ul></li><li>If an event needs to occur<ul><li>Recheck validity of the event</li><li>Execute the event and update the related quantized variables</li><li>For any variable <span>$j$</span> depends on the event<ul><li>Update the variable <span>$x_{j}=x_{j}+\dot x_j.e_j+\frac{1}{2}\ddot x_j.e_j^2$</span></li><li>For any variable <span>$k$</span> that <span>$f_j$</span> depends upon<ul><li>Update the Quantized variable <span>$q_{k}=q_{k}+\dot q_k.e_k$</span></li></ul></li><li>Update the derivatives <span>$\dot x_j=f_j(Q,t) \; and \ddot x_j=\dot f_j(Q,t)$</span> </li><li>Compute the next time when <span>$q_j=x_j \; or |q_j-x_j|=2\Delta_j$</span> </li></ul></li><li>For any zero crossing function <span>$zc$</span> depends on the event<ul><li>For any variable <span>$k$</span> that <span>$zc$</span> depends upon<ul><li>Update the Quantized variable <span>$q_{k}=q_{k}+\dot q_k.e_k$</span></li></ul></li><li>Update <span>$zc$</span></li><li>Compute the next event time of <span>$zc$</span> </li></ul></li></ul></li></ol><p><strong>The Iteration approach in the simultaneous update order 2</strong></p><ul><li><p>Update the step size <span>$h=Final\;Simulation\;Time-current\;Sim\;Time$</span>; </p></li><li><p>Calculate <span>$q_i$</span> and <span>$q_j$</span> using Eq.(10)</p></li><li><p>If (<span>$|q_i-x_i|&gt;\Delta_i$</span> or <span>$|q_j-x_j|&gt;\Delta_j$</span>)</p><ul><li>Update the step size <span>$h_i=\sqrt{\frac{2\Delta_i}{|ddx_i|}}$</span>;  <span>$h_j=\sqrt{\frac{2\Delta_j}{|ddx_j|}}$</span>; <span>$h=min(h_i,h_j)$</span></li><li>calculate <span>$q_i$</span> and <span>$q_j$</span> using Eq.(10)</li></ul></li><li><p>While (<span>$|q_i-x_i|&gt;\Delta_i$</span> or <span>$|q_j-x_j|&gt;\Delta_j$</span>) and <span>$AllowedIters&gt;0$</span></p><ul><li>Update <span>$AllowedIters=AllowedIters-1$</span></li><li>Update the step size <span>$h_i=h_i.\sqrt{\frac{\Delta_i}{|q_i-x_i|}}$</span>; <span>$h_j=h_j.\sqrt{\frac{\Delta_j}{|q_j-x_j|}}$</span>; <span>$h=min(h_i,h_j)$</span></li><li>Calculate <span>$q_i$</span> and <span>$q_j$</span> using Eq.(10)</li></ul></li><li><p>If <span>$AllowedIters=0$</span></p><ul><li>Cancel the simultnaeous update and perform a LIQSS step</li></ul></li><li><p>Calculate <span>$\dot q_i$</span> and <span>$\dot q_j$</span> using Eq.(9)</p></li></ul><p>When cycles are detected in Order 2, simultaneous updates must account for both the positions and second-order derivatives of the involved variables. This requires solving the following system of equations for <span>$q_i$</span> and <span>$q_j$</span>:</p><p class="math-container">\[\begin{align}
  &amp; q_i+h.\dot q_i=x_i+h.dx_i+h^2.ddx_i/2  \nonumber \\
  &amp; \dot q_i=dx_i+h.ddx_i \nonumber\\
  &amp; q_j+h.\dot q_j=x_j+h.dx_j+h^2.ddx_j/2 \nonumber\\
  &amp; \dot q_j=dx_j+h.ddx_j 
 \end{align}\]</p><p>Using Eq.(8), Eq.(2) and Eq.(7) is equivalent to the following:</p><p class="math-container">\[ \begin{align}
 \dot Q_{ij}=(I-h.A_{ij})^{-1}.(A_{ij}.Q_{ij}+U_{ij}+h.\dot U_{ij}) \nonumber\\
  Q_{ij}+h.\dot Q_{ij}=(X_{ij}+h.(A_{ij}.Q_{ij}+U_{ij})+h^2.(A_{ij}.\dot Q_{ij}+\dot U_{ij})/2)
 \end{align}\]</p><p class="math-container">\[ \begin{align}
   \alpha=X_{ij}+h.U_{ij}+h^2.\dot U_{ij}/2 \nonumber\\
   \beta=-(h.I-h^2.A_{ij}/2).(I-h.A_{ij})^{-1}.(U_{ij}+h.\dot U_{ij})+\alpha \nonumber\\
   \gamma=(I-h.A_{ij})+(h.I-h^2.A_{ij}/2).(I-h.A_{ij})^{-1}.A_{ij} \nonumber\\
   Q_{ij}= \gamma^{-1}.\beta
  \end{align}\]</p><p>where   <span>$\dot Q_{ij}=$</span> <span>$\begin{pmatrix}   \dot q_i \\    \dot q_j   \end{pmatrix}$</span> and <span>$\dot U_{ij}=$</span> <span>$\begin{pmatrix}   \dot u_{ij} \\    \dot u_{ji}   \end{pmatrix}$</span> </p><p>The value of <span>$h$</span> is computed analytically or via iterations as the maximum value that satisfies Eq.(5).</p><h2 id="refs3"><a class="docs-heading-anchor" href="#refs3">References</a><a id="refs3-1"></a><a class="docs-heading-anchor-permalink" href="#refs3" title="Permalink"></a></h2><p>[1]  F. Pietro, G. Migoni, and E. Kofman. Improving linearly implicit quantized state system methods. Simulation: Transactions of the Society for Modeling and Simulation International, vol.95(no.2):pp.127–144, 2019.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../liqss/">« Linearly Implicit Quantized State System Methods</a><a class="docs-footer-nextpage" href="../../examples/linearTimeInvariantSystem/">Linear Time Invariant »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 9 December 2024 14:17">Monday 9 December 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
