<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linearly Implicit Quantized State System Methods · Quantized System Solver</title><meta name="title" content="Linearly Implicit Quantized State System Methods · Quantized System Solver"/><meta property="og:title" content="Linearly Implicit Quantized State System Methods · Quantized System Solver"/><meta property="twitter:title" content="Linearly Implicit Quantized State System Methods · Quantized System Solver"/><meta name="description" content="Documentation for Quantized System Solver."/><meta property="og:description" content="Documentation for Quantized System Solver."/><meta property="twitter:description" content="Documentation for Quantized System Solver."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Quantized System Solver logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quantized System Solver</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../guide/userTutorial/">Tutorial</a></li><li><a class="tocitem" href="../../guide/userAPI/">User API</a></li></ul></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../introductoryResources/">Introduction to Quantized System Methods</a></li><li><a class="tocitem" href="../qss/">Quantized State System Methods</a></li><li class="is-active"><a class="tocitem" href>Linearly Implicit Quantized State System Methods</a><ul class="internal"><li><a class="tocitem" href="#LIQSS1"><span>LIQSS1</span></a></li><li><a class="tocitem" href="#LIQSS2"><span>LIQSS2</span></a></li><li><a class="tocitem" href="#refs2"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../mliqss/">Modified Linearly Implicit Quantized State System Methods</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/linearTimeInvariantSystem/">Linear Time Invariant</a></li><li><a class="tocitem" href="../../examples/linearTimeInvariantSystemEvents/">Linear Time Invariant with events</a></li><li><a class="tocitem" href="../../examples/vanderpol/">Van der Pol</a></li><li><a class="tocitem" href="../../examples/tysonModel/">The Tyson Model</a></li><li><a class="tocitem" href="../../examples/adr/">ADR problem</a></li><li><a class="tocitem" href="../../examples/dosing/">Conditional Dosing in Pharmacometrics</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../../developer/devIntro/">Developer Guide</a></li><li><a class="tocitem" href="../../developer/problem/">Problem</a></li><li><a class="tocitem" href="../../developer/algorithm/">QSS Algorithms</a></li><li><a class="tocitem" href="../../developer/solve/">Solve</a></li><li><a class="tocitem" href="../../developer/integrator/">Integrators</a></li><li><a class="tocitem" href="../../developer/quantizer/">Quantizer</a></li><li><a class="tocitem" href="../../developer/solution/">Solution</a></li><li><a class="tocitem" href="../../developer/taylor/">Taylor Variables</a></li><li><a class="tocitem" href="../../developer/utils/">Utils references</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Background</a></li><li class="is-active"><a href>Linearly Implicit Quantized State System Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linearly Implicit Quantized State System Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mongibellili/QuantizedSystemSolver.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/main/docs/src/background/liqss.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Linearly-Implicit-Quantized-State-System-Methods"><a class="docs-heading-anchor" href="#Linearly-Implicit-Quantized-State-System-Methods">Linearly Implicit Quantized State System Methods</a><a id="Linearly-Implicit-Quantized-State-System-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Linearly-Implicit-Quantized-State-System-Methods" title="Permalink"></a></h1><p>Despite their advantages, explicit QSS methods are inefficient in solving stiff systems. In order to deal with stiffness, LiQSS evaluates the state derivative at future instants using a future quantized state value, as in classic implicit algorithms. The quantized state becomes a future value of the state and it is calculated smarter <a href="#refs2">[2]</a>. </p><h2 id="LIQSS1"><a class="docs-heading-anchor" href="#LIQSS1">LIQSS1</a><a id="LIQSS1-1"></a><a class="docs-heading-anchor-permalink" href="#LIQSS1" title="Permalink"></a></h2><p>In first order, we either add or subtract the quantum <span>$\Delta$</span> to the quantized state, and when when we sense a change of the derivative, we set the derivative equals to zero. </p><p class="math-container">\[\begin{equation*}
 q_i=\begin{cases}
  x_i\mp\Delta_i &amp; if  \dot x_i . \tilde{f}_i(x_i\mp\Delta_i) &gt;0  \\
  \frac{-u_{ii}}{a_{ii}} &amp; otherwise
\end{cases} 
\end{equation*}\]</p><p>where <span>$\tilde{f}_i=a_{ii}.q_i+u_{ii}$</span>  is a linear approximation of the derivative function <span>$f_i$</span> at the future instant. </p><p>The LIQSS order 1 method is defined in the following Algorithm: <strong>LIQSS1 algorithm</strong></p><ol><li>If a variable <span>$i$</span> needs to change<ul><li>Compute the elapsed time <span>$e$</span> since the last update of variable <span>$i$</span></li><li>Update its value using Taylor expansion: <span>$x_{i}=x_{i}+\dot x_i.e$</span></li><li>Update the quantum <span>$\Delta_i$</span></li><li>If <span>$\dot x . (a_{ii}.(x_i+sign(\dot x).\Delta_i)+u_{ii}) &gt;0$</span><ul><li>Update the Quantized variable <span>$q_i=x_i+sign(\dot x).\Delta_i$</span></li></ul></li><li>Else<ul><li>Update the Quantized variable <span>$q_i=\frac{-u_{ii}}{a_{ii}}$</span>   </li></ul></li><li>Compute the next time when <span>$q_i=x_i$</span> </li><li>For {any variable <span>$j$</span> depends on <span>$i$</span>}<ul><li>Update the variable <span>$x_{j}=x_{j}+\dot x_j.e_j$</span></li><li>Update the derivative <span>$\dot x_{j}=f_j(q,t)$</span> </li><li>Compute the next time when <span>$q_j=x_j \; or |q_j-x_j|=2\Delta_i$</span> </li></ul></li><li>For {any zero crossing function <span>$zc$</span> depends on <span>$i$</span>}<ul><li>Update <span>$zc$</span></li><li>Compute the next event time of <span>$zc$</span> </li></ul></li></ul></li><li>If an event needs to occur<ul><li>Recheck validity of the event</li><li>Execute the event and update the related quantized variables</li><li>For any variable <span>$j$</span> depends on the event<ul><li>Update the variable <span>$x_{j}=x_{j}+\dot x_j.e_j$</span></li><li>Update the derivative <span>$\dot x_j=f_j(Q,t)$</span> </li><li>Compute the next time when <span>$q_j=x_j \; or |q_j-x_j|=2\Delta_j$</span> </li></ul></li><li>For any zero crossing function <span>$zc$</span> depends on the event<ul><li>Update <span>$zc$</span></li><li>Compute the next event time of <span>$zc$</span> </li></ul></li></ul></li></ol><h2 id="LIQSS2"><a class="docs-heading-anchor" href="#LIQSS2">LIQSS2</a><a id="LIQSS2-1"></a><a class="docs-heading-anchor-permalink" href="#LIQSS2" title="Permalink"></a></h2><p>In Order 2, the updates involve not only the first-order variables but also their second-order derivatives. Similar to Order 1, these updates depend on the future behavior of the state variables, but with a focus on both their positions and rates of change as reflected in the second-order derivative terms. To define LIQSS2, we need to consider the second derivative of the state variables. The linear approximation of the future second derivative is given as follows: <span>$\ddot x_i=a_{ii}.\dot q_i+\dot u_{ii}$</span>.</p><p>The LIQSS order 2 method is defined in the following Algorithm. <strong>LIQSS2 algorithm</strong> </p><ol><li>If a variable <span>$i$</span> needs to change<ul><li>Compute the elapsed time <span>$e$</span> since the last update of variable <span>$i$</span></li><li>Update the variable <span>$x_{i}=x_{i}+\dot x_i.e_i+\frac{1}{2}\ddot x_i.e_i^2$</span></li><li>Update the quantum <span>$\Delta_i$</span></li><li>Update the derivative <span>$\dot x_{i}=\dot x_{i}+\ddot x_i.e$</span></li><li>Update the affine coefficient <span>$u_{ii} = \dot x_i - a_{ii} . (q_{i}+\dot q_i.e_i)$</span></li><li>Update the derivative of the affine coefficient <span>$\dot u_{ii} = \ddot x_i - a_{ii} . \dot q_i$</span></li><li>The Quantized variable <span>$q_i(h)=\frac{(x_i-h.a_{ii}.x_i-h^2.(a.u_{ii}+\dot u_{ii})/2)}{(1 - h . a_{ii} + h^2.a_{ii}^2 / 2)}$</span></li><li>Update the step size <span>$h=Final\;Simulation\;Time-current\;Sim\;Time$</span>;  <span>$q_i=q_i(h)$</span></li><li>If {<span>$|q_i-x_i|&gt;\Delta_i$</span>}<ul><li>Update the Quantized variable <span>$h=\sqrt{\frac{2\Delta_i}{|ddx_i|}}$</span>;  <span>$q_i=q_i(h)$</span></li></ul></li><li>While <span>$|q_i-x_i|&gt;\Delta_i$</span><ul><li>Update the Quantized variable <span>$h=h\sqrt{\frac{\Delta_i}{|q_i-x_i|}}$</span>;  <span>$q_i=q_i(h)$</span></li></ul></li><li>Update the Quantized derivative <span>$\dot q_i=\frac{a_{ii}.q_i+u_{ii}+h.\dot u_{ii}}{1-h.a_{ii}}$</span></li><li>Compute the next time when <span>$q_i=x_i$</span> </li><li>For any variable <span>$j$</span> depends on <span>$i$</span><ul><li>Update the variable <span>$x_{j}=x_{j}+\dot x_j.e_j+\frac{1}{2}\ddot x_j.e_j^2$</span></li><li>For {any variable <span>$k$</span> that <span>$f_j$</span> depends upon}<ul><li>Update the Quantized variable <span>$q_{k}=q_{k}+\dot q_k.e_k$</span> </li></ul></li><li>Update the derivatives <span>$\dot x_{j}=f_j(q,t) \; and \ddot x_j=\dot f_j(Q,t)$</span> </li><li>Compute the next time when <span>$q_j=x_j \; or |q_j-x_j|=2\Delta_i$</span> </li></ul></li><li>For any zero crossing function <span>$zc$</span> depends on <span>$i$</span><ul><li>For {any variable <span>$k$</span> that <span>$zc$</span> depends upon}<ul><li>Update the Quantized variable <span>$q_{k}=q_{k}+\dot q_k.e_k$</span></li></ul></li><li>Update <span>$zc$</span></li><li>Compute the next event time of <span>$zc$</span> </li></ul></li></ul></li><li>If an event needs to occur<ul><li>Recheck validity of the event</li><li>Execute the event and update the related quantized variables</li><li>For any variable <span>$j$</span> depends on the event<ul><li>Update the variable <span>$x_{j}=x_{j}+\dot x_j.e_j+\frac{1}{2}\ddot x_j.e_j^2$</span></li><li>For any variable <span>$k$</span> that <span>$f_j$</span> depends upon<ul><li>Update the Quantized variable <span>$q_{k}=q_{k}+\dot q_k.e_k$</span></li></ul></li><li>Update the derivatives <span>$\dot x_j=f_j(Q,t) \; and \ddot x_j=\dot f_j(Q,t)$</span> </li><li>Compute the next time when <span>$q_j=x_j \; or |q_j-x_j|=2\Delta_j$</span> </li></ul></li><li>For any zero crossing function <span>$zc$</span> depends on the event<ul><li>For any variable <span>$k$</span> that <span>$zc$</span> depends upon<ul><li>Update the Quantized variable <span>$q_{k}=q_{k}+\dot q_k.e_k$</span></li></ul></li><li>Update <span>$zc$</span></li><li>Compute the next event time of <span>$zc$</span> </li></ul></li></ul></li></ol><h2 id="refs2"><a class="docs-heading-anchor" href="#refs2">References</a><a id="refs2-1"></a><a class="docs-heading-anchor-permalink" href="#refs2" title="Permalink"></a></h2><p>[1]  Migoni, G., Kofman, E., and Cellier, F. (2012). Quantization-based new integration methods for stiff odes. Simulation: Transactions of the Society for Modeling and Simulation International, 88(4):378–407.</p><p>[2]  G. Migoni, M. Bortolotto, E. Kofman, and F. Cellier. Linearly implicit quantization-based integration methods for stiff ordinary differential equations. Simulation Modelling Practice and Theory, vol.35:pp.118–136, 2013.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../qss/">« Quantized State System Methods</a><a class="docs-footer-nextpage" href="../mliqss/">Modified Linearly Implicit Quantized State System Methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 12 December 2024 14:21">Thursday 12 December 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
