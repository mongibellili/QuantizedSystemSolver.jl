<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantizer · Quantized System Solver</title><meta name="title" content="Quantizer · Quantized System Solver"/><meta property="og:title" content="Quantizer · Quantized System Solver"/><meta property="twitter:title" content="Quantizer · Quantized System Solver"/><meta name="description" content="Documentation for Quantized System Solver."/><meta property="og:description" content="Documentation for Quantized System Solver."/><meta property="twitter:description" content="Documentation for Quantized System Solver."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Quantized System Solver logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quantized System Solver</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../guide/userTutorial/">Tutorial</a></li><li><a class="tocitem" href="../../guide/userAPI/">User API</a></li></ul></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../../background/introductoryResources/">Introduction to Quantized System Methods</a></li><li><a class="tocitem" href="../../background/qss/">Quantized State System Methods</a></li><li><a class="tocitem" href="../../background/liqss/">Linearly Implicit Quantized State System Methods</a></li><li><a class="tocitem" href="../../background/mliqss/">Modified Linearly Implicit Quantized State System Methods</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/linearTimeInvariantSystem/">Linear Time Invariant</a></li><li><a class="tocitem" href="../../examples/linearTimeInvariantSystemEvents/">Linear Time Invariant with events</a></li><li><a class="tocitem" href="../../examples/vanderpol/">Van der Pol</a></li><li><a class="tocitem" href="../../examples/tysonModel/">The Tyson Model</a></li><li><a class="tocitem" href="../../examples/adr/">ADR problem</a></li><li><a class="tocitem" href="../../examples/dosing/">Conditional Dosing in Pharmacometrics</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../devIntro/">Developer Guide</a></li><li><a class="tocitem" href="../problem/">Problem</a></li><li><a class="tocitem" href="../algorithm/">QSS Algorithms</a></li><li><a class="tocitem" href="../solve/">Solve</a></li><li><a class="tocitem" href="../integrator/">Integrators</a></li><li class="is-active"><a class="tocitem" href>Quantizer</a><ul class="internal"><li><a class="tocitem" href="#The-Quantizer-functions"><span>The Quantizer functions</span></a></li><li><a class="tocitem" href="#Quantizer-references"><span>Quantizer references</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../solution/">Solution</a></li><li><a class="tocitem" href="../taylor/">Taylor Variables</a></li><li><a class="tocitem" href="../utils/">Utils references</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer resources</a></li><li class="is-active"><a href>Quantizer</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quantizer</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mongibellili/QuantizedSystemSolver.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/main/docs/src/developer/quantizer.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantizer"><a class="docs-heading-anchor" href="#Quantizer">Quantizer</a><a id="Quantizer-1"></a><a class="docs-heading-anchor-permalink" href="#Quantizer" title="Permalink"></a></h1><h2 id="The-Quantizer-functions"><a class="docs-heading-anchor" href="#The-Quantizer-functions">The Quantizer functions</a><a id="The-Quantizer-functions-1"></a><a class="docs-heading-anchor-permalink" href="#The-Quantizer-functions" title="Permalink"></a></h2><p>The system handles different quantizer orders (Order 1 and Order 2...). It defines methods for state integration, derivative computation, event time computation, updating quantized values, and cycle detection updates.</p><p><strong>computeNextTime:</strong> for first-order, the state of the system changes at a constant rate. The core calculation takes place when the first derivative of the state, represented by <span>$x[i][1]$</span>, is non-zero. In this case, the function determines the time to the next event by dividing a quantum threshold by this derivative. Additionally, to prevent numerical issues, it ensures that this calculated time-step does not fall below a predefined minimum value, <span>$absDeltaT$</span>. If the first derivative is extremely small or essentially zero, the function adjusts it to avoid potential numerical instabilities that could arise from very small time increments.</p><p>For second-order, the system state evolves with both a rate of change (first derivative) and acceleration (second derivative). The core calculation occurs when the second derivative of the state, represented by <span>$x[i][2]$</span>, is non-zero. In this case, the function computes the time to the next event by using the square root of the ratio between a quantum threshold and the second derivative. This ensures that the time-step reflects the influence of the system&#39;s acceleration. Additionally, to prevent numerical issues (such as division by zero or overly small time-steps), a minimum delta time (absDeltaT) is enforced. If the computed time-step is smaller than this threshold, the function adjusts the second derivative to maintain stability. If the second derivative is zero but the first derivative is non-zero, the time to the next event is calculated based on the first derivative. The function ensures that the time-step does not drop below absDeltaT, adjusting the first derivative if necessary. If both derivatives are zero, the system is assumed to have no change, and the next event time is set to infinity (Inf).</p><p><strong>recomputeNextTime:</strong> The reComputeNextTime functions are used in the explicit QSS algorithms to enable the recalculation of the next time after interactions between different variables, such as variable i and variable j. These functions determine the time until the system crosses the quantum threshold by solving polynomial equations derived from the difference between the quantized state and the actual state. In situations where the quantum threshold has already been surpassed, they promptly return a very small time increment (e.g., simt + 1e-12) to trigger an immediate update of the system&#39;s state.</p><p><strong>LiqssrecomputeNextTime:</strong> In the LIQSS methods of first-order, the recomputeNextTime function calculates the next event time based on the current state (x), its first derivative (x1), and the quantized state (q). First, if the difference between the current state and the quantized state exceeds twice the quantum size, the next event is scheduled almost immediately with a small time-step. Otherwise, if the derivative is non-zero, the function computes the time-step by dividing the state difference by the derivative. If the result is positive, this time is added to the current simulation time (simt). If negative, it adjusts the time-step by either adding or subtracting twice the quantum size based on the direction of change. If the derivative is zero, indicating no change, the event time is set to infinity. Lastly, if the computed time is in the past, the function resets it to a far future time to prevent any premature events. This ensures that the system evolves smoothly and accurately.</p><p>In the second-order LIQSS method, the recomputeNextTime function calculates the next event time by considering both the state (x) and its first (x1) and second (x2) derivatives, along with the quantized state (q). The function constructs a polynomial using the current state, derivative values, and the second derivative, then calculates the next event time by finding the smallest positive root of this polynomial.</p><p><strong>computeNextInputTime:</strong> The computeNextInputTime functions focus on computing the next action when derivatives depend only on time. They assess changes in the derivatives over a specified elapsed time to compute the time increment until the next input action. If the derivatives are null, the function reverts to handling the system in a lower-order thus simplifying the calculation.</p><p><strong>computeNextEventTime:</strong> The computeNextEventTime function calculates the next event time based on the zero-crossing function (<span>$ZCFun$</span>) of a system. It first checks if a sign change has occurred in the zero-crossing function, indicating that the system is leaving zero and should be considered an event, provided the previous value is significantly different from zero (to prevent duplicate events). If a sign change is detected, the function updates the event time to the current simulation time. If both the old and new values of the zero-crossing function are zero, it sets the next event time to infinity, indicating no event should occur. For cases where the old and new values have the same sign, it calculates the minimum positive root of the zero-crossing function, representing the time of the next event, ensuring that this time is not too close to zero to avoid spurious events. The function then updates the old sign values for future comparisons.</p><h2 id="Quantizer-references"><a class="docs-heading-anchor" href="#Quantizer-references">Quantizer references</a><a id="Quantizer-references-1"></a><a class="docs-heading-anchor-permalink" href="#Quantizer-references" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.integrateState-Tuple{Val{0}, Taylor0, Float64}" href="#QuantizedSystemSolver.integrateState-Tuple{Val{0}, Taylor0, Float64}"><code>QuantizedSystemSolver.integrateState</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrateState(::Val{0}, x::Taylor0, elapsed::Float64)</code></pre><p>does nothing: created for elapse-updating q in order1 which does not happen. This is needed in order to have one integrator function for all orders.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerQss.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.integrateState-Tuple{Val{1}, Taylor0, Float64}" href="#QuantizedSystemSolver.integrateState-Tuple{Val{1}, Taylor0, Float64}"><code>QuantizedSystemSolver.integrateState</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrateState(::Val{1}, x::Taylor0, elapsed::Float64)</code></pre><p>Integrates the state for a first-order quantized system.</p><p><strong>Arguments</strong></p><ul><li><code>::Val{1}</code>: A type parameter indicating the order of the quantized system.</li><li><code>x::Taylor0</code>: The current state variable x represented as a <code>Taylor0</code> object.</li><li><code>elapsed::Float64</code>: The elapsed time since the last integration step of this variable x.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerQss.jl#L10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.integrateState-Tuple{Val{2}, Taylor0, Float64}" href="#QuantizedSystemSolver.integrateState-Tuple{Val{2}, Taylor0, Float64}"><code>QuantizedSystemSolver.integrateState</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">integrateState(::Val{2}, x::Taylor0, elapsed::Float64)</code></pre><p>Integrates a state variable x and its first derivative using a second-order Taylor series approximation</p><p><strong>Arguments</strong></p><ul><li><code>::Val{2}</code>: A type parameter indicating the order of the Taylor series (second-order in this case).</li><li><code>x::Taylor0</code>: The current state variable x represented as a Taylor0 object.</li><li><code>elapsed::Float64</code>: The elapsed time over which to integrate the state x.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerQss.jl#L26-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.computeDerivative-Tuple{Val{1}, Taylor0, Taylor0}" href="#QuantizedSystemSolver.computeDerivative-Tuple{Val{1}, Taylor0, Taylor0}"><code>QuantizedSystemSolver.computeDerivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeDerivative(::Val{1}, x::Taylor0, f::Taylor0)</code></pre><p>copies the derivative from <code>f</code> to the first derivative of x for the first order.</p><p><strong>Arguments</strong></p><ul><li><code>::Val{1}</code>: A type parameter indicating the order of the derivative.</li><li><code>x::Taylor0</code>: The state variable .</li><li><code>f::Taylor0</code>: The Taylor series function that corresponds to the derivative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerQss.jl#L43-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.computeDerivative-Tuple{Val{2}, Taylor0, Taylor0}" href="#QuantizedSystemSolver.computeDerivative-Tuple{Val{2}, Taylor0, Taylor0}"><code>QuantizedSystemSolver.computeDerivative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeDerivative(::Val{2}, x::Taylor0, f::Taylor0)</code></pre><p>copies the first and second derivatives from <code>f</code> to the derivatives of x for the second-order quantizer.</p><p><strong>Arguments</strong></p><ul><li><code>::Val{2}</code>: A type parameter indicating the order of the quantizer.</li><li><code>x::Taylor0</code>: The state variable .</li><li><code>f::Taylor0</code>: The Taylor series function that corresponds to the derivative.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerQss.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.computeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}" href="#QuantizedSystemSolver.computeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.computeNextTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeNextTime(::Val{1}, i::Int, simt::Float64, nextTime::Vector{Float64}, x::Vector{Taylor0}, quantum::Vector{Float64})</code></pre><p>Compute the next time of change for a given state variable.</p><p><strong>Arguments</strong></p><ul><li><code>::Val{1}</code>: A type parameter indicating a first order quantization method.</li><li><code>i::Int</code>: The index of the current state variable.</li><li><code>simt::Float64</code>: The current simulation time.</li><li><code>nextTime::Vector{Float64}</code>: A vector containing the next time values for each state variable.</li><li><code>x::Vector{Taylor0}</code>: A vector of Taylor series coefficients representing the state variables and their derivatives.</li><li><code>quantum::Vector{Float64}</code>: A vector containing the quantum values for the state variables.</li></ul><p><strong>Returns</strong></p><ul><li>The function updates the <code>nextTime</code> vector with the computed next time values for the state variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerQss.jl#L79-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.computeNextTime-Tuple{Val{2}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}" href="#QuantizedSystemSolver.computeNextTime-Tuple{Val{2}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.computeNextTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeNextTime(::Val{2}, i::Int, simt::Float64, nextTime::Vector{Float64}, x::Vector{Taylor0}, quantum::Vector{Float64})</code></pre><p>Compute the next time for a given state variable <code>i</code> in a second-order quantized system.</p><p><strong>Arguments</strong></p><ul><li><code>::Val{2}</code>: A type parameter indicating the order of the quantized system (second-order).</li><li><code>i::Int</code>: The index of variable for which the next time is being computed.</li><li><code>simt::Float64</code>: The current simulation time.</li><li><code>nextTime::Vector{Float64}</code>: A vector containing the next times for all variables.</li><li><code>x::Vector{Taylor0}</code>: A vector of Taylor series coefficients representing the state variables and their derivatives.</li><li><code>quantum::Vector{Float64}</code>: A vector of quantum values for the state variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>Nothing</code>: This function updates the <code>nextTime</code> vector in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerQss.jl#L111-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.reComputeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}" href="#QuantizedSystemSolver.reComputeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.reComputeNextTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reComputeNextTime(::Val{1}, index::Int, simt::Float64, nextTime::Vector{Float64}, x::Vector{Taylor0}, q::Vector{Taylor0}, quantum::Vector{Float64})</code></pre><p>Recomputes the next time for a given state variable <code>i</code> in a first-order quantized system after the derivative has changed. similar to <a href="#QuantizedSystemSolver.computeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}"><code>computeNextTime</code></a> but it also account for the first derivative change.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerQss.jl#L154-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.reComputeNextTime-Tuple{Val{2}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}" href="#QuantizedSystemSolver.reComputeNextTime-Tuple{Val{2}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.reComputeNextTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reComputeNextTime(::Val{2}, index::Int, simt::Float64, nextTime::Vector{Float64}, x::Vector{Taylor0}, q::Vector{Taylor0}, quantum::Vector{Float64})</code></pre><p>Recomputes the next time for a given state variable <code>i</code> in a second-order quantized system after the derivatives have changed. similar to <a href="#QuantizedSystemSolver.computeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}"><code>computeNextTime</code></a> but it also account for the first and second derivatives changes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerQss.jl#L174-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.computeNextInputTime-Tuple{Val{1}, Int64, Float64, Float64, Taylor0, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}" href="#QuantizedSystemSolver.computeNextInputTime-Tuple{Val{1}, Int64, Float64, Float64, Taylor0, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.computeNextInputTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeNextInputTime(::Val{1}, i::Int, simt::Float64, elapsed::Float64, tt::Taylor0, nextInputTime::Vector{Float64}, x::Vector{Taylor0}, quantum::Vector{Float64})</code></pre><p>Compute the next input time for a given state variable in a first order method. This is needed when the differential equation depends on time only (i.e. does not depend on other state variables). It uses a prediction of the derivatives.</p><p><strong>Arguments</strong></p><ul><li><code>::Val{1}</code>: A type parameter indicating the specific method to use.</li><li><code>i::Int</code>: The index of the current state variable.</li><li><code>simt::Float64</code>: The current simulation time.</li><li><code>elapsed::Float64</code>: The elapsed time since the last update.</li><li><code>tt::Taylor0</code>: The Taylor series expansion of the state variable in a small time advance.</li><li><code>nextInputTime::Vector{Float64}</code>: A vector to store the computed next input times.</li><li><code>x::Vector{Taylor0}</code>: A vector of Taylor series expansions of the state variables.</li><li><code>quantum::Vector{Float64}</code>: A vector of quantum values for the state variables.</li></ul><p><strong>Returns</strong></p><ul><li>Nothing, it updates the <code>nextInputTime</code> vector with the next input times for the state variables.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerQss.jl#L196-L213">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.computeNextInputTime-Tuple{Val{2}, Int64, Float64, Float64, Taylor0, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}" href="#QuantizedSystemSolver.computeNextInputTime-Tuple{Val{2}, Int64, Float64, Float64, Taylor0, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.computeNextInputTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeNextInputTime(::Val{2}, i::Int, simt::Float64, elapsed::Float64, tt::Taylor0, nextInputTime::Vector{Float64}, x::Vector{Taylor0}, quantum::Vector{Float64})</code></pre><p>Compute the next input time for a given state variable in a second order method. This is needed when the differential equation depends on time only (i.e. does not depend on other state variables). It uses a prediction of the derivatives.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerQss.jl#L231-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.computeNextEventTime-Union{Tuple{Z}, Tuple{O}, Tuple{Val{O}, Int64, Taylor0, MMatrix{Z, 2}, Float64, MVector{Z, Float64}, Vector{Float64}, Float64}} where {O, Z}" href="#QuantizedSystemSolver.computeNextEventTime-Union{Tuple{Z}, Tuple{O}, Tuple{Val{O}, Int64, Taylor0, MMatrix{Z, 2}, Float64, MVector{Z, Float64}, Vector{Float64}, Float64}} where {O, Z}"><code>QuantizedSystemSolver.computeNextEventTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeNextEventTime(::Val{O},j::Int,ZCFun::Taylor0,oldsignValue::MMatrix{Z,2} ,simt::Float64,  nextEventTime :: MVector{Z,Float64}, quantum::Vector{Float64},absQ::Float64) where {O, Z}</code></pre><p>Compute the next event time for a given zero-crossing function.</p><p><strong>Arguments</strong></p><ul><li><code>::Val{O}</code>: A type parameter indicating the order of the quantizer.</li><li><code>j::Int</code>: The index of the zero-crossing function being processed.</li><li><code>ZCFun::Taylor0</code>: the value of the zero-crossing function of type <code>Taylor0</code>.</li><li><code>oldsignValue::MMatrix{Z,2}</code>: The previous sign and value of the zero-crossing function.</li><li><code>simt::Float64</code>: The current simulation time.</li><li><code>nextEventTime:: MVector{Z,Float64}</code>: Vector contains the next event time for all zero-crossing functions.</li><li><code>quantum::Vector{Float64}</code>: A vector of quantum values for the state variables.</li><li><code>absQ::Float64</code>: The absolute quantum value.</li></ul><p><strong>Returns</strong></p><ul><li>The computed next event time for the state variable <code>j</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerQss.jl#L269-L286">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.updateQ-Tuple{Val{1}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}" href="#QuantizedSystemSolver.updateQ-Tuple{Val{1}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}"><code>QuantizedSystemSolver.updateQ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateQ(::Val{1}, i::Int, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64}, exactA::Function, d::Vector{Float64}, cacheA::MVector{1,Float64}, dxaux::Vector{MVector{1,Float64}}, qaux::Vector{MVector{1,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64, nextStateTime::Vector{Float64})</code></pre><p>Update the quantized state for the LIQSS1 (Linearly Implicit Quantized State System 1) method.</p><p><strong>Arguments</strong></p><ul><li><code>::Val{1}</code>: Type parameter indicating the LIQSS1 method.</li><li><code>i::Int</code>: Index of the state variable to update.</li><li><code>xv::Vector{Taylor0}</code>: Vector of current state values.</li><li><code>qv::Vector{Taylor0}</code>: Vector of quantized state values.</li><li><code>quantum::Vector{Float64}</code>: Vector of quantum values for the state variables.</li><li><code>exactA::Function</code>: Function to compute the exact value of a jacobian entry.</li><li><code>d::Vector{Float64}</code>: Vector of discrete variables.</li><li><code>cacheA::MVector{1,Float64}</code>: Cache for jacobian entry computation.</li><li><code>dxaux::Vector{MVector{1,Float64}}</code>: Auxiliary vector for saving old x values.</li><li><code>qaux::Vector{MVector{1,Float64}}</code>: Auxiliary vector for saving old quantized values.</li><li><code>tx::Vector{Float64}</code>: Vector of times at which the state variables were updated.</li><li><code>tq::Vector{Float64}</code>: Vector of times at which the quantized state variables were updated.</li><li><code>simt::Float64</code>: Current simulation time.</li><li><code>ft::Float64</code>: Final time of the simulation.</li><li><code>nextStateTime::Vector{Float64}</code>: Vector of times at which the state variables will be updated next.</li></ul><p><strong>Returns</strong></p><ul><li>None. The function updates the quantized state and other info in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerLiqss1.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.updateQInit-Tuple{Val{1}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}" href="#QuantizedSystemSolver.updateQInit-Tuple{Val{1}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}"><code>QuantizedSystemSolver.updateQInit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateQInit(::Val{1}, i::Int, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64}, exactA::Function, d::Vector{Float64}, cacheA::MVector{1,Float64}, dxaux::Vector{MVector{1,Float64}}, qaux::Vector{MVector{1,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64, nextStateTime::Vector{Float64})</code></pre><p>Initialize the quantized state for the LIQSS1 method.</p><p><strong>Arguments</strong></p><ul><li><code>::Val{1}</code>: Type parameter indicating the LIQSS1 method.</li><li><code>i::Int</code>: Index of the state variable to update.</li><li><code>xv::Vector{Taylor0}</code>: Vector of state variables.</li><li><code>qv::Vector{Taylor0}</code>: Vector of quantized state variables.</li><li><code>quantum::Vector{Float64}</code>: Vector of quantum values for the state variables.</li><li><code>exactA::Function</code>: Function to compute the exact value of the state variable.</li><li><code>d::Vector{Float64}</code>: Vector of derivatives of the state variables.</li><li><code>cacheA::MVector{1,Float64}</code>: Cache for intermediate computations.</li><li><code>dxaux::Vector{MVector{1,Float64}}</code>: Auxiliary vector for derivatives.</li><li><code>qaux::Vector{MVector{1,Float64}}</code>: Auxiliary vector for quantized states.</li><li><code>tx::Vector{Float64}</code>: Vector of times at which state variables were last updated.</li><li><code>tq::Vector{Float64}</code>: Vector of times at which quantized state variables were last updated.</li><li><code>simt::Float64</code>: Current simulation time.</li><li><code>ft::Float64</code>: Final simulation time.</li><li><code>nextStateTime::Vector{Float64}</code>: Vector of times at which the next state update is scheduled.</li></ul><p><strong>Description</strong></p><p>This function initializes the quantized state for the LIQSS1 method by updating the quantized state variables and their associated times based on the provided state variables, derivatives, and quantum values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerLiqss1.jl#L88-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.Liqss_reComputeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}" href="#QuantizedSystemSolver.Liqss_reComputeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.Liqss_reComputeNextTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Liqss_reComputeNextTime(::Val{1}, i::Int, simt::Float64, nextStateTime::Vector{Float64}, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64})</code></pre><p>Recomputes the next time for the LIQSS1 quantizer.</p><p><strong>Arguments</strong></p><ul><li><code>::Val{1}</code>: Type parameter indicating the LIQSS1 method.</li><li><code>i::Int</code>: Index of the state variable.</li><li><code>simt::Float64</code>: Current simulation time.</li><li><code>nextStateTime::Vector{Float64}</code>: Vector containing the next state times for each state variable.</li><li><code>xv::Vector{Taylor0}</code>: Vector of current state values represented as Taylor series.</li><li><code>qv::Vector{Taylor0}</code>: Vector of quantized state values represented as Taylor series.</li><li><code>quantum::Vector{Float64}</code>: Vector of quantum values for the state variables.</li></ul><p><strong>Returns</strong></p><ul><li>Updates the <code>nextStateTime</code> vector with the recomputed next time for the specified state variable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerLiqss1.jl#L177-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.nmisCycle_and_simulUpdate-Tuple{Float64, Float64, Any, Val{1}, Int64, Int64, Float64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64}" href="#QuantizedSystemSolver.nmisCycle_and_simulUpdate-Tuple{Float64, Float64, Any, Val{1}, Int64, Int64, Float64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64}"><code>QuantizedSystemSolver.nmisCycle_and_simulUpdate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nmisCycle_and_simulUpdate(aij::Float64, aji::Float64, trackSimul, ::Val{1}, index::Int, j::Int, dirI::Float64, x::Vector{Taylor0}, q::Vector{Taylor0}, quantum::Vector{Float64}, exactA::Function, d::Vector{Float64}, cacheA::MVector{1,Float64}, dxaux::Vector{MVector{1,Float64}}, qaux::Vector{MVector{1,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64)</code></pre><p>Performs a simultaneous update of two quantized variables <code>qi</code> and <code>qj</code> if cycle conditions are met.</p><p><strong>Arguments</strong></p><ul><li><code>aij::Float64</code>: linear approximation Coefficient for the jacobian entry between variable i and variable j.</li><li><code>aji::Float64</code>: linear approximation Coefficient for the jacobian entry between variable j and variable i.</li><li><code>trackSimul</code>: A tracking object for the simulataneous update.</li><li><code>::Val{1}</code>: A type parameter indicating the method variant.</li><li><code>index::Int</code>: The index of the current variable.</li><li><code>j::Int</code>: The index of the interacting variable.</li><li><code>dirI::Float64</code>: Direction of variable i.</li><li><code>x::Vector{Taylor0}</code>: State vector of Taylor series coefficients for the variables.</li><li><code>q::Vector{Taylor0}</code>: Quantized state vector of Taylor series coefficients for the variables.</li><li><code>quantum::Vector{Float64}</code>: Quantum levels for the variables.</li><li><code>exactA::Function</code>: Function to compute the exact value of a jacobian entry.</li><li><code>d::Vector{Float64}</code>: discrete variables.</li><li><code>cacheA::MVector{1,Float64}</code>: Cache for jacobian entry computation.</li><li><code>dxaux::Vector{MVector{1,Float64}}</code>: Auxiliary vector for old x values.</li><li><code>qaux::Vector{MVector{1,Float64}}</code>: Auxiliary vector for old quantized values.</li><li><code>tx::Vector{Float64}</code>: Time vector for state updates.</li><li><code>tq::Vector{Float64}</code>: Time vector for quantized state updates.</li><li><code>simt::Float64</code>: Current simulation time.</li><li><code>ft::Float64</code>: Final time for the simulation.</li></ul><p><strong>Returns</strong></p><ul><li>None. The function performs in-place updates on the quantized state vectors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerMliqss1.jl#L2-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.updateQ-Tuple{Val{2}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{2, Float64}}, Vector{MVector{2, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}" href="#QuantizedSystemSolver.updateQ-Tuple{Val{2}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{2, Float64}}, Vector{MVector{2, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}"><code>QuantizedSystemSolver.updateQ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateQ(::Val{2}, i::Int, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64}, exactA::Function, d::Vector{Float64}, cacheA::MVector{1,Float64}, dxaux::Vector{MVector{2,Float64}}, qaux::Vector{MVector{2,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64, nextStateTime::Vector{Float64})</code></pre><p>Update the quantized state for the second-order quantizer.</p><p><strong>Arguments</strong></p><ul><li><code>::Val{2}</code>: Type parameter indicating the second-order quantizer.</li><li><code>i::Int</code>: Index of the state variable to update.</li><li><code>xv::Vector{Taylor0}</code>: Vector of state variables.</li><li><code>qv::Vector{Taylor0}</code>: Vector of quantized state variables.</li><li><code>quantum::Vector{Float64}</code>: Vector of quantum values of the state variables.</li><li><code>exactA::Function</code>: Function to compute the exact value of a jacobian entry.</li><li><code>d::Vector{Float64}</code>: Vector of discrete variables.</li><li><code>cacheA::MVector{1,Float64}</code>: Cache for jacobian entry computation.</li><li><code>dxaux::Vector{MVector{2,Float64}}</code>: Auxiliary vector for saving old x values.</li><li><code>qaux::Vector{MVector{2,Float64}}</code>: Auxiliary vector for saving old quantized values.</li><li><code>tx::Vector{Float64}</code>: Vector of state update times.</li><li><code>tq::Vector{Float64}</code>: Vector of quantized state update times.</li><li><code>simt::Float64</code>: Current simulation time.</li><li><code>ft::Float64</code>: Final time of the simulation.</li><li><code>nextStateTime::Vector{Float64}</code>: Vector of times for the next state updates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerLiqss2.jl#L2-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.updateQInit-Tuple{Val{2}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{2, Float64}}, Vector{MVector{2, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}" href="#QuantizedSystemSolver.updateQInit-Tuple{Val{2}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{2, Float64}}, Vector{MVector{2, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}"><code>QuantizedSystemSolver.updateQInit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateQInit(::Val{2}, i::Int, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64}, exactA::Function, d::Vector{Float64}, cacheA::MVector{1,Float64}, dxaux::Vector{MVector{2,Float64}}, qaux::Vector{MVector{2,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64, nextStateTime::Vector{Float64})</code></pre><p>Initialize the quantized state variables for the LIQSS2 method. It is similar to the <a href="#QuantizedSystemSolver.updateQ-Tuple{Val{1}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}"><code>updateQ</code></a> function but does not accept q to be set to x when all derivatives are zero, which is the case when an equilibrium ocurrs during the simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerLiqss2.jl#L102-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.Liqss_reComputeNextTime-Tuple{Val{2}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}" href="#QuantizedSystemSolver.Liqss_reComputeNextTime-Tuple{Val{2}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.Liqss_reComputeNextTime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Liqss_reComputeNextTime(::Val{2}, i::Int, simt::Float64, nextStateTime::Vector{Float64}, xv::Vector{Taylor0}, qv::Vector{Taylor0}, quantum::Vector{Float64})</code></pre><p>Recomputes the next time for a given state in a second-order quantized state system.</p><p><strong>Arguments</strong></p><ul><li><code>::Val{2}</code>: A type parameter indicating the order of the quantized state system (second-order in this case).</li><li><code>i::Int</code>: The index of the state for which the next time is being recomputed.</li><li><code>simt::Float64</code>: The current simulation time.</li><li><code>nextStateTime::Vector{Float64}</code>: A vector containing the next state times for all states.</li><li><code>xv::Vector{Taylor0}</code>: A vector containing the current state values represented as Taylor series.</li><li><code>qv::Vector{Taylor0}</code>: A vector containing the quantized state values represented as Taylor series.</li><li><code>quantum::Vector{Float64}</code>: A vector containing the quantum values the states.</li></ul><p><strong>Returns</strong></p><ul><li>This function does not return a value. It updates the <code>nextStateTime</code> vector in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerLiqss2.jl#L181-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.nmisCycle_and_simulUpdate-Tuple{Float64, Float64, Any, Val{2}, Int64, Int64, Float64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{2, Float64}}, Vector{MVector{2, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64}" href="#QuantizedSystemSolver.nmisCycle_and_simulUpdate-Tuple{Float64, Float64, Any, Val{2}, Int64, Int64, Float64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{2, Float64}}, Vector{MVector{2, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64}"><code>QuantizedSystemSolver.nmisCycle_and_simulUpdate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nmisCycle_and_simulUpdate(aij::Float64, aji::Float64, trackSimul, ::Val{2}, index::Int, j::Int, dirI::Float64, x::Vector{Taylor0}, q::Vector{Taylor0}, quantum::Vector{Float64}, exactA::Function, d::Vector{Float64}, cacheA::MVector{1,Float64}, dxaux::Vector{MVector{2,Float64}}, qaux::Vector{MVector{2,Float64}}, tx::Vector{Float64}, tq::Vector{Float64}, simt::Float64, ft::Float64)</code></pre><p>Performs a simultaneous update of two quantized variables <code>qi</code> and <code>qj</code> and their derivatives if cycle conditions are met. This is similar to the <a href="#QuantizedSystemSolver.nmisCycle_and_simulUpdate-Tuple{Float64, Float64, Any, Val{1}, Int64, Int64, Float64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64}"><code>nmisCycle_and_simulUpdate</code></a> order 1 function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/d327df8d84df57dc0ef56c162842225f70d88614/src/quantizers/quantizerMliqss2.jl#L1-L6">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#QuantizedSystemSolver.Liqss_reComputeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.Liqss_reComputeNextTime</code></a></li><li><a href="#QuantizedSystemSolver.Liqss_reComputeNextTime-Tuple{Val{2}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.Liqss_reComputeNextTime</code></a></li><li><a href="#QuantizedSystemSolver.computeDerivative-Tuple{Val{1}, Taylor0, Taylor0}"><code>QuantizedSystemSolver.computeDerivative</code></a></li><li><a href="#QuantizedSystemSolver.computeDerivative-Tuple{Val{2}, Taylor0, Taylor0}"><code>QuantizedSystemSolver.computeDerivative</code></a></li><li><a href="#QuantizedSystemSolver.computeNextEventTime-Union{Tuple{Z}, Tuple{O}, Tuple{Val{O}, Int64, Taylor0, MMatrix{Z, 2}, Float64, MVector{Z, Float64}, Vector{Float64}, Float64}} where {O, Z}"><code>QuantizedSystemSolver.computeNextEventTime</code></a></li><li><a href="#QuantizedSystemSolver.computeNextInputTime-Tuple{Val{2}, Int64, Float64, Float64, Taylor0, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.computeNextInputTime</code></a></li><li><a href="#QuantizedSystemSolver.computeNextInputTime-Tuple{Val{1}, Int64, Float64, Float64, Taylor0, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.computeNextInputTime</code></a></li><li><a href="#QuantizedSystemSolver.computeNextTime-Tuple{Val{2}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.computeNextTime</code></a></li><li><a href="#QuantizedSystemSolver.computeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.computeNextTime</code></a></li><li><a href="#QuantizedSystemSolver.integrateState-Tuple{Val{1}, Taylor0, Float64}"><code>QuantizedSystemSolver.integrateState</code></a></li><li><a href="#QuantizedSystemSolver.integrateState-Tuple{Val{0}, Taylor0, Float64}"><code>QuantizedSystemSolver.integrateState</code></a></li><li><a href="#QuantizedSystemSolver.integrateState-Tuple{Val{2}, Taylor0, Float64}"><code>QuantizedSystemSolver.integrateState</code></a></li><li><a href="#QuantizedSystemSolver.nmisCycle_and_simulUpdate-Tuple{Float64, Float64, Any, Val{1}, Int64, Int64, Float64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64}"><code>QuantizedSystemSolver.nmisCycle_and_simulUpdate</code></a></li><li><a href="#QuantizedSystemSolver.nmisCycle_and_simulUpdate-Tuple{Float64, Float64, Any, Val{2}, Int64, Int64, Float64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{2, Float64}}, Vector{MVector{2, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64}"><code>QuantizedSystemSolver.nmisCycle_and_simulUpdate</code></a></li><li><a href="#QuantizedSystemSolver.reComputeNextTime-Tuple{Val{1}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.reComputeNextTime</code></a></li><li><a href="#QuantizedSystemSolver.reComputeNextTime-Tuple{Val{2}, Int64, Float64, Vector{Float64}, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}}"><code>QuantizedSystemSolver.reComputeNextTime</code></a></li><li><a href="#QuantizedSystemSolver.updateQ-Tuple{Val{2}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{2, Float64}}, Vector{MVector{2, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}"><code>QuantizedSystemSolver.updateQ</code></a></li><li><a href="#QuantizedSystemSolver.updateQ-Tuple{Val{1}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}"><code>QuantizedSystemSolver.updateQ</code></a></li><li><a href="#QuantizedSystemSolver.updateQInit-Tuple{Val{1}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{1, Float64}}, Vector{MVector{1, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}"><code>QuantizedSystemSolver.updateQInit</code></a></li><li><a href="#QuantizedSystemSolver.updateQInit-Tuple{Val{2}, Int64, Vector{Taylor0}, Vector{Taylor0}, Vector{Float64}, Function, Vector{Float64}, MVector{1, Float64}, Vector{MVector{2, Float64}}, Vector{MVector{2, Float64}}, Vector{Float64}, Vector{Float64}, Float64, Float64, Vector{Float64}}"><code>QuantizedSystemSolver.updateQInit</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../integrator/">« Integrators</a><a class="docs-footer-nextpage" href="../solution/">Solution »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Tuesday 10 December 2024 14:55">Tuesday 10 December 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
