<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Normalize_IR · Quantized System Solver</title><meta name="title" content="Normalize_IR · Quantized System Solver"/><meta property="og:title" content="Normalize_IR · Quantized System Solver"/><meta property="twitter:title" content="Normalize_IR · Quantized System Solver"/><meta name="description" content="Documentation for Quantized System Solver."/><meta property="og:description" content="Documentation for Quantized System Solver."/><meta property="twitter:description" content="Documentation for Quantized System Solver."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Quantized System Solver logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quantized System Solver</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../guide/userTutorial/">Tutorial</a></li><li><a class="tocitem" href="../../guide/userAPI/">User API</a></li></ul></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../../background/introductoryResources/">Introduction to Quantized System Methods</a></li><li><a class="tocitem" href="../../background/qss/">Quantized State System Methods</a></li><li><a class="tocitem" href="../../background/liqss/">Linearly Implicit Quantized State System Methods</a></li><li><a class="tocitem" href="../../background/mliqss/">Modified Linearly Implicit Quantized State System Methods</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/linearTimeInvariantSystem/">Linear Time Invariant</a></li><li><a class="tocitem" href="../../examples/linearTimeInvariantSystemEvents/">Linear Time Invariant with events</a></li><li><a class="tocitem" href="../../examples/vanderpol/">Van der Pol</a></li><li><a class="tocitem" href="../../examples/tysonModel/">The Tyson Model</a></li><li><a class="tocitem" href="../../examples/adr/">ADR problem</a></li><li><a class="tocitem" href="../../examples/dosing/">Conditional Dosing in Pharmacometrics</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../devIntro/">Developer Guide</a></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox" checked/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">IR model</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Normalize_IR</a><ul class="internal"><li><a class="tocitem" href="#allow-composite-if_statments-and-normalize"><span>allow composite if_statments and normalize</span></a></li></ul></li><li><a class="tocitem" href="../intermediateRepresentation/">IR</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">problem construction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../problem/">Problem</a></li><li><a class="tocitem" href="../problemFunction/">Problem Function</a></li><li><a class="tocitem" href="../problem_references/">Problem Internals</a></li></ul></li><li><a class="tocitem" href="../algorithm/">QSS Algorithms</a></li><li><a class="tocitem" href="../solve/">Solve</a></li><li><a class="tocitem" href="../integrator/">Integrators</a></li><li><a class="tocitem" href="../quantizer/">Quantizer</a></li><li><a class="tocitem" href="../solution/">Solution</a></li><li><a class="tocitem" href="../taylor/">Taylor Variables</a></li><li><a class="tocitem" href="../utils/">Utils references</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer resources</a></li><li><a class="is-disabled">IR model</a></li><li class="is-active"><a href>Normalize_IR</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Normalize_IR</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mongibellili/QuantizedSystemSolver.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/main/docs/src/developer/normalize_ir.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Normalize_IR"><a class="docs-heading-anchor" href="#Normalize_IR">Normalize_IR</a><a id="Normalize_IR-1"></a><a class="docs-heading-anchor-permalink" href="#Normalize_IR" title="Permalink"></a></h1><h2 id="allow-composite-if_statments-and-normalize"><a class="docs-heading-anchor" href="#allow-composite-if_statments-and-normalize">allow composite if_statments and normalize</a><a id="allow-composite-if_statments-and-normalize-1"></a><a class="docs-heading-anchor-permalink" href="#allow-composite-if_statments-and-normalize" title="Permalink"></a></h2><p>allow event conditions to be composite (contain &amp;&amp;, || ). </p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><pre><code class="language-Julia hljs">if u[1]+u[2] &gt; u[3] &amp;&amp; u &lt; 10 || u &gt; 5 &amp;&amp; u &lt; 15 || u &gt; 20 
    a = 0
end</code></pre><h3 id="Solution"><a class="docs-heading-anchor" href="#Solution">Solution</a><a id="Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Solution" title="Permalink"></a></h3><p>case1) &amp;&amp; ; without else</p><pre><code class="language-Julia hljs">if A&gt;0 &amp;&amp; B&gt;0
   X
end</code></pre><p>&lt;–&gt;</p><pre><code class="language-Julia hljs">if A&gt;0 
    if  B&gt;0
      X
   end
end   
if B&gt;0 
    if  A&gt;0
      X
   end
end  </code></pre><p>case2) &amp;&amp; ; with else</p><pre><code class="language-Julia hljs">if A&gt;0 &amp;&amp; B&gt;0
   X
else
  Y
end</code></pre><p>&lt;–&gt;</p><pre><code class="language-Julia hljs">if A&gt;0 
    if  B&gt;0
      X
   end
else
   Y
end   
if B&gt;0 
    if  A&gt;0
      X
   end
else
   Y
end  </code></pre><p>case3) || ; without else</p><pre><code class="language-Julia hljs">if A&gt;0 || B&gt;0
   X
end</code></pre><p>&lt;–&gt;</p><pre><code class="language-Julia hljs">if A&gt;0 
      X
end   
if B&gt;0 
      X
end </code></pre><p>case4) || ; with else</p><pre><code class="language-Julia hljs">if A&gt;0 || B&gt;0
   X
else
  Y
end</code></pre><p>&lt;–&gt;</p><pre><code class="language-Julia hljs">if A&gt;0 
   X
else
      if  !(B&gt;0)
         Y
      end
end   
if B&gt;0 
      X
else
     if !(A&gt;0)
       Y
    end
end  </code></pre><p>case5) multiple || &amp;&amp; ;with or without else</p><pre><code class="language-Julia hljs">if A&gt;0 || B&gt;0 &amp;&amp; C&gt;0 #.....
      #(with or without else : the logic is the same)
end</code></pre><p>&lt;–&gt;</p><pre><code class="language-Julia hljs">if A&gt;0 
      #whole user if-statment and its body
end
if B&gt;0 
      #whole user if-statment and its body
end
if C&gt;0 
     #whole user if-statment and its body
end</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.SimpleModelIR.changeVarNames_params-Tuple{Expr, Symbol, Symbol, Symbol, Dict{Symbol, Union{Float64, Int64, Expr, Symbol}}, Set{Symbol}}" href="#QuantizedSystemSolver.SimpleModelIR.changeVarNames_params-Tuple{Expr, Symbol, Symbol, Symbol, Dict{Symbol, Union{Float64, Int64, Expr, Symbol}}, Set{Symbol}}"><code>QuantizedSystemSolver.SimpleModelIR.changeVarNames_params</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">changeVarNames_params(ex::Expr,stateVarName::Symbol,discrParamName::Symbol,muteVar::Symbol,param::Dict{Symbol,Union{Float64,Int64,Expr,Symbol}},helperFunSymSet::Set{Symbol})</code></pre><p>As the name suggests, this changes the continuous variables names to :q and the discrete variable name to :p and any mute variables to :i. It also plugs the parameters values from a parameter dictionary into the differential equations. The function changeVarNames_params has three methods. One for RHS of equations, one for if-statements when RHS is an expression, and one for if-statements when RHS is a symbol. This is method one. It has an additional symDict::Dict{Symbol,Expr} to collect the translation of symbols of continous and discrete variables (q[i] &lt;-&gt; qi). </p><p><strong>arguments:</strong></p><ul><li><code>ex::Expr</code>: the expression to be changed</li><li><code>stateVarName::Symbol</code>: the name of the state variable</li><li><code>muteVar::Symbol</code>: the name of the mute variable</li><li><code>param::Dict{Symbol,Union{Float64,Int64,Expr,Symbol}}</code>: the dictionary of parameters</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver

(ex, stateVarName, discrParamName,muteVar, param) = (:(du[k] = u[k] * u[k - 1] * coef2), :u,:p, :k, Dict{Symbol, Union{Float64, Int64,Expr,Symbol}}(:coef1 =&gt; 2.0, :coef2 =&gt; 1.5))

  newEx=QuantizedSystemSolver.changeVarNames_params(ex, stateVarName,discrParamName, muteVar, param,Set([:f]))
(newEx, stateVarName, muteVar, param)
# output

(:(du[i] = q[i] * q[i - 1] * 1.5), :u, :k, Dict{Symbol, Union{Float64, Int64, Expr, Symbol}}(:coef1 =&gt; 2.0, :coef2 =&gt; 1.5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/simpleModelIR/normalize_ir.jl#L38-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.SimpleModelIR.changeVarNames_params-Tuple{Symbol, Symbol, Symbol, Symbol, Dict{Symbol, Union{Float64, Int64, Expr, Symbol}}, Set{Symbol}}" href="#QuantizedSystemSolver.SimpleModelIR.changeVarNames_params-Tuple{Symbol, Symbol, Symbol, Symbol, Dict{Symbol, Union{Float64, Int64, Expr, Symbol}}, Set{Symbol}}"><code>QuantizedSystemSolver.SimpleModelIR.changeVarNames_params</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">changeVarNames_params(element::Symbol,stateVarName::Symbol,discrParamName::Symbol,muteVar::Symbol,param::Dict{Symbol,Union{Float64,Int64,Expr,Symbol}},helperFunSymSet::Set{Symbol})</code></pre><p>This is method three of the function changeVarNames_params. It is for if-statements when RHS is a symbol.  Again, it changes the symbol to :q if it is a continuous variable, to :p if it is a discrete variable, to :i if it is a mute variable, and to its corresponding value if it is a parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/simpleModelIR/normalize_ir.jl#L83-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.SimpleModelIR.recurse-Tuple{Expr, Vector{Expr}}" href="#QuantizedSystemSolver.SimpleModelIR.recurse-Tuple{Expr, Vector{Expr}}"><code>QuantizedSystemSolver.SimpleModelIR.recurse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">recurse(e::Expr,flattened::Vector{Expr})</code></pre><p>Break down a compound condition into basic components. This function recursively decomposes a condition expression into its basic components, flattening nested logical operators (&amp;&amp;, ||) into a list of expressions. It returns a vector of flattened expressions.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
ex=:(u &lt; 1 || u &gt; 10)
flattened = Expr[]
QuantizedSystemSolver.recurse(ex, flattened)
flattened

# output

2-element Vector{Expr}:
 :(u &lt; 1)
 :(u &gt; 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/simpleModelIR/normalize_ir.jl#L116-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.SimpleModelIR.decompose_condition-Tuple{Expr}" href="#QuantizedSystemSolver.SimpleModelIR.decompose_condition-Tuple{Expr}"><code>QuantizedSystemSolver.SimpleModelIR.decompose_condition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decompose_condition(cond::Expr)</code></pre><p>Break down a compound condition into basic components. Returns a tuple (kind, normalized conditions). where kind is :or or :and depending on the original condition.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
ex=:(u &lt; 1 || u &gt; 10)
(kind,flattened)=QuantizedSystemSolver.decompose_condition(ex)
(kind,flattened)

# output

(:or, Expr[:(u &lt; 1), :(u &gt; 10)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/simpleModelIR/normalize_ir.jl#L145-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.SimpleModelIR.to_zcf-Tuple{Expr}" href="#QuantizedSystemSolver.SimpleModelIR.to_zcf-Tuple{Expr}"><code>QuantizedSystemSolver.SimpleModelIR.to_zcf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">to_zcf(expr::Expr)</code></pre><p>Convert a condition expression to zero-crossing form. This function transforms a condition expression into a zero-crossing form (ZCF) by rearranging the terms. For example, it converts expressions like <code>A &lt; B</code> to <code>B - A</code> and <code>A &gt; B</code> to <code>A - B</code>. It is used to prepare conditions for further processing in the normalization of IRs.    </p><p><strong>Example:</strong></p><p>```jldoctest using QuantizedSystemSolver ex1 = :(u &gt; 10) ex2 = :(u &lt; 1) zcf1 = QuantizedSystemSolver.to<em>zcf(ex1) zcf2 = QuantizedSystemSolver.to</em>zcf(ex2) (zcf1, zcf2)</p><p><strong>output</strong></p><p>(:(u - 10), :(1 - u))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/simpleModelIR/normalize_ir.jl#L177-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.SimpleModelIR.process_if_condition-NTuple{5, Any}" href="#QuantizedSystemSolver.SimpleModelIR.process_if_condition-NTuple{5, Any}"><code>QuantizedSystemSolver.SimpleModelIR.process_if_condition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">process_if_condition(cond, stateVarName, discrParamName, param, helperFunSymSet)</code></pre><p>Processes an <code>if</code> condition within the intermediate representation (IR).</p><p><strong>Arguments</strong></p><ul><li><code>cond</code>: The condition expression to be processed.</li><li><code>stateVarName</code>: The name of the state variable involved in the condition.</li><li><code>discrParamName</code>: The name of the discrete parameter relevant to the condition.</li><li><code>param</code>: Additional parameters required for processing.</li><li><code>helperFunSymSet</code>: A set of helper function symbols used during processing.</li></ul><p><strong>Returns</strong></p><p>Returns the processed representation of the <code>if</code> condition, potentially transformed for normalization within the IR.</p><p><strong>Notes</strong></p><p>This function is intended for internal use in the normalization of IR.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/simpleModelIR/normalize_ir.jl#L204-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.SimpleModelIR.process_if_block-Tuple{Expr, Any, Any, Any, Any}" href="#QuantizedSystemSolver.SimpleModelIR.process_if_block-Tuple{Expr, Any, Any, Any, Any}"><code>QuantizedSystemSolver.SimpleModelIR.process_if_block</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">process_if_block(block_expr::Expr, stateVarName, discrParamName, param, helperFunSymSet)</code></pre><p>Processes an <code>if</code> block (body) expression within the intermediate representation (IR).</p><p><strong>Arguments</strong></p><ul><li><code>block_expr::Expr</code>: The Julia expression representing the <code>if</code> block to be processed.</li><li><code>stateVarName</code>: The name of the state variable involved in the block.</li><li><code>discrParamName</code>: The name  of the discrete variable.</li><li><code>param</code>: Additional parameter(s) required for processing the block.</li><li><code>helperFunSymSet</code>: A set of helper function symbols used during processing.</li></ul><p><strong>Returns</strong></p><ul><li>The processed <code>if</code> block body (change of variable names).</li></ul><p><strong>Notes</strong></p><ul><li>This function is intended for internal use within the IR normalization pipeline.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/simpleModelIR/normalize_ir.jl#L243-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.SimpleModelIR.process_if_expr-NTuple{5, Any}" href="#QuantizedSystemSolver.SimpleModelIR.process_if_expr-NTuple{5, Any}"><code>QuantizedSystemSolver.SimpleModelIR.process_if_expr</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">process_if_expr(statement,stateVarName,discrParamName,param,helperFunSymSet)</code></pre><p>Processes an <code>IfStatement</code> within the intermediate representation (IR) of a simple model.  This function normalizes the given <code>IfStatement</code> according to the provided state variable name, discrete variable name, additional parameters, and a set of helper function symbols:     - Applies variable substitution and body block processing.     - Decomposes composite conditions (&amp;&amp;, ||).</p><p><strong>Arguments</strong></p><ul><li><code>statement::IfStatement</code>: The <code>IfStatement</code> node to be processed.</li><li><code>stateVarName</code>: The name of the state variable relevant to the normalization.</li><li><code>discrParamName</code>: The name of the discretization parameter.</li><li><code>param</code>: Additional parameter(s) required for normalization.</li><li><code>helperFunSymSet</code>: A set of symbols representing helper functions used during normalization.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{IfStatement}</code>: A vector of normalized <code>IfStatement</code> objects resulting from the processing.</li></ul><p><strong>Notes</strong></p><p>This function is typically used as part of the IR normalization pipeline in the <code>SimpleModelIR</code> module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/simpleModelIR/normalize_ir.jl#L292-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.SimpleModelIR.normalize_ir-Tuple{Any, Symbol, Symbol}" href="#QuantizedSystemSolver.SimpleModelIR.normalize_ir-Tuple{Any, Symbol, Symbol}"><code>QuantizedSystemSolver.SimpleModelIR.normalize_ir</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize_ir(ir, stateVarName::Symbol, discrParamName::Symbol)</code></pre><p>Normalizes the intermediate representation (IR) of an ODE function.</p><p><strong>Arguments</strong></p><ul><li><code>ir::ODEFunctionIR</code>: The intermediate representation of the ODE function to be normalized.</li><li><code>stateVarName::Symbol</code>: The symbol representing the state variable in the IR.</li><li><code>discrParamName::Symbol</code>: The symbol representing the name of the discrete variable.</li></ul><p><strong>Returns</strong></p><ul><li>A normalized version of the input <code>ODEFunctionIR</code>.</li></ul><p><strong>Description</strong></p><p>This function processes the given ODE function IR, normalizing its structure with respect to the specified state variable and discretization parameter. The normalization includes renaming variables, swapping parameters, and decomposing composite if-statements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/41debd13396e9e7eb49f93aafade8bd5327cbb47/src/problem_generator/simpleModelIR/normalize_ir.jl#L406-L422">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../devIntro/">« Developer Guide</a><a class="docs-footer-nextpage" href="../intermediateRepresentation/">IR »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Saturday 12 July 2025 18:01">Saturday 12 July 2025</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
