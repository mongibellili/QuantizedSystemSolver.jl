<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Problem · Quantized System Solver</title><meta name="title" content="Problem · Quantized System Solver"/><meta property="og:title" content="Problem · Quantized System Solver"/><meta property="twitter:title" content="Problem · Quantized System Solver"/><meta name="description" content="Documentation for Quantized System Solver."/><meta property="og:description" content="Documentation for Quantized System Solver."/><meta property="twitter:description" content="Documentation for Quantized System Solver."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Quantized System Solver logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Quantized System Solver</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../../guide/userTutorial/">Tutorial</a></li><li><a class="tocitem" href="../../guide/userAPI/">User API</a></li></ul></li><li><span class="tocitem">Background</span><ul><li><a class="tocitem" href="../../background/introductoryResources/">Introduction to Quantized System Methods</a></li><li><a class="tocitem" href="../../background/qss/">Quantized State System Methods</a></li><li><a class="tocitem" href="../../background/liqss/">Linearly Implicit Quantized State System Methods</a></li><li><a class="tocitem" href="../../background/mliqss/">Modified Linearly Implicit Quantized State System Methods</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/linearTimeInvariantSystem/">Linear Time Invariant</a></li><li><a class="tocitem" href="../../examples/vanderpol/">Van der Pol</a></li><li><a class="tocitem" href="../../examples/tysonModel/">The Tyson Model</a></li><li><a class="tocitem" href="../../examples/adr/">ADR problem</a></li><li><a class="tocitem" href="../../examples/dosing/">Conditional Dosing in Pharmacometrics</a></li></ul></li><li><span class="tocitem">Developer resources</span><ul><li><a class="tocitem" href="../devIntro/">Developer Guide</a></li><li class="is-active"><a class="tocitem" href>Problem</a><ul class="internal"><li><a class="tocitem" href="#Problem-extension"><span>Problem extension</span></a></li><li><a class="tocitem" href="#Further-reading-about-the-functions-creating-the-problem"><span>Further reading about the functions creating the problem</span></a></li><li><a class="tocitem" href="#Helper-packages"><span>Helper packages</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../algorithm/">QSS Algorithms</a></li><li><a class="tocitem" href="../solve/">Solve</a></li><li><a class="tocitem" href="../integrator/">Integrators</a></li><li><a class="tocitem" href="../quantizer/">Quantizer</a></li><li><a class="tocitem" href="../solution/">Solution</a></li><li><a class="tocitem" href="../taylor/">Taylor Variables</a></li><li><a class="tocitem" href="../utils/">Utils references</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer resources</a></li><li class="is-active"><a href>Problem</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Problem</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/mongibellili/QuantizedSystemSolver.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/main/docs/src/developer/problem.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Problem"><a class="docs-heading-anchor" href="#Problem">Problem</a><a id="Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Problem" title="Permalink"></a></h1><p>The NLodeProblem function is the entry point for defining a new problem to be solved by the QSS solver. It takes user-provided code, which includes system parameters, variables, equations, and event logic, and constructs a Problem object that encapsulates all the necessary information for the solver to simulate the system such as problem dimensions, dependencies, and equations. The function works by parsing the user code and extracting relevant data to populate the Problem object.</p><h2 id="Problem-extension"><a class="docs-heading-anchor" href="#Problem-extension">Problem extension</a><a id="Problem-extension-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-extension" title="Permalink"></a></h2><p>Problem extension can be achieved easily via PRTYPE which is of type Val, or another subtype of this superclass can be created.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.NLODEProblem" href="#QuantizedSystemSolver.NLODEProblem"><code>QuantizedSystemSolver.NLODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NLODEProblem{PRTYPE,T,D,Z,CS}</code></pre><p>This is a superclass for all ODE problems. It is parametric on:</p><ul><li>The problem type PRTYPE.</li><li>The number of continuous variables T</li><li>The number of discrete events D</li><li>The number of events (zero crossing functions) Z</li><li>The cache size CS.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/commonQSS/qssAbstractTypes.jl#L2-L11">source</a></section></article><h3 id="What-is-needed-with-a-new-problem:"><a class="docs-heading-anchor" href="#What-is-needed-with-a-new-problem:">What is needed with a new problem:</a><a id="What-is-needed-with-a-new-problem:-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-needed-with-a-new-problem:" title="Permalink"></a></h3><p>The more different the new problem from the <code>NLODEContProblem</code>, the more functions are needed to be extended. In general the following functions need to be extended.</p><ul><li>The <code>NLodeProblemFunc</code> method to handle this problem.</li><li>The <code>integrate</code> method for this new type of problem.</li><li>The <code>custom_Solve</code> method if needed.</li></ul><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><pre><code class="language-julia hljs">struct SmallODEProblem{CS}&lt;: NLODEProblem{1,1,0,0,CS} 
  cacheSize::Val{CS}# CS= cache size 
  initConditions::Float64   
  eq::Function#function that holds the differential equation
end</code></pre><p>This new problem type takes care of one differential equation. There is no need for the Jacobian nor for the dependencies. This needs an extension of the custom_Solve method that just removes the references to the <code>jac</code> and the <code>SD</code>. An extension of the integrate method is also needed since the implementation is a lot simpler than what is currently implemented.</p><h2 id="Further-reading-about-the-functions-creating-the-problem"><a class="docs-heading-anchor" href="#Further-reading-about-the-functions-creating-the-problem">Further reading about the functions creating the problem</a><a id="Further-reading-about-the-functions-creating-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Further-reading-about-the-functions-creating-the-problem" title="Permalink"></a></h2><p><em>NLODEDiscProblem{PRTYPE,T,D,Z,CS}:</em> This is the struct that holds all the necessary data for a nonlinear ordinary differential equation (ODE)  problem with discrete events. The structure includes various fields such as initial conditions, discrete variables, Jacobians, event dependencies, and other data related to how the problem is formulated. This structure serves as the core data holder for the problem and will be used in the solver. It is a parametric abstract type that has the following parameters:</p><p>PRTYPE: The type of the problem (to distinguish between various types, and allow future extension of the solver to handle new types).</p><p>T: The number of continuous variables (state variables).</p><p>Z: The number of zero-crossing functions, which are used to detect events.</p><p>Y: The actual number of events.</p><p>CS: Cache size, which is used to store intermediate operations.</p><p>The use of abstract types in this context allows for flexibility and extensibility in the solver. By defining these abstract types, the code can be easily adapted to handle different types of problems, algorithms, and solutions without needing to modify the core solver logic. This design choice enhances the maintainability and scalability of the solver, making it easier to add new features or support additional problem types in the future.</p><p><strong>NLodeProblemFunc:</strong> After an initial preparation performed by the The NLodeProblem function, The function NLodeProblemFunc takes the resulting expressions to continue constructing an instance of the NLODEDiscProblem structure. It works in several key stages:</p><p><em>Initialization:</em> The function begins by initializing vectors and dictionaries that will hold equations (equs), Jacobian dependencies (jac), zero-crossing functions (ZCjac), and event dependencies. These serve to store the different types of equations and their relationships.</p><p><em>Processing ODEs:</em> It loops through each of the ODE expressions provided by the user. Depending on the type of expression (discrete variables, differential equations, or loop constructs), it processes the right-hand side (RHS) of the equation. For differential equations, it extracts dependencies to build the Jacobian and transform the equations into a more appropriate form for further use. Special cases are handled, such as if the RHS is a number or a symbol.</p><p><em>Handling Events:</em> The function also processes event-related constructs (if conditions) that correspond to different points where the system might undergo discrete changes. It process the RHS of the event equations, transforms them into a suitable form, and builds the necessary dependency structures. Specifically, it constructs how discrete and continuous variables influence one another through the events.</p><p><em>Constructing the Function Code:</em> After processing all ODEs and events, the function dynamically generates a Julia function code needed to store the system of ODEs and events. This code is built into a function that handles different cases (i.e., which equation to evaluate based on an index of a state change or an event).</p><p><strong>Building Dependencies:</strong> Several helper functions that build the dependencies between variables, events. They build dependency vectors that track how discrete and continous variables influence the system. This is used to know what variables to update and determine when specific events should be checked. By tracking the relationships between variables and events, the solver can determine the appropriate actions to take at each time step. The dependencies are stored in the following vectors:</p><p>-<span>$jac$</span>: It determines which variables affect a derivative.</p><p>-<span>$ZCjac$</span>: It determines which variables affect a zero-crossing function.</p><p>-<span>$SD$</span>: It determines which derivatives that are affected by a given variable.</p><p>-<span>$SZ$</span>: It determines which zero-crossing functions that are affected by a given variable.</p><p>-<span>$HZ$</span>: It tells which Zero-crossing functions influenced by a given event.</p><p>-<span>$HD$</span>: It tells which derivatives influenced by a given event.</p><p>Here&#39;s a quick summary and what each helper function is doing:</p><p><em>extractJacDepNormal:</em> It Extracts the dependencies for normal (non-loop) expressions. It updates the Jacobian matrix <span>$jac$</span> and a dictionary <span>$dD$</span> for tracking dependencies of derivatives to discrete variables.</p><p><em>extractJacDepLoop:</em> Similar to extractJacDepNormal, but specifically for loop expressions. It tracks dependencies across loop iterations.</p><p><em>extractZCJacDepNormal:</em> It Extracts zero-crossing Jacobian dependencies for discrete variables (<span>$dZ$</span>), and it updates <span>$zcjac$</span>, <span>$SZ$</span>.</p><p><em>createDependencyToEventsDiscr:</em> It maps discrete dependencies (dD, dZ) to specific events, it and constructs dependency matrices HZ and HD from the discrete variables only.</p><p><em>createDependencyToEventsCont:</em> Similar to createDependencyToEventsDiscr, but for continuous dependencies (SD, sZ), and it updates the matrices HZ and HD from the continuous variables only.</p><p><em>unionDependency:</em> Merges the two previous sets of dependencies (continuous and discrete) into the final matrices HZ and HD.</p><h2 id="Helper-packages"><a class="docs-heading-anchor" href="#Helper-packages">Helper packages</a><a id="Helper-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-packages" title="Permalink"></a></h2><p>The 𝑝𝑜𝑠𝑡𝑤𝑎𝑙𝑘 function from the MacroTools.jl (Copyright (c) 2015: Mike Innes) package plugs parameters and helper functions directly into the equations, and traverses the right-hand side of differential equations and zero-crossing functions, facilitating the construction of the Jacobian matrix and identifying variable dependencies. It also transforms specific expressions like 𝑞[1] into 𝑞[1] [0] within events, and converts 𝑞[𝑖] to 𝑞𝑖, making the equations more tractable for differentiation and Jacobian construction. Additionally, the @𝑐𝑎𝑝𝑡𝑢𝑟𝑒 macro efficiently handles cases where differential equations are defined within a for loop. </p><p>The diff(basi, symarg) function from the SymEngine.jl (Copyright (c) 2015-2017 Isuru Fernando) package is applied to perform symbolic differentiation, where basi is an expression and symarg is the symbol with respect to which the derivative is taken. This returns the partial derivative of the expression, making it particularly useful for deriving system Jacobians. </p><p>@code_string macro from the CodeTracking.jl (Copyright (c) 2019 Tim Holy) is used to get the body expression of the function that holds the problem given by the user. </p><p>@RuntimeGeneratedFunction from the RuntimeGeneratedFunctions.jl package (Copyright (c) 2020 Chris Rackauckas) is used to avoid world-age issues with the generated functions.</p><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><h3 id="Problem-definition"><a class="docs-heading-anchor" href="#Problem-definition">Problem definition</a><a id="Problem-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-definition" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.NLODEContProblem" href="#QuantizedSystemSolver.NLODEContProblem"><code>QuantizedSystemSolver.NLODEContProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NLODEContProblem{PRTYPE,T,D,Z,CS}</code></pre><p>A struct that holds the continuous problem. It has the following fields:  </p><ul><li><code>prname</code>: The name of the problem  </li><li><code>prtype</code>: The type of the problem  </li><li><code>a</code>: The size of the problem  </li><li><code>c</code>: The number of discrete events  </li><li><code>b</code>: The number of zero crossing functions  </li><li><code>cacheSize</code>: The size of the cache  </li><li><code>initConditions</code>: The initial conditions of the problem  </li><li><code>discreteVars</code> # to match the differentialEqation.jl interface that wants the parameter p to be part of the problem</li><li><code>eqs</code>: The function that holds all the ODEs  </li><li><code>jac</code>: The Jacobian dependency  </li><li><code>SD</code>: The state derivative dependency  </li><li><code>exactJac</code>: The exact Jacobian function  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDefinition.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.NLODEContProblemSpan" href="#QuantizedSystemSolver.NLODEContProblemSpan"><code>QuantizedSystemSolver.NLODEContProblemSpan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NLODEContProblemSpan{PRTYPE,T,D,Z,CS}</code></pre><p>A struct that holds the continuous problem with tspan. It has the following fields:  </p><ul><li><code>prname</code>: The name of the problem  </li><li><code>prtype</code>: The type of the problem  </li><li><code>a</code>: The size of the problem   </li><li><code>c</code>: The number of discrete vars </li><li><code>b</code>: The number of zero crossing functions </li><li><code>cacheSize</code>: The size of the cache  </li><li><code>initConditions</code>: The initial conditions of the problem  </li><li><code>discreteVars</code> # to match the differentialEqation.jl interface that wants the parameter p to be part of the problem</li><li><code>eqs</code>: The function that holds all the ODEs  </li><li><code>jac</code>: The Jacobian dependency  </li><li><code>SD</code>: The state derivative dependency  </li><li><code>exactJac</code>: The exact Jacobian function  </li><li><code>tspan::Tuple{Float64, Float64}</code>:  This field variable did not exist in the original NLODEContProblem as this simulation time should part of the problem. However, to match the differentialEqation.jl interface, the tspan is added to the definition of the problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDefinition.jl#L31-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.NLODEDiscProblem" href="#QuantizedSystemSolver.NLODEDiscProblem"><code>QuantizedSystemSolver.NLODEDiscProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NLODEDiscProblem{PRTYPE,T,D,Z,CS}</code></pre><p>A struct that holds the Problem of a system of ODEs with a set of events. It has the following fields:  </p><ul><li><code>prname::Symbol</code>  </li><li><code>prtype::Val{PRTYPE}</code>  </li><li><code>a::Val{T}</code> </li><li><code>c::Val{D}</code></li><li><code>b::Val{Z}</code>  </li><li><code>cacheSize::Val{CS}</code></li><li><code>initConditions::Vector{Float64}</code>  </li><li><code>discreteVars::Vector{Float64}</code>    </li><li><code>jac::Vector{Vector{Int}}</code>#Jacobian dependency..I have a der and I want to know which vars affect it...opposite of SD  </li><li><code>ZCjac::Vector{Vector{Int}}</code> # to update other Qs before checking ZCfunction  </li><li><code>eqs::Function</code>#function that holds all ODEs  </li><li><code>eventDependencies::Vector{EventDependencyStruct}</code>  </li><li><code>SD::Vector{Vector{Int}}</code>#  I have a var and I want the der that are affected by it  </li><li><code>HZ::Vector{Vector{Int}}</code>#  an ev occured and I want the ZC that are affected by it  </li><li><code>HD::Vector{Vector{Int}}</code>#  an ev occured and I want the der that are affected by it  </li><li><code>SZ::Vector{Vector{Int}}</code>#  I have a var and I want the ZC that are affected by it  </li><li><code>exactJac::Function</code> #used only in the implicit integration: linear approximation  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDefinition.jl#L65-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.NLODEDiscProblemSpan" href="#QuantizedSystemSolver.NLODEDiscProblemSpan"><code>QuantizedSystemSolver.NLODEDiscProblemSpan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NLODEDiscProblemSpan{PRTYPE,T,D,Z,CS}</code></pre><p>A struct that holds the Problem of a system of ODEs with a set of events with tspan. It has the following fields:     -<code>prname::Symbol</code>   -<code>prtype::Val{PRTYPE}</code>    -<code>a::Val{T}</code>   -<code>c::Val{D}</code>   -<code>b::Val{Z}</code>    -<code>cacheSize::Val{CS}</code>   -<code>initConditions::Vector{Float64}</code>     -<code>discreteVars::Vector{Float64}</code>      -<code>jac::Vector{Vector{Int}}</code>#Jacobian dependency..I have a der and I want to know which vars affect it...opposite of SD     -<code>ZCjac::Vector{Vector{Int}}</code> # to update other Qs before checking ZCfunction     -<code>eqs::Function</code>#function that holds all ODEs     -<code>eventDependencies::Vector{EventDependencyStruct}</code>    -<code>SD::Vector{Vector{Int}}</code>#  I have a var and I want the der that are affected by it     -<code>HZ::Vector{Vector{Int}}</code>#  an ev occured and I want the ZC that are affected by it     -<code>HD::Vector{Vector{Int}}</code>#  an ev occured and I want the der that are affected by it     -<code>SZ::Vector{Vector{Int}}</code>#  I have a var and I want the ZC that are affected by it     -<code>exactJac::Function</code>#used only in the implicit integration: linear approximation     -<code>tspan::Tuple{Float64, Float64}</code># This field variable did not exist in the original NLODEDiscProblem as this simulation time should part of the problem. However, to match the differentialEqation.jl interface, the tspan is added to the definition of the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDefinition.jl#L105-L126">source</a></section></article><h3 id="Problem-construction"><a class="docs-heading-anchor" href="#Problem-construction">Problem construction</a><a id="Problem-construction-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-construction" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">The examples of the continuous problem</header><div class="admonition-body"><p>All the examples that explain the problem construction functions use the following problem. The examples are reproducible as they are shown. To see the problem construction process in one step, add <code>print()</code> statements inside the functions of the package while solving this problem as shown in the tutorial section.</p><pre><code class="language-julia hljs">du[1] = u[2]-2.0*u[1]*u[2]
for k in 2:9  
du[k]=u[k]*u[k-1];
end 
du[10]=u[1]-u[10]</code></pre></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.NLodeProblemFunc-Union{Tuple{EM}, Tuple{D}, Tuple{T}, Tuple{Expr, Val{T}, Val{D}, Val{0}, Vector{Float64}, Symbol, Dict{Symbol, Expr}, Tuple{Float64, Float64}, Vector{EM}, Symbol}} where {T, D, EM}" href="#QuantizedSystemSolver.NLodeProblemFunc-Union{Tuple{EM}, Tuple{D}, Tuple{T}, Tuple{Expr, Val{T}, Val{D}, Val{0}, Vector{Float64}, Symbol, Dict{Symbol, Expr}, Tuple{Float64, Float64}, Vector{EM}, Symbol}} where {T, D, EM}"><code>QuantizedSystemSolver.NLodeProblemFunc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NLodeProblemFunc(odeExprs::Expr,::Val{T},::Val{D},::Val{0},initConditions::Vector{Float64},du::Symbol,symDict::Dict{Symbol,Expr},tspan::Tuple{Float64, Float64},discrVars::Vector{EM},prbName::Symbol) where {T,D,EM}</code></pre><p>This function continues building a continuous problem. it receives an expression and useful info from the main interface. it calls the transform function from the taylorEquationConstruction.jl file to change the AST of all operations to personlized ones and update the needed cache size. It also construct via helper functions the Exact jacobian function, the jacobian dependecy and the state-derivative dependency (opposite of jacobian) as vectors. Finally, it groups all differential equations in one function, and constructs a continous problem from the qssProblemDefinition.jl file.</p><p><strong>Arguments</strong></p><ul><li><code>odeExprs::Expr</code>: The expression of the whole user code in the function defining the problem with names modified and parameters plugged in.</li><li><code>Val{T}</code>: the dimensions of the system of differential equations.    </li><li><code>Val{0}</code>: No zero-crossing functions. pure continous problem.   </li><li><code>Val{0}</code>: No events functions. pure continous problem.  </li><li><code>initConditions::Vector{Float64}</code>: No zero-crossing functions. pure continous problem.  </li><li><code>du::Symbol</code>: to distinguish the start of a differential equations.  </li><li><code>symDict::Dict{Symbol,Expr}</code>: maps a reference expression to a symbol (qi-&gt;q[i]).  </li><li><code>tspan::Tuple{Float64, Float64}</code>: stores the initial time and final time of the simulation.  </li><li><code>prbName::Symbol</code>: The problem name as chosen by the user to be carried to the solution for displaying purposes.  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuous.jl#L2-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.NLodeProblemFunc-Union{Tuple{EM}, Tuple{Z}, Tuple{D}, Tuple{T}, Tuple{Expr, Val{T}, Val{D}, Val{Z}, Vector{Float64}, Symbol, Dict{Symbol, Expr}, Tuple{Float64, Float64}, Vector{EM}, Symbol}} where {T, D, Z, EM}" href="#QuantizedSystemSolver.NLodeProblemFunc-Union{Tuple{EM}, Tuple{Z}, Tuple{D}, Tuple{T}, Tuple{Expr, Val{T}, Val{D}, Val{Z}, Vector{Float64}, Symbol, Dict{Symbol, Expr}, Tuple{Float64, Float64}, Vector{EM}, Symbol}} where {T, D, Z, EM}"><code>QuantizedSystemSolver.NLodeProblemFunc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NLodeProblemFunc(odeExprs::Expr,::Val{T},::Val{D},::Val{Z},initCond::Vector{Float64},du::Symbol,symDict::Dict{Symbol,Expr},tspan::Tuple{Float64, Float64},discrVars::Vector{EM},prbName::Symbol) where {T,D,Z,EM}

    continues building a discrete problem. 
It receives an expression and useful info from the main interface. It calls the transform function from the taylorEquationConstruction.jl file to change the AST of all operations to personlized ones and update the needed cache size. It also construct via helper functions the Exact jacobian function, the jacobian dependecy (jac) and the state-derivative dependency (SD:opposite of jacobian), the state to zero-crossing dependency (SZ) and events to derivative and zero-crossing (HD and HZ) as vectors. Finally, it groups all differential equations and events in one function, and constructs a discrete problem from the qssProblemDefinition.jl file.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDiscrete.jl#L2-L7">source</a></section></article><h3 id="Problem-construction-helpers"><a class="docs-heading-anchor" href="#Problem-construction-helpers">Problem construction helpers</a><a id="Problem-construction-helpers-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-construction-helpers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.prepareInfo-Tuple{Expr, Symbol}" href="#QuantizedSystemSolver.prepareInfo-Tuple{Expr, Symbol}"><code>QuantizedSystemSolver.prepareInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prepareInfo(x::Expr,stateVarName::Symbol)</code></pre><p>Prepares information about the ODE problem by replacing symbols and parameters, and extracting information about size, symbols, and initial conditions.</p><p><strong>Arguments</strong></p><ul><li><code>x::Expr</code>: The expressions defining the ODE.</li><li><code>stateVarName::Symbol</code>: The symbol representing the continuous variables.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>probInfo</code> struct containing the number of zero-crossings (<code>numZC</code>) and a dictionary of symbols and expressions (<code>symDict</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/interface/main.jl#L73-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.probHelper" href="#QuantizedSystemSolver.probHelper"><code>QuantizedSystemSolver.probHelper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">probHelper</code></pre><p>In old interface, this holds information about the ODE problem. It helps the <a href="#QuantizedSystemSolver.arrangeProb-Tuple{Expr}"><code>arrangeProb</code></a> function to return the number of zero-crossings, a dictionary of symbols and expressions, and other information.</p><p><strong>Fields</strong></p><ul><li><code>problemSize::Int</code>: The size of the problem.</li><li><code>discreteSize::Int</code>: The size of the discrete variables.</li><li><code>numZC::Int</code>: The number of zero-crossings.</li><li><code>savedInitCond::Dict{Union{Int,Expr},Float64}</code>: A dictionary of initial conditions.</li><li><code>initConditions::Vector{Float64}</code>: The initial conditions.</li><li><code>du::Symbol</code>: The symbol representing the derivative of the continuous variables.</li><li><code>symDict::Dict{Symbol,Expr}</code>: A dictionary of symbols and expressions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/interface/macroInterface.jl#L67-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.arrangeProb-Tuple{Expr}" href="#QuantizedSystemSolver.arrangeProb-Tuple{Expr}"><code>QuantizedSystemSolver.arrangeProb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arrangeProb(x::Expr)</code></pre><p>in old interface, this prepares information about the ODE problem by replacing symbols and parameters, and extracting information about size, symbols, and initial conditions.</p><p><strong>Returns</strong></p><ul><li>A <code>probHelper</code> struct containing the number of zero-crossings (<code>numZC</code>), a dictionary of symbols and expressions (<code>symDict</code>), .</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/interface/macroInterface.jl#L93-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.eliminateRef-Tuple{Expr}" href="#QuantizedSystemSolver.eliminateRef-Tuple{Expr}"><code>QuantizedSystemSolver.eliminateRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eliminateRef(a::Expr)</code></pre><p>changes an expression in the form q[i] to an expression in the form qi inside differential equations and zero-crossing, needed to compute the symbolic differentiation. It also changes q[i+Number] to qiplusNumber, q[i-Number] to qiminusNumber, and q[i*Number] to qitimesNumber. It is called by the <a href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>extractJacDepNormal</code></a> and the <a href="#QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>extractJacDepLoop</code></a> functions.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
a=:(q[i - 1]) 
newa=QuantizedSystemSolver.eliminateRef(a)
(a,newa)

# output

(:(q[i - 1]), :qiminus1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuousHelper.jl#L28-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.changeExprToFirstValue-Tuple{Expr}" href="#QuantizedSystemSolver.changeExprToFirstValue-Tuple{Expr}"><code>QuantizedSystemSolver.changeExprToFirstValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeExprToFirstValue(ex::Expr)</code></pre><p>changes an expression in the form u[1] to an expression in the form u[1][0] inside exact jacobian expressions and inside events, because linear coefficients do not have derivatives and updates in events affect the value of a variable directly and there is no need to update its higher derivatives. It is called by the <a href="#QuantizedSystemSolver.restoreRef-Tuple{Any, Any}"><code>restoreRef</code></a> function for jacobian expressions, and called by the <a href="#QuantizedSystemSolver.NLodeProblemFunc-Union{Tuple{EM}, Tuple{D}, Tuple{T}, Tuple{Expr, Val{T}, Val{D}, Val{0}, Vector{Float64}, Symbol, Dict{Symbol, Expr}, Tuple{Float64, Float64}, Vector{EM}, Symbol}} where {T, D, EM}"><code>NLodeProblemFunc</code></a> function for events.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver 
ex=:(q[i - 1]) 
newEx=QuantizedSystemSolver.changeExprToFirstValue(ex)

# output

:((q[i - 1])[0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuousHelper.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.symbolFromRef-Tuple{Any}" href="#QuantizedSystemSolver.symbolFromRef-Tuple{Any}"><code>QuantizedSystemSolver.symbolFromRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symbolFromRef(refEx)</code></pre><p>gets a symbol qi, qiplusNumber, qiminusNumber, or qitimesNumber from a symbol i or expressions like i+Number, i+Number, i+Number.  It is called by the <a href="#QuantizedSystemSolver.changeVarNames_params-Tuple{Expr, Symbol, Symbol, Dict{Symbol, Union{Float64, Expr}}, Dict{Symbol, Expr}}"><code>changeVarNames_params</code></a>, the <a href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>extractJacDepNormal</code></a> and the <a href="#QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>extractJacDepLoop</code></a> functions</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
ex=:(i - 1) 
newEx=QuantizedSystemSolver.symbolFromRef(ex)
(ex,newEx)

# output

(:(i - 1), :qiminus1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuousHelper.jl#L61-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.symbolFromRefdiscrete-Tuple{Any}" href="#QuantizedSystemSolver.symbolFromRefdiscrete-Tuple{Any}"><code>QuantizedSystemSolver.symbolFromRefdiscrete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symbolFromRefdiscrete(refEx)</code></pre><p>Similar to <a href="#QuantizedSystemSolver.symbolFromRef-Tuple{Any}"><code>symbolFromRef</code></a>  but for discrete variables. It gets a symbol diplusNumber, diminusNumber, or ditimesNumber from expressions like i+Number, i+Number, i+Number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDiscreteHelper.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.restoreRef-Tuple{Any, Any}" href="#QuantizedSystemSolver.restoreRef-Tuple{Any, Any}"><code>QuantizedSystemSolver.restoreRef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">restoreRef(coefExpr,symDict)</code></pre><p>This function is the opposite of symbolFromRef. After using the symbols in symbolic differentiation, it gets back expressions like d[i+Number] and q[i+Number][0] from symbols diplusNumber and qiplusNumber. Adding a zero to q variables is beacause q is a taylor variable while d is a vector.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver

symDict= Dict{Symbol, Expr}(:qi =&gt; :(q[i]), :q10 =&gt; :(q[10]), :q2 =&gt; :(q[2]), :qiminus1 =&gt; :(q[i - 1]), :q1 =&gt; :(q[1]))
coefExpr=:(1.5qiminus1) 
  newEx=QuantizedSystemSolver.restoreRef(coefExpr, symDict)


# output

:(1.5 * (q[i - 1])[0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuousHelper.jl#L96-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.changeVarNames_params-Tuple{Expr, Symbol, Symbol, Dict{Symbol, Union{Float64, Expr}}, Dict{Symbol, Expr}}" href="#QuantizedSystemSolver.changeVarNames_params-Tuple{Expr, Symbol, Symbol, Dict{Symbol, Union{Float64, Expr}}, Dict{Symbol, Expr}}"><code>QuantizedSystemSolver.changeVarNames_params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeVarNames_params(ex::Expr,stateVarName::Symbol,muteVar::Symbol,param::Dict{Symbol,Union{Float64,Expr}},symDict::Dict{Symbol,Expr})</code></pre><p>As the name suggests, this changes the continuous variables names to :q and the discrete variable name to :d and any mute variables to :i. It also plugs the parameters values from a parameter dictionary into the differential equations. The function changeVarNames_params has three methods. One for RHS of equations, one for if-statements when RHS is an expression, and one for if-statements when RHS is a symbol. This is method one. It has an additional symDict::Dict{Symbol,Expr} to collect the translation of symbols of continous and discrete variables (q[i] &lt;-&gt; qi). </p><p><strong>arguments:</strong></p><ul><li><code>ex::Expr</code>: the expression to be changed</li><li><code>stateVarName::Symbol</code>: the name of the state variable</li><li><code>muteVar::Symbol</code>: the name of the mute variable</li><li><code>param::Dict{Symbol,Union{Float64,Expr}}</code>: the dictionary of parameters</li><li><code>symDict::Dict{Symbol,Expr}</code>: the dictionary to store the translation of symbols of continous and discrete variables (q[i] &lt;-&gt; qi)</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver

(ex, stateVarName, muteVar, param, symDict) = (:(du[k] = u[k] * u[k - 1] * coef2), :u, :k, Dict{Symbol, Union{Float64, Expr}}(:coef1 =&gt; 2.0, :coef2 =&gt; 1.5), Dict{Symbol, Expr}(:q2 =&gt; :(q[2]), :q1 =&gt; :(q[1])))

  newEx=QuantizedSystemSolver.changeVarNames_params(ex, stateVarName, muteVar, param, symDict)
(newEx, stateVarName, muteVar, param, symDict)
# output

(:(du[i] = q[i] * q[i - 1] * 1.5), :u, :k, Dict{Symbol, Union{Float64, Expr}}(:coef1 =&gt; 2.0, :coef2 =&gt; 1.5), Dict{Symbol, Expr}(:qi =&gt; :(q[i]), :q2 =&gt; :(q[2]), :qiminus1 =&gt; :(q[i - 1]), :q1 =&gt; :(q[1])))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuousHelper.jl#L126-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.changeVarNames_params-Tuple{Expr, Symbol, Symbol, Dict{Symbol, Union{Float64, Expr}}}" href="#QuantizedSystemSolver.changeVarNames_params-Tuple{Expr, Symbol, Symbol, Dict{Symbol, Union{Float64, Expr}}}"><code>QuantizedSystemSolver.changeVarNames_params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeVarNames_params(ex::Expr,stateVarName::Symbol,muteVar::Symbol,param::Dict{Symbol,Union{Float64,Expr}})</code></pre><p>This is method two for if-statements when RHS is an expression. Again, it changes the continuous variables name to :q and the discrete variable name to :d and any mute variables to :i. It also plugs the parameters values from a parameter dictionary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuousHelper.jl#L174-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.changeVarNames_params-Tuple{Symbol, Symbol, Symbol, Dict{Symbol, Union{Float64, Expr}}}" href="#QuantizedSystemSolver.changeVarNames_params-Tuple{Symbol, Symbol, Symbol, Dict{Symbol, Union{Float64, Expr}}}"><code>QuantizedSystemSolver.changeVarNames_params</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">changeVarNames_params(element::Symbol,stateVarName::Symbol,muteVar::Symbol,param::Dict{Symbol,Union{Float64,Expr}})</code></pre><p>This is method three of the function changeVarNames_params. It is for if-statements when RHS is a symbol. Again, it changes the symbol to :q if it is a continuous variable, to :d if it is a discrete variable, to :i if it is a mute variable, and to its corresponding value if it is a parameter. It is called by the <a href="#QuantizedSystemSolver.prepareInfo-Tuple{Expr, Symbol}"><code>prepareInfo</code></a> function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuousHelper.jl#L196-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.transformFSimplecase-Tuple{Any}" href="#QuantizedSystemSolver.transformFSimplecase-Tuple{Any}"><code>QuantizedSystemSolver.transformFSimplecase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transformFSimplecase(ex)</code></pre><p>transforms expressions of the right hand side of differential equations and zero-crossing functions to personalized ones that use caching to a form that can be used in the <a href="../taylor/#QuantizedSystemSolver.createT-Tuple{Taylor0, Taylor0}"><code>createT</code></a> function. The right hand side of the equations should be a number or a q[i] term.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
ex=:(q[2])
newEx=QuantizedSystemSolver.transformFSimplecase(ex);


# output

:(createT(q[2], cache[1]))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/taylorEquationConstruction.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.transformF-Tuple{Any}" href="#QuantizedSystemSolver.transformF-Tuple{Any}"><code>QuantizedSystemSolver.transformF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transformF(ex)</code></pre><p>transforms expressions of the right hand side of differential equations and zero-crossing functions to personalized ones that use caching to a form that can be used in functions like  <a href="../taylor/#QuantizedSystemSolver.addT-Tuple{Taylor0, Taylor0, Taylor0}"><code>addT</code></a>, <a href="../taylor/#QuantizedSystemSolver.subT-Tuple{Taylor0, Taylor0, Taylor0}"><code>subT</code></a>, <a href="../taylor/#QuantizedSystemSolver.mulT-Tuple{Taylor0, Taylor0, Taylor0}"><code>mulT</code></a>, <a href="../taylor/#QuantizedSystemSolver.muladdT-Union{Tuple{R}, Tuple{Q}, Tuple{P}, Tuple{P, Q, R, Taylor0}} where {P, Q, R&lt;:Union{Number, Taylor0}}"><code>muladdT</code></a>. The right hand side of the equations can be any form of expression.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
ex=:(q[2] - 2.0*q[1]*q[2],1)
newEx=QuantizedSystemSolver.transformF(ex);


# output

:((subT(q[2], mulTT(2.0, q[1], q[2], cache[2], cache[3]), cache[1]), 3))
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/taylorEquationConstruction.jl#L28-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}" href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>QuantizedSystemSolver.extractJacDepNormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> extractJacDepNormal(varNum::Int,rhs::Union{Int,Expr},jac :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}}, exactJacExpr :: Dict{Expr,Union{Float64,Int,Symbol,Expr}},symDict::Dict{Symbol,Expr})</code></pre><p>Extract the jacobian dependency as well as the exacte symbolic jacobian expression, in the form of dictionaries, from the simple differential equations.</p><p>The function sarts by looking for the &#39;i&#39; in q[i] in the RHS and storing this &#39;i&#39; in a jacSet for the varNum. Then, it changes q[i] to qi for symbolic differentiation. After finding <span>$\frac{\partial f_i}{\partial q_i}$</span> as the exact jacobian entry, it changes back qi to q[i]. Also, any mute variable from the differential equations is changed to &#39;i&#39; and the symbol for the variable is changed to &#39;q&#39;.</p><p><strong>example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
jac = Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}}()
exacteJacExpr = Dict{Expr,Union{Float64,Int,Symbol,Expr}}()
symDict=Dict(:q2 =&gt; :(q[2]), :q1 =&gt; :(q[1]))
varNum=1;rhs=:(q[2] - 2.0*q[1]*q[2]);
QuantizedSystemSolver.extractJacDepNormal(varNum,rhs,jac,exacteJacExpr ,symDict )
(jac,exacteJacExpr)

# output

(Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(1 =&gt; Set([2, 1])), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(:((1, 1)) =&gt; :(-2.0 * (q[2])[0]), :((1, 2)) =&gt; :(1 - 2.0 * (q[1])[0])))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuousHelper.jl#L216-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}" href="#QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>QuantizedSystemSolver.extractJacDepLoop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extractJacDepLoop(b::Int,niter::Int,rhs::Union{Int,Expr},jac :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}} ,exactJacExpr :: Dict{Expr,Union{Float64,Int,Symbol,Expr}},symDict::Dict{Symbol,Expr})</code></pre><p>This function is similar to the <a href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>extractJacDepNormal</code></a>  function by using the tuple (b,niter) instead of the integer varNum. It extracts the jacobian dependency as well as the exacte symbolic jacobian expression, in the form of dictionaries, from the differential equations that are written in a loop.</p><p>The keys of the exactJacExpr dictionary are more complex than in the case of simple differential equations. This complexity accounts for the fact the &#39;for&#39; loop contains many simple differential equations. This approach makes parsing of the problem agnostic of the problem size.    This function sarts by looking for the &#39;i&#39; in q[i] in the RHS and storing this &#39;i&#39; in a jacSet. Then, it changes q[i] to qi for symbolic differentiation. After finding <span>$\frac{\partial rhs}{\partial qi}$</span> as the exact jacobian entry, it changes back qi to q[i].</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
jac = Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}}()
exacteJacExpr = Dict{Expr,Union{Float64,Int,Symbol,Expr}}()
b,niter=2,9;
rhs=:(q[i] * q[i - 1]);
symDict=Dict(:qi =&gt; :(q[i]),  :q2 =&gt; :(q[2]), :q9 =&gt; :(q[9]), :qiminus1 =&gt; :(q[i - 1]), :q10 =&gt; :(q[10]), :q1 =&gt; :(q[1]))
QuantizedSystemSolver.extractJacDepLoop(b,niter,rhs,jac,exacteJacExpr ,symDict )
(jac,exacteJacExpr)

# output

(Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(:((2, 9)) =&gt; Set([:(i - 1), :i])), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(:(((2, 9), i - 1)) =&gt; :((q[i])[0]), :(((2, 9), i)) =&gt; :((q[i - 1])[0])))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuousHelper.jl#L258-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createJacVect-Union{Tuple{T}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{T}}} where T" href="#QuantizedSystemSolver.createJacVect-Union{Tuple{T}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{T}}} where T"><code>QuantizedSystemSolver.createJacVect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createJacVect(jac:: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},::Val{T}) where{T}</code></pre><p>constructs the jacobian dependency as a vector from the existing dictionary jac resulted from <a href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>extractJacDepNormal</code></a> and <a href="#QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>extractJacDepLoop</code></a> functions. </p><p>This function just collects the data from the value of the dictionary if the key of the dictionary is an integer. (a dictionary contains(key=&gt;value),...). In the case it is an expression :(b,niter), the function uses a &#39;for&#39; loop to replace each &#39;b&#39; by its corresponding integer. This approach depends on the size of the problem, but it runs one time.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
jac=Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(1 =&gt; Set([2, 1]),:((2, 9)) =&gt; Set([:(i - 1), :i]),10 =&gt; Set([1, 10]))
jacVect=QuantizedSystemSolver.createJacVect(jac,Val(10) )
string(jacVect)

# output

&quot;[[2, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [10, 1]]&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuousHelper.jl#L304-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createSDVect-Union{Tuple{T}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{T}}} where T" href="#QuantizedSystemSolver.createSDVect-Union{Tuple{T}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{T}}} where T"><code>QuantizedSystemSolver.createSDVect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createSDVect(jac:: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},::Val{T}) where{T}</code></pre><p>constructs the State to derivative dependency (opposite of jacobian dependency) as a vector from the existing dictionary jac resulted from the <a href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>extractJacDepNormal</code></a> and the <a href="#QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>extractJacDepLoop</code></a> functions. It is the opposite in the sense that here we collect the keys into some vectors whereas in the jacobian dependency we collect the values of the dictionary in some vectors. </p><p>If the key of the dictionary is an integer, then for all elements &#39;k&#39; in the value of the dictionary (a set), the key is pushed into a new vector indexed at &#39;k&#39;. In the case the key is an expression :(b,niter), the function uses a &#39;for&#39; loop to replace each &#39;b&#39; by its corresponding integer. This approach depends on the size of the problem, but it runs one time.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
jac=Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(1 =&gt; Set([2, 1]),:((2, 9)) =&gt; Set([:(i - 1), :i]),10 =&gt; Set([1, 10]));
SD=QuantizedSystemSolver.createSDVect(jac,Val(10) );
string(SD)

# output

&quot;[[10, 2, 1], [2, 3, 1], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9], [10]]&quot;
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuousHelper.jl#L350-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createExactJacFun-Tuple{Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol}" href="#QuantizedSystemSolver.createExactJacFun-Tuple{Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol}"><code>QuantizedSystemSolver.createExactJacFun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createExactJacFun(Exactjac:: Dict{Expr,Union{Float64,Int,Symbol,Expr}},funName::Symbol)</code></pre><p>constructs the exact jacobian entries as a function from the existing dictionary Exactjac resulted from extractJacDepNormal and extractJacDepLoop functions. </p><p>From the input dictionary exactJac, we see that the key is always a expression that hold a tuple of size 2: the first element is going to be the index &#39;i&#39; and the second element if the index &#39;j&#39;. The value corresponding to this key, which is the exact jacobian entry, is put in a cache. i.e the function maps the keys of the dictionary to their values using an &#39;if-statement.. This approach does not depend on the size of the problem.     # Example:   </p><pre><code class="language-julia hljs">using QuantizedSystemSolver
exacteJacExpr=Dict{Expr,Union{Float64,Int,Symbol,Expr}}(:((1, 1)) =&gt; :(-2.0 * (q[2])[0]), :((1, 2)) =&gt; :(1 - 2.0 * (q[1])[0]),:(((2, 9), i - 1)) =&gt; :((q[i])[0]), :(((2, 9), i)) =&gt; :((q[i - 1])[0]),:((10, 10)) =&gt; -1, :((10, 1)) =&gt; 1);
exactJac=QuantizedSystemSolver.createExactJacFun(exacteJacExpr,:f);
exactJac

# output

:(function exactJacf(q::Vector{Taylor0}, d::Vector{Float64}, cache::MVector{1, Float64}, i::Int, j::Int, t::Float64)
      if i == 0
          return nothing
      elseif i == 1 &amp;&amp; j == 1
          cache[1] = -2.0 * (q[2])[0]
          return nothing
      elseif i == 10 &amp;&amp; j == 10
          cache[1] = -1
          return nothing
      elseif 2 &lt;= i &lt;= 9 &amp;&amp; j == i - 1
          cache[1] = (q[i])[0]
          return nothing
      elseif i == 1 &amp;&amp; j == 2
          cache[1] = 1 - 2.0 * (q[1])[0]
          return nothing
      elseif 2 &lt;= i &lt;= 9 &amp;&amp; j == i
          cache[1] = (q[i - 1])[0]
          return nothing
      elseif i == 10 &amp;&amp; j == 1
          cache[1] = 1
          return nothing
      end
  end)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuousHelper.jl#L396-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createContEqFun-Tuple{Dict{Union{Int64, Expr}, Expr}, Symbol}" href="#QuantizedSystemSolver.createContEqFun-Tuple{Dict{Union{Int64, Expr}, Expr}, Symbol}"><code>QuantizedSystemSolver.createContEqFun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function createContEqFun(equs::Dict{Union{Int,Expr},Expr},funName::Symbol)</code></pre><p>constructs one function from all differential equations in the problem, which are transformed and stored in a dictionary in the NLodeProblemFunc function.</p><p>The function maps the keys of the dictionary to their values using an &#39;if-statement.     # Example:   </p><pre><code class="language-julia hljs">using QuantizedSystemSolver
equs = Dict{Union{Int64, Expr}, Expr}(10 =&gt; :(subT(q[1], q[10], cache[1])), :((2, 9)) =&gt; :(mulT(q[i], q[i - 1], cache[1])), 1 =&gt; :(subT(q[2], mulTT(2.0, q[1], q[2], cache[2], cache[3]), cache[1])));
diffEqfun=QuantizedSystemSolver.createContEqFun(equs,:f);
diffEqfun

# output

:(function f(i::Int, q::Vector{Taylor0}, t::Taylor0, d::Vector{Float64}, cache::Vector{Taylor0})
      if i == 0
          return nothing
      elseif i == 10
          subT(q[1], q[10], cache[1])
          return nothing
      elseif 2 &lt;= i &lt;= 9
          mulT(q[i], q[i - 1], cache[1])
          return nothing
      elseif i == 1
          subT(q[2], mulTT(2.0, q[1], q[2], cache[2], cache[3]), cache[1])
          return nothing
      end
  end)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemContinuousHelper.jl#L460-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.extractJacDepNormalDiscrete-Tuple{Int64, Union{Int64, Expr, Symbol}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}" href="#QuantizedSystemSolver.extractJacDepNormalDiscrete-Tuple{Int64, Union{Int64, Expr, Symbol}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>QuantizedSystemSolver.extractJacDepNormalDiscrete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extractJacDepNormalDiscrete(varNum::Int,rhs::Union{Symbol,Int,Expr},jac :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},exactJacExpr :: Dict{Expr,Union{Float64,Int,Symbol,Expr}},symDict::Dict{Symbol,Expr},dD :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}})</code></pre><p>Extracts the jacobian dependency (jac) as well as the exacte symbolic jacobian expression (exactJacExpr) and the dependency of state derivatives to discrete variables (dD), in the form of dictionaries, from the simple differential equations.</p><p>For the continuous part, similar to <a href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>extractJacDepNormal</code></a>  function, this function sarts by looking for the &#39;i&#39; in q[i] in the RHS and storing this &#39;i&#39; in a jacSet for the varNum. Then, it changes q[i] to qi for symbolic differentiation. After finding <span>$\frac{\partial f_i}{\partial q_i}$</span> as the exact jacobian entry, it changes back qi to q[i]. Also, any mute variable from the differential equations is changed to &#39;i&#39;.</p><p>For the discrete part, the function puts the index of the differential equation in a set, and stores this set in a dictionary dD with the key being the index of the discrete variable.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
(varNum, rhs, jac, exactJacExpr, symDict, dD) = (1, :(d[2] - 2.0 * q[1] * d[2]), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(), Dict{Symbol, Expr}(:q10 =&gt; :(q[10]), :d2 =&gt; :(d[2]), :qiminus1 =&gt; :(q[i - 1]), :d1 =&gt; :(d[1]), :q1 =&gt; :(q[1])), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}())
QuantizedSystemSolver.extractJacDepNormalDiscrete(varNum, rhs, jac, exactJacExpr, symDict, dD )
(jac, exactJacExpr, dD) 

# output

(Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(1 =&gt; Set([1])), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(:((1, 1)) =&gt; :(-2.0 * d[2])), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(2 =&gt; Set([1])))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDiscreteHelper.jl#L40-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.extractJacDepLoopDiscrete-Tuple{Int64, Int64, Union{Int64, Expr, Symbol}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}" href="#QuantizedSystemSolver.extractJacDepLoopDiscrete-Tuple{Int64, Int64, Union{Int64, Expr, Symbol}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>QuantizedSystemSolver.extractJacDepLoopDiscrete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extractJacDepLoopDiscrete(b::Int,niter::Int,rhs::Union{Symbol,Int,Expr},jac :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}},exactJacExpr :: Dict{Expr,Union{Float64,Int,Symbol,Expr}},symDict::Dict{Symbol,Expr},dD :: Dict{Union{Int,Expr},Set{Union{Int,Symbol,Expr}}})</code></pre><p>This function is similar to the <a href="#QuantizedSystemSolver.extractJacDepNormalDiscrete-Tuple{Int64, Union{Int64, Expr, Symbol}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>extractJacDepNormalDiscrete</code></a>  function by using the tuple (b,niter) instead of the integer varNum. Itextracts the jacobian dependency (jac) as well as the exacte symbolic jacobian expression (exactJacExpr) and the dependency of state derivatives to discrete variables (dD), in the form of dictionaries, from the differential equations that are written in a loop.</p><p>For the continuous part, it sarts by looking for the &#39;i&#39; in q[i] in the RHS and storing this &#39;i&#39; in a jacSet. Then, it changes q[i] to qi for symbolic differentiation. After finding <span>$\frac{\partial f_i}{\partial q_i}$</span> as the exact jacobian entry, it changes back qi to q[i]. Also, any mute variable from the differential equations is changed to &#39;i&#39;.</p><p>For the discrete part, the function puts the the tuple (b,niter) in a set, and stores this set in a dictionary dD with the key being the index of the discrete variable.     # Example:</p><pre><code class="language-julia hljs">using QuantizedSystemSolver
(b, niter, rhs, jac, exactJacExpr, symDict, dD) = (2, 9, :(d[1] * q[i - 1] * 1.5), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(1 =&gt; Set([1])), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(:((1, 1)) =&gt; :(-2.0 * d[2])), Dict{Symbol, Expr}(:q10 =&gt; :(q[10]), :d2 =&gt; :(d[2]), :qiminus1 =&gt; :(q[i - 1]), :d1 =&gt; :(d[1]), :q1 =&gt; :(q[1])), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(2 =&gt; Set([1])))
QuantizedSystemSolver.extractJacDepLoopDiscrete(b, niter, rhs, jac, exactJacExpr, symDict, dD )
(jac, exactJacExpr, dD) 

# output

(Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(:((2, 9)) =&gt; Set([:(i - 1)]), 1 =&gt; Set([1])), Dict{Expr, Union{Float64, Int64, Expr, Symbol}}(:((1, 1)) =&gt; :(-2.0 * d[2]), :(((2, 9), i - 1)) =&gt; :(1.5 * d[1])), Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(2 =&gt; Set([1]), 1 =&gt; Set([:((2, 9))])))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDiscreteHelper.jl#L91-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.extractZCJacDepNormal-Tuple{Int64, Expr, Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Dict{Int64, Set{Int64}}}" href="#QuantizedSystemSolver.extractZCJacDepNormal-Tuple{Int64, Expr, Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Dict{Int64, Set{Int64}}}"><code>QuantizedSystemSolver.extractZCJacDepNormal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extractZCJacDepNormal(counter::Int,zcf::Expr,zcjac :: Vector{Vector{Int}},SZ ::Dict{Int,Set{Int}},dZ :: Dict{Int,Set{Int}})</code></pre><p>Extracts the zero-crossing jacobian dependency as a vector (zcjac), the dependency of the zero-crossing functions to continuous (SZ) and discrete variables (dZ) in the form of dictionaries, from the &#39;if-statements&#39; (zcf).</p><p>The zcjac is a vector of vectors, where each vector contains the indices of the continuous variables that the zero-crossing function depends on. The SZ dictionary contains the indices of the zero-crossing functions as values and the indices of the continuous variables as keys. Similarly, the dZ dictionary contains the indices of the zero-crossing functions as values and the indices of the discrete variables as keys.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
(counter, zcf, zcjac, SZ, dZ) = (2, :(q[2] - d[1]), [[1]], Dict{Int64, Set{Int64}}(1 =&gt; Set([1])), Dict{Int64, Set{Int64}}())
QuantizedSystemSolver.extractZCJacDepNormal(counter, zcf, zcjac, SZ, dZ)
(zcjac, SZ, dZ) 

# output

([[1], [2]], Dict{Int64, Set{Int64}}(2 =&gt; Set([2]), 1 =&gt; Set([1])), Dict{Int64, Set{Int64}}(1 =&gt; Set([2])))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDiscreteHelper.jl#L140-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.EventDependencyStruct" href="#QuantizedSystemSolver.EventDependencyStruct"><code>QuantizedSystemSolver.EventDependencyStruct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EventDependencyStruct</code></pre><p>A struct that holds the event dependency information. It has the following fields:</p><ul><li><code>id::Int:</code> the id of the event</li><li><code>evCont::Vector{Int}:</code> the index tracking used for HD &amp; HZ. Also it is used to update q,quantum,recomputeNext when x is modified in an event</li><li><code>evDisc::Vector{Int}:</code> the index tracking used for HD &amp; HZ.</li><li><code>evContRHS::Vector{Int}:</code> the index tracking used to update other Qs before executing the event</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDiscreteHelper.jl#L24-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createSZvect-Union{Tuple{T}, Tuple{Dict{Int64, Set{Int64}}, Val{T}}} where T" href="#QuantizedSystemSolver.createSZvect-Union{Tuple{T}, Tuple{Dict{Int64, Set{Int64}}, Val{T}}} where T"><code>QuantizedSystemSolver.createSZvect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createSZvect(SZ :: Dict{Int64, Set{Int64}},::Val{T}) where{T}</code></pre><p>constructs the zero-crossing dependency to state variables as a vector from the existing dictionary SZ resulted from the <a href="#QuantizedSystemSolver.extractZCJacDepNormal-Tuple{Int64, Expr, Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Dict{Int64, Set{Int64}}}"><code>extractZCJacDepNormal</code></a> function. The continuous variables are the keys and the zero-crossing are the values.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
(SZ, T) = (Dict{Int64, Set{Int64}}(2 =&gt; Set([2]), 1 =&gt; Set([1])), 10)
szVec=QuantizedSystemSolver.createSZvect(SZ, Val(T))
string(szVec)

# output

&quot;[[1], [2], Int64[], Int64[], Int64[], Int64[], Int64[], Int64[], Int64[], Int64[]]&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDiscreteHelper.jl#L184-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createdDvect-Union{Tuple{D}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{D}}} where D" href="#QuantizedSystemSolver.createdDvect-Union{Tuple{D}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{D}}} where D"><code>QuantizedSystemSolver.createdDvect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createdDvect(dD::Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}},::Val{D}) where{D}</code></pre><p>constructs the State to derivative dependency to discrete variables as a vector from the existing dictionary dD resulted from the <a href="#QuantizedSystemSolver.extractJacDepNormalDiscrete-Tuple{Int64, Union{Int64, Expr, Symbol}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>extractJacDepNormalDiscrete</code></a> and the <a href="#QuantizedSystemSolver.extractJacDepLoopDiscrete-Tuple{Int64, Int64, Union{Int64, Expr, Symbol}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>extractJacDepLoopDiscrete</code></a> functions. The discrete variables are the keys and the differential equations are the values. This dependency is needed only in <a href="#QuantizedSystemSolver.createDependencyToEventsDiscr-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}"><code>createDependencyToEventsDiscr</code></a>  .</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
(dD, D) = (Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}(2 =&gt; Set([10, 1]), 1 =&gt; Set([:((2, 9))])), 2)
dDVect=QuantizedSystemSolver.createdDvect(dD, Val(D) )
string(dDVect)

# output

&quot;[[2, 3, 4, 5, 6, 7, 8, 9], [10, 1]]&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDiscreteHelper.jl#L211-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createDependencyToEventsDiscr-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}" href="#QuantizedSystemSolver.createDependencyToEventsDiscr-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}"><code>QuantizedSystemSolver.createDependencyToEventsDiscr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createDependencyToEventsDiscr(dD::Vector{Vector{Int}},dZ::Dict{Int64, Set{Int64}},eventDep::Vector{EventDependencyStruct})</code></pre><p>constructs the dependency of zero-crossing functions and state derivatives to events using only discrete variables.</p><p><strong>arguments</strong></p><ul><li><code>dD::Vector{Vector{Int}}:</code> the dependency of state derivatives to discrete variables as a vector</li><li><code>dZ::Dict{Int64, Set{Int64}}:</code> the dependency of zero-crossing functions to discrete variables as a dictionary</li><li><code>eventDep::Vector{EventDependencyStruct}:</code> the event dependency information as a vector of structs</li></ul><p><strong>returns</strong></p><ul><li><p><code>HZ1::Vector{Vector{Int}}:</code> the dependency of zero-crossing functions to events using only discrete variables</p></li><li><p><code>HD1::Vector{Vector{Int}}:</code> the dependency of differential equations to events using only discrete variables</p><p><strong>Example:</strong></p></li></ul><pre><code class="language-julia hljs">using QuantizedSystemSolver
(dD, dZ, eventDep) = ([[2, 3, 4, 5, 6, 7, 8, 9], [10, 1]], Dict{Int64, Set{Int64}}(1 =&gt; Set([2])), QuantizedSystemSolver.EventDependencyStruct[QuantizedSystemSolver.EventDependencyStruct(1, Int64[], [1], Int64[]), QuantizedSystemSolver.EventDependencyStruct(2, Int64[], Int64[], Int64[]), QuantizedSystemSolver.EventDependencyStruct(3, [3], [2], [3, 1, 2]), QuantizedSystemSolver.EventDependencyStruct(4, Int64[], Int64[], Int64[])])
(HZ1, HD1) =QuantizedSystemSolver.createDependencyToEventsDiscr(dD, dZ, eventDep )
(HZ1, HD1) 

# output

([[2], Int64[], Int64[], Int64[]], [[5, 4, 6, 7, 2, 9, 8, 3], Int64[], [10, 1], Int64[]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDiscreteHelper.jl#L248-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.createDependencyToEventsCont-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}" href="#QuantizedSystemSolver.createDependencyToEventsCont-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}"><code>QuantizedSystemSolver.createDependencyToEventsCont</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createDependencyToEventsCont(SD::Vector{Vector{Int}},sZ::Dict{Int64, Set{Int64}},eventDep::Vector{EventDependencyStruct})</code></pre><p>constructs the dependency of zero-crossing functions and state derivatives to events using only continuous variables.</p><p><strong>arguments</strong></p><ul><li><code>SD::Vector{Vector{Int}}:</code> the dependency of state derivatives to continuous variables as a vector</li><li><code>sZ::Dict{Int64, Set{Int64}}:</code> the dependency of zero-crossing functions to continuous variables as a dictionary</li><li><code>eventDep::Vector{EventDependencyStruct}:</code> the event dependency information as a vector of structs</li></ul><p><strong>returns</strong></p><ul><li><p><code>HZ2::Vector{Vector{Int}}:</code> the dependency of zero-crossing functions to events using only continuous variables</p></li><li><p><code>HD2::Vector{Vector{Int}}:</code> the dependency of differential equations to events using only continuous variables</p><p><strong>Example:</strong></p></li></ul><pre><code class="language-julia hljs">using QuantizedSystemSolver
(SD, sZ, eventDep) = ([[10, 2, 1], [3], [4], [5], [6], [7], [8], [9], Int64[], [10]], Dict{Int64, Set{Int64}}(2 =&gt; Set([2]), 1 =&gt; Set([1])), QuantizedSystemSolver.EventDependencyStruct[QuantizedSystemSolver.EventDependencyStruct(1, Int64[], [1], Int64[]), QuantizedSystemSolver.EventDependencyStruct(2, Int64[], Int64[], Int64[]), QuantizedSystemSolver.EventDependencyStruct(3, [3], [2], [3, 1, 2]), QuantizedSystemSolver.EventDependencyStruct(4, Int64[], Int64[], Int64[])])
(HZ2, HD2) =QuantizedSystemSolver.createDependencyToEventsCont(SD, sZ, eventDep)
(HZ2, HD2) 

# output

([Int64[], Int64[], Int64[], Int64[]], [Int64[], Int64[], [4], Int64[]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDiscreteHelper.jl#L304-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="QuantizedSystemSolver.unionDependency-Tuple{Vector{Vector{Int64}}, Vector{Vector{Int64}}}" href="#QuantizedSystemSolver.unionDependency-Tuple{Vector{Vector{Int64}}, Vector{Vector{Int64}}}"><code>QuantizedSystemSolver.unionDependency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unionDependency(HZD1::Vector{Vector{Int}},HZD2::Vector{Vector{Int}})</code></pre><p>merges the state derivatives and zero-crossing functions dependencies to events using both continuous and discrete variables.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">using QuantizedSystemSolver
(HD1, HD2) = ([[5, 4, 6, 7, 2, 9, 8, 3], Int64[], [10, 1], Int64[]], [Int64[], Int64[], [4], Int64[]])
HD=QuantizedSystemSolver.unionDependency(HD1, HD2)
string(HD)

# output

&quot;[[5, 4, 6, 7, 2, 9, 8, 3], Int64[], [4, 10, 1], Int64[]]&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mongibellili/QuantizedSystemSolver.jl/blob/b66f5e633e798d8bec2e0166830ec805e7c6c6c7/src/problem/qssProblemDiscreteHelper.jl#L359-L374">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#QuantizedSystemSolver.EventDependencyStruct"><code>QuantizedSystemSolver.EventDependencyStruct</code></a></li><li><a href="#QuantizedSystemSolver.NLODEContProblem"><code>QuantizedSystemSolver.NLODEContProblem</code></a></li><li><a href="#QuantizedSystemSolver.NLODEContProblemSpan"><code>QuantizedSystemSolver.NLODEContProblemSpan</code></a></li><li><a href="#QuantizedSystemSolver.NLODEDiscProblem"><code>QuantizedSystemSolver.NLODEDiscProblem</code></a></li><li><a href="#QuantizedSystemSolver.NLODEDiscProblemSpan"><code>QuantizedSystemSolver.NLODEDiscProblemSpan</code></a></li><li><a href="#QuantizedSystemSolver.NLODEProblem"><code>QuantizedSystemSolver.NLODEProblem</code></a></li><li><a href="#QuantizedSystemSolver.probHelper"><code>QuantizedSystemSolver.probHelper</code></a></li><li><a href="#QuantizedSystemSolver.NLodeProblemFunc-Union{Tuple{EM}, Tuple{Z}, Tuple{D}, Tuple{T}, Tuple{Expr, Val{T}, Val{D}, Val{Z}, Vector{Float64}, Symbol, Dict{Symbol, Expr}, Tuple{Float64, Float64}, Vector{EM}, Symbol}} where {T, D, Z, EM}"><code>QuantizedSystemSolver.NLodeProblemFunc</code></a></li><li><a href="#QuantizedSystemSolver.NLodeProblemFunc-Union{Tuple{EM}, Tuple{D}, Tuple{T}, Tuple{Expr, Val{T}, Val{D}, Val{0}, Vector{Float64}, Symbol, Dict{Symbol, Expr}, Tuple{Float64, Float64}, Vector{EM}, Symbol}} where {T, D, EM}"><code>QuantizedSystemSolver.NLodeProblemFunc</code></a></li><li><a href="#QuantizedSystemSolver.arrangeProb-Tuple{Expr}"><code>QuantizedSystemSolver.arrangeProb</code></a></li><li><a href="#QuantizedSystemSolver.changeExprToFirstValue-Tuple{Expr}"><code>QuantizedSystemSolver.changeExprToFirstValue</code></a></li><li><a href="#QuantizedSystemSolver.changeVarNames_params-Tuple{Expr, Symbol, Symbol, Dict{Symbol, Union{Float64, Expr}}, Dict{Symbol, Expr}}"><code>QuantizedSystemSolver.changeVarNames_params</code></a></li><li><a href="#QuantizedSystemSolver.changeVarNames_params-Tuple{Expr, Symbol, Symbol, Dict{Symbol, Union{Float64, Expr}}}"><code>QuantizedSystemSolver.changeVarNames_params</code></a></li><li><a href="#QuantizedSystemSolver.changeVarNames_params-Tuple{Symbol, Symbol, Symbol, Dict{Symbol, Union{Float64, Expr}}}"><code>QuantizedSystemSolver.changeVarNames_params</code></a></li><li><a href="#QuantizedSystemSolver.createContEqFun-Tuple{Dict{Union{Int64, Expr}, Expr}, Symbol}"><code>QuantizedSystemSolver.createContEqFun</code></a></li><li><a href="#QuantizedSystemSolver.createDependencyToEventsCont-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}"><code>QuantizedSystemSolver.createDependencyToEventsCont</code></a></li><li><a href="#QuantizedSystemSolver.createDependencyToEventsDiscr-Tuple{Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Vector{EventDependencyStruct}}"><code>QuantizedSystemSolver.createDependencyToEventsDiscr</code></a></li><li><a href="#QuantizedSystemSolver.createExactJacFun-Tuple{Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Symbol}"><code>QuantizedSystemSolver.createExactJacFun</code></a></li><li><a href="#QuantizedSystemSolver.createJacVect-Union{Tuple{T}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{T}}} where T"><code>QuantizedSystemSolver.createJacVect</code></a></li><li><a href="#QuantizedSystemSolver.createSDVect-Union{Tuple{T}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{T}}} where T"><code>QuantizedSystemSolver.createSDVect</code></a></li><li><a href="#QuantizedSystemSolver.createSZvect-Union{Tuple{T}, Tuple{Dict{Int64, Set{Int64}}, Val{T}}} where T"><code>QuantizedSystemSolver.createSZvect</code></a></li><li><a href="#QuantizedSystemSolver.createdDvect-Union{Tuple{D}, Tuple{Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Val{D}}} where D"><code>QuantizedSystemSolver.createdDvect</code></a></li><li><a href="#QuantizedSystemSolver.eliminateRef-Tuple{Expr}"><code>QuantizedSystemSolver.eliminateRef</code></a></li><li><a href="#QuantizedSystemSolver.extractJacDepLoop-Tuple{Int64, Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>QuantizedSystemSolver.extractJacDepLoop</code></a></li><li><a href="#QuantizedSystemSolver.extractJacDepLoopDiscrete-Tuple{Int64, Int64, Union{Int64, Expr, Symbol}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>QuantizedSystemSolver.extractJacDepLoopDiscrete</code></a></li><li><a href="#QuantizedSystemSolver.extractJacDepNormal-Tuple{Int64, Union{Int64, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}}"><code>QuantizedSystemSolver.extractJacDepNormal</code></a></li><li><a href="#QuantizedSystemSolver.extractJacDepNormalDiscrete-Tuple{Int64, Union{Int64, Expr, Symbol}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}, Dict{Expr, Union{Float64, Int64, Expr, Symbol}}, Dict{Symbol, Expr}, Dict{Union{Int64, Expr}, Set{Union{Int64, Expr, Symbol}}}}"><code>QuantizedSystemSolver.extractJacDepNormalDiscrete</code></a></li><li><a href="#QuantizedSystemSolver.extractZCJacDepNormal-Tuple{Int64, Expr, Vector{Vector{Int64}}, Dict{Int64, Set{Int64}}, Dict{Int64, Set{Int64}}}"><code>QuantizedSystemSolver.extractZCJacDepNormal</code></a></li><li><a href="#QuantizedSystemSolver.prepareInfo-Tuple{Expr, Symbol}"><code>QuantizedSystemSolver.prepareInfo</code></a></li><li><a href="#QuantizedSystemSolver.restoreRef-Tuple{Any, Any}"><code>QuantizedSystemSolver.restoreRef</code></a></li><li><a href="#QuantizedSystemSolver.symbolFromRef-Tuple{Any}"><code>QuantizedSystemSolver.symbolFromRef</code></a></li><li><a href="#QuantizedSystemSolver.symbolFromRefdiscrete-Tuple{Any}"><code>QuantizedSystemSolver.symbolFromRefdiscrete</code></a></li><li><a href="#QuantizedSystemSolver.transformF-Tuple{Any}"><code>QuantizedSystemSolver.transformF</code></a></li><li><a href="#QuantizedSystemSolver.transformFSimplecase-Tuple{Any}"><code>QuantizedSystemSolver.transformFSimplecase</code></a></li><li><a href="#QuantizedSystemSolver.unionDependency-Tuple{Vector{Vector{Int64}}, Vector{Vector{Int64}}}"><code>QuantizedSystemSolver.unionDependency</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../devIntro/">« Developer Guide</a><a class="docs-footer-nextpage" href="../algorithm/">QSS Algorithms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 9 December 2024 14:17">Monday 9 December 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
